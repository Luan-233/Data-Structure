# 有关各种数据结构&求解思想及应用

by Luan_233

### 线性数据结构

----

#### 栈

+ 单调栈

  用于求解一个序列中，某一个元素向左或向右第一个大于或小于的位置。

  + 

  + 

+ 表达式的求值

----

#### 队列

+ 单调队列

  用于求解定长区间内的最大最小值。

  + 例题1：洛谷P1886 滑动窗口
  + 例题2：洛谷P2216 [HAOI2007]理想的正方形

  + 例题3：洛谷P3512 [POI2010]PIL-Pilots
  + 例题4：洛谷P3594 [POI2015]WIL-Wilcze doły

+ DP优化
  + 区间最值型优化
    + 例题1：洛谷P3957 [NOIP2017 普及组] 跳房子
    + 例题2：洛谷P2254 [NOI2005] 瑰丽华尔兹
    + 例题3：洛谷P2569 [SCOI2010]股票交易
    + 例题4：洛谷P5665 [CSP-S2019] 划分
    + 例题5：洛谷P7832 [CCO2021] Bread First Search
  + 斜率优化
    + 例题1：洛谷P3195 [HNOI2008]玩具装箱
    + 例题2：洛谷P3628 [APIO2010]特别行动队
    + 例题3：洛谷P2120 [ZJOI2007]仓库建设
    + 例题4：洛谷P2900 [USACO08MAR]Land Acquisition G
  + 多重背包的优化

----

#### 哈希表

用于在期望时间复杂度常数的情况下维护集合或者实现映射。

----

### 维护集合的数据结构

----

#### 堆

堆是一种用于维护集合最值、插入元素、删除最值的数据结构。

+ 对顶堆
+ 左偏树
+ 配对堆
+ 可持久化可并堆
+ 用于一些调整型的贪心优化

----

#### 并查集

并查集用于集合的合并，以及查询两个元素是否在同一个集合内。下面介绍若干种并查集使用手法和扩展，以及适于求解的问题。

+ 路径压缩
  + 实现手法
  + 复杂度分析
+ 按秩合并
  + 实现手法
  + 复杂度分析
+ 带有偏移量的并查集
+ 实体化的并查集应用：克鲁斯卡尔重构树
  + 例题1：洛谷P7834 [ONTAK2010] Peaks 加强版
  + 例题2：洛谷P4768 [NOI2018] 归程
  + 例题3：洛谷P4899 [IOI2018] werewolf 狼人

----

#### Treap

用于维护集合的数据结构。每个节点含有两个关键字，一个用于维护元素，使得整棵树满足中序遍历单调；另一个用于维护树的形态，使得树随时满足堆的性质。所以说Treap是笛卡尔树的一种。

+ 具体实现手法

  每个二叉树结点记录一个随机出来的优先级，单点插入删除只需要进行左旋右旋保证堆性质。

+ 复杂度分析

  

----

#### 替罪羊树

用于维护集合的数据结构。

+ 具体实现手法

  每个二叉树结点记录子树的$size$，设定一个阈值$\alpha$，我们认为一个结点不平衡当且仅当$\frac{max(size(ls),size(rs))}{size} > \alpha$，在插入时候若不平衡，则取出中序遍历按照建立二叉树的方式重构子树。一般$\alpha$取值在$0.75-0.85$。

+ 复杂度分析

  对于一棵替罪羊树，设势能函数
  $$
  \phi(T)=c\sum_{cur \in T} |size(cur.ls)-size(cur.rs)|
  $$

  其中$c$是一个与$\alpha$有关的常数，容易证明一棵替罪羊树的高度一定是对数级别的，考虑一次插入一个点会最多给势能提升多少，显然是$c$倍的树的高度，是$O(logn)$的。一棵子树重构以后这个结点以及它所有的子结点的势能函数变成$0$，此时容易发现对于一个被重构的结点，我们用$O(n)$的代价让势能函数减少了$(2\alpha-1)cn$，此时只需要调结$c$的大小，使得其能够支配住重构过程的常数即可。容易发现每次不用连续重构自上而下的一段结点，只需要重构最上方的不平衡结点即可，此时重构常数极大减小。

----

#### 字典树Trie树

+ 01-Trie

  + 维护集合

    可以充当线段树用。

  + 位运算贪心

    一般用于求解异或最大值。

  + 可持久化01-Trie

  + 反向建树的应用

----

#### AVL树

----

#### 红黑树

----

#### B-Tree & (B+)-Tree

----

#### van Emde Boas Tree

----

#### Fusion Tree

----

### 维护定长序列的数据结构

----

#### 树状数组

+ 基本操作

  + 单点加法，区间求和
  + 区间加法，单点查询
  + 区间加法，区间查询

+ 统计应用

  + 例题1：洛谷P1972 [SDOI2009] HH的项链

    询问离线，按照右端点为关键字存入链表，对于每个元素记录$pre(i)$表示$i$前面最后一个和i颜色相同的位置，没有就设为0，考虑一个暴力的实现，从左向右扫描，如果某种颜色是第一次出现则进行记录，否则不会产生贡献。那么考虑固定右端点，向左扫描时记录所有的第一次出现的位置，若这个位置是第一次出现则赋为$1$，否则为$0$，那么此时右端点为$r$，左端点为$x$的答案就是$x$到$r$的区间求和，那么考虑右端点向右移动一位，显然只有$r+1$这个位置会变成第一次出现，那么上一次出现$r+1$这个位置的颜色就会从第一次出现变成第二次出现，赋成$0$即可，只需要一个单点修改区间维护即可完成操作。

  + 例题2：洛谷P4113 [HEOI2012] 采花

  + 例题3：

+ 树状数组二分

  用于在一个权值数据结构里求第K大。

  ```C++
  inline int query(int rank) {
  	int res = 0;
  	for (int i = lg2[n]; ~i; --i) {
  		if (res + (1 << i) > n) continue;
  		if (t[res + (1 << i)] < rank) rank -= t[res += (1 << i)];
  	}
  	return res + 1;
  }
  ```

+ DP优化

  一般用于二维偏序的优化。

----

#### 线段树

由于绝大多数实现思路都可以用线段树及其变式完成，故把大多数典型题目类型放到这个版块，充分讲解线段树的应用。

+ 基本操作

  + 区间加法，区间求和

    现存若干种常见的线段树写法，主要介绍记录左右子树的写法。这种写法适合推广到动态开点写法。

    信息的记录：

    ```c++
    int root, ls[maxn << 1], rs[maxn << 1], cnt;//根结点编号、左儿子编号。右儿子编号、内存池计数器
    long long sum[maxn << 1], tag[maxn << 1];//区间数值和、区间加法标记
    ```

    建树：

    ```c++
    void build(int L, int R, int& cur) {
    	cur = ++cnt;
    	if (L == R) { read(sum[cur]); return; }
    	int mid = (L + R) >> 1;
    	build(L, mid, ls[cur]), build(mid + 1, R, rs[cur]);
        sum[cur] = sum[ls[cur]] + sum[rs[cur]];
    }
    ```

    对于别的维护区间信息的线段树，更加一般化的写法如下：（左右均为闭区间）

    ```c++
    void build(int L, int R, int& cur) {
    	cur = ++cnt;
    	if (L == R) {
            //初始化叶子结点信息
            return;
        }
    	int mid = (L + R) >> 1;
    	build(L, mid, ls[cur]), build(mid + 1, R, rs[cur]);
        pushup(cur);
    }
    ```

    其中$pushup(cur)$的意义是通过$cur$的左右子树信息合并，得到$cur$对应区间的信息，例如区间加法的$pushup$就可以这样实现：

    ```c++
    inline void pushup(int cur) {
    	sum[cur] = sum[ls[cur]] + sum[rs[cur]];
    }
    ```

    然后考虑区间求和，我们直接在线段树上面dfs，若当前结点代表区间与询问有交集就继续向有交集的子树走，将查询到的信息合并返回；若结点区间被询问区间包含，就直接返回这个区间的信息即可。

    ```c++
    ll query(int L, int R, int l, int r, int cur) {//LR即当前cur对应的区间，lr对应询问区间
    	if ((l <= L) && (r >= R)) return sum[cur];//被包含就直接返回
    	int mid = (L + R) >> 1;
        ll res = 0;
    	if (l <= mid) res += query(L, mid, l, r, ls[cur]);
    	if (r > mid) res += query(mid + 1, R, l, r, rs[cur]);//分割区间
    	return res;
    }
    ```

    在这个基础之上加上区间加法，显然不能把每个叶子节点都暴力加一遍，所以我们要利用标记，维护这个子树对应的区间内每个叶子结点加上了多少，并且实时更新结点对应的和。写出来以后会发现操作和查询是一样的。

    另外，由于加上了修改操作，我们首先需要考虑实时的维护每个我们需要的结点的信息，也就是标记的下推。更具体的，标记最好理解为“在这个子树内每个叶结点都进行了这样一次操作，这个结点的信息已经更新完成”。这样有利于在之后的代码书写中搞清楚。另外一般的标记需要有可合并性，也就是对于一个已经有标记的结点，要能在这个基础之上再额外进行快速修改。

    所以我们的标记下推与区间修改可以如下写：（个人写法问题，只在dfs的时候记录区间左右端点）

    ```c++
    inline void pushdown(int L, int R, int cur) {
    	int mid = (L + R) >> 1;
    	tag[ls[cur]] += tag[cur], tag[rs[cur]] += tag[cur];
    	sum[ls[cur]] += tag[cur] * (mid - L + 1);
    	sum[rs[cur]] += tag[cur] * (R - mid);//维护子结点的标记与区间和
    	tag[cur] = 0;//标记下推完以后，它的历史使命就完成了，清空
    }
    void modify(int L, int R, int l, int r, int cur, long long val) {
    	if ((l <= L) && (r >= R)) {
    		sum[cur] += val * (R - L + 1), tag[cur] += val;
    		return;
    	}
    	if (tag[cur]) pushdown(L, R, cur);//没有标记就不需要下推
    	int mid = (L + R) >> 1;
    	if (l <= mid) update(L, mid, l, r, ls[cur], val);
    	if (r > mid) update(mid + 1, R, l, r, rs[cur], val);
    	pushup(cur);
    }
    ```

    同时，由于标记的存在，在查询的时候需要下推标记更新信息，使得我们查询到的区间信息就是正确的：

    ```c++
    ll query(int L, int R, int l, int r, int cur) {
    	if ((l <= L) && (r >= R)) return sum[cur];
    	if (tag[cur]) pushdown(L, R, cur);//重要！！！
    	int mid = (L + R) >> 1;
        ll res = 0;
    	if (l <= mid) res += query(L, mid, l, r, ls[cur]);
    	if (r > mid) res += query(mid + 1, R, l, r, rs[cur]);
    	return res;
    }
    ```

    这样我们就得到了能够维护区间加法、区间求和的线段树。

    当然了，由于加法的特殊性质，有另一种不需要下推标记的写法，叫做标记可持久化。

  + 区间加法，区间乘法，区间求和

    这个相对于上面多加上了一个乘法操作，自然可以多加上一个标记维护乘法。

  + 定长01序列的操作&标记技巧

    常见的操作有区间赋值，区间异或1，区间求和，区间最长0/1段长度，使用维护序列的数据结构均可完成。

    标记记录区间覆盖、区间是否被异或过，打标记的时候考虑所有的先前情况，合并时候按照题目需求，记录区间0/1数量、左0/1长度、右0/1长度、区间最长0/1长度。以

    + 例题1：洛谷P2894 [USACO08FEB] Hotel G
    + 例题2：洛谷P2572 [SCOI2010] 序列操作
    + 例题3：洛谷P3968 [TJOI2014] 电源插排
    + 例题4：洛谷P4344 [SHOI2015] 脑洞治疗仪

+ 动态开点

  这个写法可以在线段树有用信息稀疏的情况下节省空间。同时为后面的线段树合并做铺垫。很多时候可以替代平衡树进行操作。

+ 可持久化

+ 线段树合并

+ 区间历史最值

  + 例题1：洛谷P4314 CPU监控

  + 例题2：SPOJ1557 GSS2 - Can you answer these queries II

    在最大子段和的问题上加上了只算一次的条件，考虑将询问按照右端点离线，暴力一点，从左向右枚举右端点向左扫描，在左边所有的点处更新以这个点作为子区间左端点的最大值，然后处理完一个右端点就处理所有在这个位置的询问，显然是求解区间最大值。考虑在右端点向右移动一位的时候所有左端点的答案如何变化，首先所有的位置都先加上新右端点的权，然后上一次出现新右端点元素的位置向左出现重复减去这个权，也就是实现一个区间加法，然后再把所有的左端点更新从开始到现在的最大值，查询只需查询区间的从开始到现在出现过的的最大值，那么此时问题转化为区间加区间历史最大值，套用模板即可。

+ 区间最大子段和

  + 单点修改区间最大子段和

    使用朴素的线段树，每个结点记录这个结点代表的区间的和、以区间左/右端点作为开头/结尾的最大前/后缀和，叶子结点这四个值就对应序列上的值；向上合并的时候区间和最易于维护，考虑左端点为开头的最大前缀和，要么跨越中间要么不跨越中间，前者对应左子区间的左端点为开头的最大前缀和，后者显然左区间已经全部被选上，对应左子区间的和加上右子区间的左端点为开头的最大前缀和；同理右端点为结尾的最大后缀和；区间最大子段和依然考虑能否跨区间，不跨区间就对应左右子区间的最大子段和，否则对应左子区间的右端点为结尾的最大前缀和，加上右子区间的左端点为开头的最大前缀和，如此维护。

    + 例题1：SPOJ1043 GSS1 - Can you answer these queries I
    + 例题2：SPOJ1716 GSS3 - Can you answer these queries III

  + 一些可以向区间最大子段和转化的变式

    + 例题1：洛谷P3488 [POI2009] LYZ-Ice Skates

      

    + 例题2：洛谷P2839 [国家集训队] middle

      我们考虑离散化以后二分答案，将$[a,d]$这一段区间内大于等于$mid$的权设为1，否则设为-1，如果$mid$能够成为某个子序列的中位数，那么这一段的数字和一定等于0或1，那么考虑当mid越来越大的时候，最大的权值和一定越来越小以致于小于0，在二分一个值的时候，按照上述说法处理这一段序列，求出左端点在$[a,b]$，右端点在$[c,d]$的最大子段和，若大于等于0则上调二分下界，这个正负1的序列可以通过权值递降的顺序建可持久化线段树求得。

    + 例题3：洛谷P3582 [POI2015] KIN

      考虑固定一个右端点向左暴力，第一次看的电影就加上其权值，第二次碰到就抵消加上负的权值，再碰到就是0，利用“区间不同种类颜色数”中记录$pre$的思想，就可以转化为一个单点修改、后缀最大权值和的问题。

    + 例题4：SPOJ2916 GSS5 - Can you answer these queries V

      注意到给定的区间可能重合也可能不重合，那么大力讨论一下所有的情况，不重合的情况比较简单，只需要左右分开求前缀后缀最大值，加上中间的和即可。考虑左右区间有交集的情况，分为两端点均在交集部分、有至少一个端点不在交集部分两种情况，前者就是最大子段和模板，后者用不重合的情况处理交集两侧的前后缀最大值的和即可。

    + 例题5：SPOJ6779 GSS7 - Can you answer these queries VII

      序列问题上树就用树剖，区间赋值就考虑每个结点打标记，讨论赋值的正负对区间最大子段和、前后缀最值的影响，同理标记下推的过程。

+ 允许暴力修改的线段树

+ 李超线段树

+ 线段树维护单调栈

  + 例题1：洛谷P4198 楼房重建

    考虑线段树每个结点维护其对应区间形成的单调栈的长度，显然叶子结点的答案为1，考虑自下向上维护的过程，定义函数pushup(cur,k)表示计算将cur这个结点对应的区间建成一个首元素大于k的单调栈，栈内元素的数量是多少。线段树维护一个区间最大值，

  + 例题2：洛谷P4425 [HNOI/AHOI2018] 转盘

+ 线段树分裂

  + 例题1：洛谷P5494 【模板】线段树分裂
  + 例题2：洛谷P2824 [HEOI2016/TJOI2016] 排序

+ 线段树分治

+ 区间取最值型的操作

  直接介绍SegmentTreeBeats（吉老师线段树）的实现方法以及

+ 扫描线的维护

  + 例题1：洛谷P5490 【模板】扫描线（矩形面积并）

  + 例题2：洛谷P1856 [IOI1998] [USACO5.5] 矩形周长Picture

  + 例题3：洛谷P3246 [HNOI2016] 序列

    首先有考虑贡献的套路，设这个序列为$a$，考虑每一个位置能够成为多少个区间的最小值，对于相同元素，我们令一个子段的最小值是这一段的最小值中最靠左的。那么利用单调栈处理出左面第一个小于等于当前位置的值的位置，以及右面第一个小于当前值的位置。设位置$i$能够向左最多延伸到$left(i)$，向右最多延伸到$right(i)$，我们可以定义一个二维平面，位置$(x,y)$上面的值是$a[x...y]$中最靠左的最小值，显然对于序列中的每个元素，平面中$left(i)\le x \le i$，$i\le y \le right(i)$的值就是$a[i]$，由此可以将二维平面$y=x$的上半部分分割成若干不相交的子矩形。考虑扫描线的过程，每个询问$[l,r]$就是在查询二维平面内$l\le x \le r$，$l\le y \le r$这一部分的矩阵和，进一步拆分成$x \le r$，$l\le y \le r$的和与$x \le l-1$，$l\le y \le r$的和。递增枚举横坐标，对于已经完全包含在左面的子矩形，直接区间加法维护和；对于跨越当前横坐标的子矩形，注意到我们要求的部分和就是$\sum (r-left(i))\times a[i]=r\sum a[i]-\sum left(i)a[i]$，用两个线段树分别维护当前未被完全扫描完的子矩形的$a[i]$与$left(i)a[i]$即可。

+ 优化建图

  + 例题1：洛谷P5025 [SNOI2017]炸弹

+ DP优化

  + 例题1：洛谷P1848 [USACO12OPEN] Bookshelf G

+ zkw线段树

----

#### 分块

+ 基本操作

  以hwzer的数列分块入门九题作为基础操作讲解。以下默认当询问左右端点在同一个块内的时候就是零散块的操作，设$B$为块长。

  + 数列分块1：区间加法，单点查询

    分块，每个块打一个标记，维护整个块内每个元素额外加上了多少。加法操作就枚举散块与整块，散块直接暴力加，整块只需要在标记上做加法即可。单点查询只需要取出序列中的数再加上所在块的标记即可。块长取$B=\sqrt{n}$的时候复杂度为$O(m\sqrt{n})$。

  + 数列分块2：区间加法，区间询问小于等于某个元素的数的个数

    分块，每个块打标记记录这个块每个元素额外加上了多少，还需要维护一个数组保存这个块中所有元素排序过后的结果。散块暴力给每一个元素做加法，排序重构排序数组；查询答案就暴力枚举散块元素，整块内部二分。块长取$B=\sqrt{n}$的时候复杂度为$O(m\sqrt{n}logn)$。

    当然了，注意到散块加法是给排好序的数组中的一部分数做加法，故在排序数组中每个数额外记录其在原序列中的位置，一遍扫描把排序数组分成两部分，其中一部分是需要做加法的，另一部分不需要做加法，这两部分可以通过归并实现排序数组的维护。调节块长，块长取$B=\sqrt{nlogn}$的时候复杂度为$O(m\sqrt{nlogn})$。

  + 数列分块3：区间加法，区间查询前驱

    实现手法和数列分块2相似，故不再赘述。

  + 数列分块4：区间加法，区间求和

    分块，每个块维护整个块的元素和，以及打标记，维护这个块内每个元素额外加上了多少。加法操作就枚举散块与整块，散块直接暴力加，维护整块元素和，整块需要在标记上做加法，元素和也相应的有变动。区间求和需要枚举零散块与整块，整块直接查询块内元素和，零散块部分暴力扫描，注意需要加上所在块的标记。

  + 数列分块5：区间每个数开方，区间求和

    分块，维护每个块内的元素最大值。注意到正整型范围内的每个元素开平方根下取整不超过5次就会变成1，变成1或者0以后就不再变化，所以每个元素暴力做就可以。对于零散块暴力开根号维护块和与最大值，在整块的最大值超过1的时候对整个块暴力，维护块和与最大值，否则直接跳过不计算。求和同理数列分块4。每个整块至多暴力$5B\times \frac{n}{B}=O(n)$数量级，在块长取$B=\sqrt{n}$的时候复杂度为$O((n+m)\sqrt{n})$。

  + 数列分块6：单点插入，单点询问

    这个将会放在维护序列的数据结构中的块状链表部分讲解。

  + 数列分块7：区间加法，区间乘法，区间求和

    类似于线段树做法，每个块维护加法乘法标记，将数列分块4与乘法线段树结合一下就可以了。

  + 数列分块8：区间赋值，区间询问某个数的出现次数

    考虑怎么维护区间赋值，如果我们能做到在$O(x)$时间内定位、移除或增加一个颜色段，由摊还分析可以知道暴力修改（无查询的情况下）的复杂度是$O((n+m)x)$的。维护$cnt(i,j)$实表示块$i$内$j$出现了多少次，再在每个块内实现现一个链表，维护这个块内的极长相同数字段，每一次零散块操作会让这个块内极长色段数减少$x(0\le x)$并且至多增加$2$，暴力重构一下维护；整块赋值就直接暴力遍历这个块的链表清空，这一部分的复杂度是这个块的初始颜色段数加上后来零散块操作加上的颜色数，所有块的总量是$O(n+m)$的。查询就散块暴力整块查表。块长取$B=\sqrt{n}$的时候复杂度为$O((n+m)\sqrt{n})$。

  + 数列分块9：区间众数（洛谷P4168 [Violet] 蒲公英）

    设$cnt(i,j)$表示前$i$个块内j出现了多少次，前缀和处理；$ans(i,j)$表示从第$i$个块的开头到位置$j$这段区间的最小众数，枚举每个块的左端点向右暴力处理。求解答案的时候，若询问左右端点在同一个块内的时候暴力求解，否则先查$ans$数组求出一个临时解，扫描左右零散块，开一个$num(i)$记录零散部分$i$出现了多少次，枚举左零散块中的元素，利用$cnt$与$num$查询出现次数更新答案。求解完一次就撤销清空$num$数组。块长取$\sqrt{n}$的时候复杂度为$O((n+m)\sqrt{n})$。

+ 区间逆序对：时间复杂度$O((n+m)\sqrt{n})$，空间复杂度$O((n+m)\sqrt{n})$的分块（洛谷P5046 [Ynoi2019 模拟赛] Yuno loves sqrt technology I）

  介绍两种复杂度一样的做法，只介绍跨块处理手法，零散块以及块内询问处理手法一样我就写在后面了。

  + $f(i,j)$表示前$i$个块内小于等于$j$的数有多少个，$ans(i,j)$表示第$i$个块的开头到第$j$个块的末尾这一段的答案，然后对于每个块处理前缀后缀的逆序对数，$ans(i,j)=ans(i,j-1)+ans(j,j)+calc()$，这个calc表示的是求解块$i$到$j-1$这一部分与块$j$产生的逆序对数贡献，只需要枚举块$j$内的元素，查$f$数组求得贡献。$ans(i,i)$可以在求解前后缀时顺带求出。每个单独的部分考虑完然后考虑互相的贡献，零散块之间采用归并，零散块对整块的部分用$f$数组，枚举零散块元素，查询f数组得到这个元素的贡献求和即可。
  + $f(i,j)$表示前$i$个元素对第$j$个块产生的逆序对数贡献，求解只需要把第$j$个块与整个序列做一遍归并，考虑元素$i$在这个块的前面还是后面（如果在块内的话就不产生贡献），$O(n)$求出一个块的信息，做一遍前缀和得到结果。然后上述做法中的$calc$可以直接查询$f$数组，进而在$O(n)$时间复杂度内求得$ans$数组，零散块对整块的贡献就枚举中间块，用数组$f$差分求解。

  然后将每个零散块复制一下进行排序，扫零散块的时候打标记，扫描排序数组得到零散部分的有序数列，然后归并求解逆序对。左右端点落在同一个块的询问只需要两个后缀相减再减去归并求得的贡献即可。

+ 带修改的分块

  + 例题1：单点修改，区间数颜色，强制在线

    以$n^{\frac{2}{3}}$为大小进行分块，记录$ans(i,j)$表示从第$i$块的开头一直到第$j$块的末尾的答案，同理记录前缀和，修改一个元素就考虑所有的跨过这个块的大区间，总共$O(n^\frac{2}{3})$数量级，每一个区间都可以在查前缀和表的时候$O(1)$更新，查询同理静态分块做法。只不过单次操作复杂度变成了$O(n^\frac{2}{3})$，总复杂度$O(n^\frac{5}{3})$。

  + 例题2：洛谷P5065 [Ynoi2014] 不归之人与望眼欲穿的人们
  
+ 值域分块

  一般要套序列分块一起使用，用于求解区间第K大。一般用$cnt1(i,j)$表示前$i$个块内j出现了多少次，$cnt2(i,j)$表示前$i$个块内值域有多少数位于值域的第$j$个块内，然后零散部分（如果询问跨块，那么零散部分就是左右两端，否则就是询问的序列）记录$cnt3(i)$为零散部分有多少$i$，$cnt4(i)$为零散部分有多少数落入值域块$i$，然后从小到大枚举值域块，类似于线段树二分，如果定位了某个块就枚举这个值域块内部的元素，求解完成后撤销零散块贡献。

  + 例题：区间x变y，区间K小值（洛谷P4119 [Ynoi2018] 未来日记）

    首先按照上面说的进行序列与值域分块，然后每个块记录一个映射，$f1(i)$表示当前块内$i$代表什么数，$f2(i)$表示当前块内什么数代表$i$，然后零散块修改直接重构，记录块内有多少$x$，整块考虑三种情况：

    + 没有$x$，那么直接跳过；

    + 有$x$，没有$y$，直接用上面提到的$f1$、$f2$进行映射，同时记录块内有多少个$x$；
    + 有$x$，有$y$，直接重构这个块，记录块内有多少$x$。

    然后对于修改，记录每个块有多少$x$被修改，求一个前缀和后对$cnt1$、$cnt2$进行修改维护。

    这个复杂度看起来是假的，但实际上仍然是$O(n \sqrt{n})$的（认为序列长度与询问量同阶），考虑一个整块的重构会用$O(\sqrt{n})$的代价将这个块内的数字种类减1，而一个块的数字种类至多是$\sqrt{n}$个，只有一次零散块的重构才会给这个数增加1，零散块的重构次数不超过$2n$，所以总的重构次数不会超过$O(n+m)$，总的重构代价与总复杂度渐进表示一致。

----

#### 嵌套数据结构树套树

说白了就是外面一个维护序列的数据结构，里面一个维护集合的数据结构。具体而言就是维护序列的数据结构的每个结点都需要维护这个结点所代表的区间内所有元素的可重集。

树套树用于维护区间第K大、区间x的排名、区间查找前驱后继等应用。

除非内层是权值线段树，否则树套树求解区间第K大都需要多一个$log$，因为权值线段树虽然可能由于动态开点的缘故形态不同，但是所有不同的权值线段树上对应结点的代表区间一致，所以可以在若干棵线段树上同时二分向下走，省去了每一次再跑一遍外层数据结构的复杂度。

| 数据结构类型            | 空间复杂度     | 单点修改时间复杂度 | 区间x的排名   | 区间第K大       |
| ----------------------- | -------------- | ------------------ | ------------- | --------------- |
| 树状数组/线段树套平衡树 | $O(nlogn)$     | $O(log^2n)$        | $O(log^2n)$   | $O(logVlog^2n)$ |
| 树状数组套权值线段树    | $O(nlogVlogn)$ | $O(logVlogn)$      | $O(logVlogn)$ | $O(logVlogn)$   |

一些例题：

+ 区间数颜色

  + 单点修改（洛谷P1903 [国家集训队] 数颜色）

    考虑如何沿用上面那个一个$log$的思路，维护某一个位置的$pre$，求解区间内有多少数小于$x$，显然$pre$只涉及两种元素的变动，考虑对于每一种颜色开一个set，记录所有这种颜色出现的位置，然后对于一个位置，求出当前颜色的后继、目标颜色的前驱后继，树套树单点修改（强制在线）或者cdq分治求解（允许离线）。

  + 区间赋值（洛谷P4690 [Ynoi2016] 镜中的昆虫）

    考虑依然沿用上面记录$pre$数组的做法，然后把颜色相同的位置缩成一段，采用类似于珂朵莉树的形式维护，然后对于一段的修改操作，若一个颜色段完全位于区间内部则只需要修改这一段开头位置的pre值，否则需要修改这一段分裂后分裂处的$pre$值，至多需要修改$2$个位置。容易发现在这个过程中我们以$O(nlong)$的代价使颜色段数的数目至少减少$n-2$个，在初始化以及后面的操作中颜色段数总量不会超过$O(n+m)$，利用摊还分析可以证明复杂度正确，同时$O(n+m)$也就是需要单点修改的$pre$的总量。只需要把这么多个操作放在树套树上或者cdq分治就可以解决。

+ 三维偏序

  
  
+ 离线化的树套树：整体二分

  这里以单点修改，区间第K大为例，讲解整体二分的实现方法。（洛谷P2617 Dynamic Rankings）

  将序列中的每个初始的数表示为单点插入，然后将询问与修改都放进一个大数组里一起操作。询问的形式就是求解一个区间的第K大，序列初始化的形式是单点增加一个数，修改的形式是单点移除一个数再加入另一个数。所有的操作从左到右按照时间顺序递增。预先开好一个允许单点加区间求和的数据结构，以及两个栈$stk1$、$stk2$用来分离所有的操作。

  在我们已知所有的元素的取值范围以及所有的操作以后，设函数$solve(L,R,l,r)$表示当前处理所有的修改的值域以及询问的答案均位于区间$[L,R]$内，这一部分在所有的操作序列$[l,r]$中。考虑二分法检查答案，令$mid=\lfloor \frac{R+L}{2} \rfloor$，然后从$l$到$r$枚举操作，若此时对应的增加/移除操作，且这个操作的权值小于等于$mid$，就在一个新的数组内把这个位置的值增加/减少$1$，并且把这个修改放入$stk1$，否则只需要放入$stk2$；若遇到查询操作，就在序列中查询这一段有多少个$1$，也就是检查当前这一段内值域位于$[l,mid]$中的数有多少，设这个数值为$offset$，若$rank \le offset$则把这个询问放入$stk1$，否则将$rank$减去$offset$，然后把询问放入$stk2$。这个过程类似于线段树上二分，也就是查询左子树中的元素个数以决定向哪一个子结点迭代。处理完以后就把$stk1$中的操作进行一遍撤销，将两个栈中的操作放回操作序列$[l,r]$，其中$stk1$在左，$stk2$在右，向下递归$solve(L,mid,l,l+top1-1)$和$solve(mid+1,R,l+top,r)$。当递归到某一段没有询问的时候就返回，当值域区间长度为$1$的时候，就可以直接更新对应操作区间内询问的答案了。

  复杂度证明：显然一个操作只会出现在$logV$个值域区间内，每个操作恰好对应一次数据结构的修改或者查询，故总复杂度$O((n+m)lognlogV)$。

  别的可以用整体二分解决的题目：

  + 例题1：洛谷P3332 [ZJOI2013] K大数查询
  + 例题2：洛谷P1527 [国家集训队] 矩阵乘法
  + 例题3：洛谷P3527 [POI2011] MET-Meteors
  + 例题4：洛谷P4175 [CTSC2008] 网络管理
  + 例题5：洛谷P7424 [THUPC2017] 天天爱射击
  + 例题6：洛谷P3242 [HNOI2015] 接水果

----

#### 能够快速预处理的静态区间查询

+ 倍增rmq，ST表

  以求解区间最大值为例，$f(i,j)$表示闭区间$[i,i+2^j-1]$的最大值，有递推式$f(i,j)=max(f(i,j-1),f(i+2^{(j-1)},j-1))$，初始化$f(i,0)=a[i]$，查询区间$[l,r]$则令$t=\lfloor log_2(r-l+1) \rfloor$，查询$max(f(l,t),f(r-2^t+1,t))$。同理可以应用于区间$min$，区间$and$、区间$or$、区间最大公约数最小公倍数，区间线性基等具有结合律、幂等运算或者至多能够产生一次贡献的操作。

+ 可以优化至$O(n+m)$的rmq

  + 随机数据下期望$O(n+q)$的区间最值求解（洛谷P3793 由乃救爷爷）

    对序列分块，预处理每个块前缀后缀的答案，以及块到块的答案，这两个操作均可以在$O(n)$内完成，然后对于跨块的询问，直接将询问拆成两个零散块与中间块的答案$O(1)$求出，否则直接暴力扫出落在一个块内的答案。

    为什么这个复杂度是对的呢？考虑有多少种情况需要暴力求解，答案是$\Theta(n\sqrt{n})$级别的，所有的询问的情况是$\Theta(n^2)$级别的，在所有可能的询问出现概率相等的情况下，我们有$\Theta(\frac{1}{\sqrt{n}})$的概率进行一次暴力，这个部分的期望复杂度是$O(m\times\frac{1}{\sqrt{n}}\times\sqrt{n})$也就是$O(m)$的，其它的询问均可以在$O(1)$完成，故总复杂度的期望是线性的。

    而且这个东西也不好卡，如果要卡的话需要调小询问长度，显然就有着很大的风险把暴力选手放过去。

  + 约束rmq的$O(n+m)$求解

    ”约束“的意思是整个序列中的相邻元素的差的绝对值恰好为1，利用这个特殊条件可以将问题进行优化。

    + 首先进行分块，按照$size=\lceil\frac{(log_2n)}{2}\rceil$为一块进行分块，然后求出单块内部前缀后缀的最大值，整块间使用ST表处理，这一部分的复杂度是$O(n)$的。
    + 当询问跨块的时候，直接零散块查表以后大块rmq，考虑当询问落在一个块内的时候怎么处理，我们要充分利用差值的绝对值为正负1的条件，需要额外记录一下每个块中的最小值是多少，然后把这个块内的所有元素减去这个最小值，注意到块长很短，全做减法以后相邻差值不变，我们认为两个块不同当且仅当在减去块内最小值以后，块内存在若干元素不同。此时由于差分数组的取值只有正负1，本质不同的块至多有$2^{0.5log_2n}$种，这个是$O(\sqrt{n})$级别的，因此对这本质不同的$O(\sqrt{n})$种块跑$O(size^2)$的暴力处理结果，查询时直接映射即可。这部分处理复杂度亚线性，单次查询$O(1)$。记得查询完以后把减去的最小值加回来。

  + $O(n\alpha(n)+m)$的做法：

+ 猫树：分治实体化的产物

----

#### 莫队

+ 普通莫队
  + 适用范围：一些可以在$O(nm)$复杂度下暴力求解的区间询问题目，可以在已知一个区间的所有信息以及这个区间的答案的情况下$O(1)$扩展到相邻区间。不带修改，允许离线。
  
  + 实现方式：将所有的询问排序，对序列分块，以左端点所在块为第一关键字升序排序，右端点为第二关键字升序排序，维护两个指针左右移动，做完一个询问就暴力移动指针维护区间的信息与答案至下一个询问。
  
  + 复杂度证明：设块长大小为$B$，那么总的分块数就是$\frac{n}{B}$，考虑复杂度来源于哪个部分：
  
    + 左端点在一个块内移动：每个询问至多移动块长，$O(\frac{nm}{B})$。
    + 左端点跨块移动：每个块至多向右跨一次。$O(n)$。
    + 左端点所在块相同的时候，右端点移动：每个块都对应移动序列长度数量级，$O(\frac{n^2}{B})$。
    + 左端点跨块的时候，右端点移动：$O(\frac{n^2}{B})$。

    假设$n$与$m$同阶，当$B$取$\sqrt{n}$的时候总复杂度$O((n+m)\sqrt{n})$。
  
  + 例题
    + 例题1：洛谷P1494 [国家集训队]小Z的袜子
    + 例题2：洛谷P2709 小B的询问
    + 例题3：洛谷P3730 曼哈顿交易
    + 例题4：洛谷P4137 Rmq Problem / mex
    + 例题5：洛谷P4396 [AHOI2013] 作业
    + 例题6：洛谷P4462 [CQOI2018] 异或序列
  
+ 带修莫队
  + 适用范围：允许在普通莫队$O(nm)$暴力求解的同时，在已知某个区间信息以及答案的同时$O(1)$扩展到相邻区间，或者进行一次单点修改的区间查询问题。
  + 实现方式：以$n^\frac{2}{3}$为大小分块，所有的询问离线，修改单独放到一个数组内，记录每个询问发生在多少个修改过后。所有的询问以左端点所在块为第一关键字升序，右端点所在块为第二关键字升序，时间轴为第三关键字升序排序。
  + 复杂度证明：

    + 左端点移动复杂度：一个左端点不跨块时候$O(Bm)$，跨块移动$O(n)$。
    + 右端点移动复杂度：左端点在一个块内的时候$O(Bm)$，左端点不变右端点跨块的时候$O(\frac{n^2}{B})$，左端点变化右端点跨块的时候$O(\frac{n^2}{B})$。
    + 时间轴移动复杂度：不同的左右端点所在块都会让时间轴递增移动，复杂度$O(\frac{n^2m}{B^2})$，左右端点所在块变动的时候，时间轴回调也是这个复杂度。

    综上，若认为$n$与$m$同阶，则当$B=n^ \frac{2}{3}$的时候复杂度为$O(n^\frac{5}{3})$。
  + 例题：洛谷P1903 [国家集训队] 数颜色

+ 回滚莫队
  + 适用范围：有一些区间信息允许$O(1)$扩展到一个包含当前区间的大区间，但是不允许$O(1)$区间缩减，比如一些取minmax的操作。
  + 实现手法：首先筛选出左右端点落在同一个块内的询问，暴力处理。其余的询问按照左端点所在块为第一关键字，右端点为第二关键字排序，枚举在同一块内的询问时，右端点指针初始化为当前块的右端点，然后不断向右扩展直至出现一个以右端点指针为右边界的询问，然后左边只需要暴力从右向左把散块加进去，并且记录左面零散块加进去的时候发生了什么修改，做完询问就反向撤销，然后继续让右端点递增左端点扩展循环直至左端点落在这个块内的询问都被处理完，然后清空所有的记录信息枚举下个块
  + 例题
    + 洛谷P5906 【模板】回滚莫队
    + SPOJ20644 ZQUERY - Zero Query
    + ATCoder1219 歴史の研究
    + CF522D Closest Equals
  
+ 树上莫队
  + 适用范围：离线求解树上路径集合问题。
  
  + 实现手法：对于一棵树，dfs的时候需记录入栈序以及出栈序，即一棵树的欧拉序。每个节点会恰好在欧拉序中出现两次，记为它们的左端点$lsid$以及右端点$rsid$。欧拉序有如下性质：（均假设$lsid(x)<lsid(y)$）
  
    + 当结点$xy$互不为对方祖先结点的时候，有$rsid(x)<lsid(y)$，且欧拉序中$[rsid(x),lsid(y)]$这一段区间中只出现过一次的编号等于这条链上的所有除$LCA(x,y)$以外的点。
    + 当结点$x$是$y$的祖先结点的时候，有$rsid(y)<rsid(x)$，欧拉序中$[lsid(x),lsid(y)]$这一段区间中只出现过一次的编号等于这条链上的所有点。
  
    有以上两个性质，可以对$xy$的位置关系进行讨论，然后就是出现一次算加入信息，出现两次的时候就减掉，其余的就套普通的莫队的模板即可。
  
  + 例题
  
    + SPOJ10707 COT2 - Count on a tree II
    + 洛谷P4074 [WC2013] 糖果公园
  
+ 二次离线莫队

  + 适用范围：用于区间更新所需要的信息可以差分成两个前缀和相减、进而转化成扫描线可以维护的形式的可以莫队的题目。以例题的形式讲解如何应用这个思想。

  + 例题

    + 例题1：洛谷P5047 [Ynoi2019 模拟赛] Yuno loves sqrt technology II

    考虑莫队时需要的信息，如果直接硬维护的话需要维护区间内出现了什么数，以及查询多少数比$x$大/小，考虑将所有的询问进行离线，每个询问的形式是某个区间内比$x$大/小的数有多少个，然后进行一步差分，这里以求解$l$到$r$内有多少数比$r+1$位置的数大为例：差分变成求解$1$到$r$内有多少数比$r+1$位置的数大、$1$到$l-1$内有多少数比$r+1$位置的数大，注意到前者与$l$无关，可以直接处理，后者继续离线，注意到询问的形式都是某个前缀中比某个数小或大，采用一个权值数据结构，从左到右一个一个加入元素，求解对应位置前缀的答案，这是一个$O(n)$插入总量$O(n\sqrt{n})$询问总量的扫描线，使用值域分块平衡两端复杂度，容易实现一个分块，满足$O(\sqrt{n})$单点修改$O(1)$前缀求和，利用这个可以将时间复杂度优化至$O(n\sqrt{n})$，但此时空间复杂度依然是$O(n\sqrt{n})$。

    注意到莫队的区间移动操作，当一个端点没有移动到指定位置的时候，另一个端点一直固定不动，且这个移动的端点一定是经过一个区间，那么我们依然以上面求解l到r内有多少数比$r+1$位置的数大为例，差分后与$l$无关的那部分前缀和$O(1)$查到，与$l$有关的一部分记录一个区间即可，这部分的空间开销优化至$O(m)$。

    时间复杂度$O((n+m)\sqrt{n})$，空间复杂度$O(n+m)$。

    + 例题2：洛谷P4887 第十四分块(前体)
    + 例题3：洛谷P5501 [LnOI2019] 来者不拒，去者不追
    + 例题4：洛谷P5398 [Ynoi2018] GOSICK

+ 莫队的常数优化技巧&细节
  + 优化1：调节块长。这个比较玄学。优化效果取决于各种地方的实现方式。一般情况下在$nm$同阶的时候，建议块长比$\sqrt{n}$略小一些。但不排除某些题目中询问量与序列长度数量级差别较大的情况。
  + 优化2：考虑对于左端点落在一个块内的询问，其右端点指针一定是向右移动的；在左端点移向下一个块的时候，右端点指针会大概率向左移动到此块第一个询问处，如果能够在这个左移的过程中处理掉所有的询问，而不是左移以后再右移去处理询问，常数会获得一定程度的优化。具体实现起来，以左端点所在块为第一关键字，右端点为第二关键字，左端点所在块的下标为奇数的时候，右端点升序排序，反之降序排序。
  + 细节：若四个while循环排布顺序不当，可能会导致指针$l>r$的情况，有可能会造成数组内存下溢。所以优先考虑扩展两端区间，然后再考虑收缩区间。

---

#### 笛卡尔树

+ 
+ 例题
  + 例题1：洛谷P6453 [COCI2008-2009#4] PERIODNI
  + 例题2：洛谷P5044 [IOI2018] meetings 会议

----

### 维护动态序列的数据结构

----

#### Splay

允许很方便的在保持中序遍历不变的情况下把一个结点转到根并保持复杂度。

+ 维护序列的写法
+ 复杂度分析

----

#### FHQ-Treap

又称之为非旋树堆，允许以分裂的形式将一个treap按照中序遍历分为两个部分。

+ 维护序列的写法

+ 可持久化平衡树

----

#### 块状链表

----

#### WBLT

奇怪的数据结构，复杂度不对但是跑得很快，好写，难卡。

----

### 维护K维空间的数据结构&算法

----

#### CDQ分治

----

#### 二维树状数组

+ 单点修改，矩阵求和

+ 矩阵加法，矩阵求和（洛谷P4514 上帝造题的七分钟）

  这是一个经典树状数组套路了，首先一步简单容斥转化为$[1,1]$到$[x,y]$上面的矩阵加矩阵求和，考虑沿用一维树状数组的思路进行差分，考虑弱化问题矩阵加法单点修改，假设左上角为$[x1,y1]$，右下角为$[x2,y2]$，差分修改为$[x1,y1]$、$[x2+1,y2+1]$加1，$[x1,y2+1]$、$[x2+1,y1]$减1，单点查询变为二维前缀和；然后考虑把这些单点信息加起来。设差分数组为$a[i,j]$，则考虑每个差分数组的元素会被多少个单点计算到，得到二维前缀和：
  $$
  ans=\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j]\times(x-i+1)\times(y-j+1) \\
  =\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j]\times(xy-x(j-1)-y(i-1)+(i-1)(j-1))\\
  =xy\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j]-x\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j](j-1)-y\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j](i-1)+\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j](i-1)(j-1)
  $$
  于是记录差分数组以及上面衍生出来的四个数组，四个二维树状数组维护即可。

----

#### 二维线段树&四分树

----

#### KD-Tree

----

### 维护树的数据结构

----

#### 树链剖分

+ 轻重链剖分

  考虑dfs的时候记录dfs序，把尽可能多的点放在一条自上而下dfs序连续的一段上面，使得我们可以用维护序列的数据结构维护树上路径，考虑每个非叶子结点向下连一条边，称为重边，这条边指向的结点称作重儿子；其余的指向子结点的边称为轻边，与此对应称这些子结点为轻儿子。连续的重边自上而下连接在一起，称为重链。当我们dfs时访问到一个有重儿子的结点，那么优先访问重儿子，再访问轻儿子，让一条重链的dfs序自上而下连续递增。

  考虑链上的操作可以通过dfs序映射到一个序列上，一条重链对应一个连续的区间，特别的我们认为没有重儿子的结点算作长度为1的重链，那么我们考虑如何让每个点到根上的路径中，轻重链切换次数最少。方案是把最子树大小最大的子结点设为重儿子，在这种情况下每个结点到根结点的轻重链切换次数为$O(logn)$。

  这个复杂度证明比较简单，考虑从一个结点向上走，这个结点指向父结点的边是轻边当且仅当存在一个兄弟结点，这个兄弟结点的子树大小大于等于这个结点的子树大小。显然这个时候向上走一步，子树大小会至少翻一倍，至多翻倍的次数是对数级别的，也就是说每个结点到根结点的轻重链切换次数都是$O(logn)$的。

  具体实现的时候需要实现两个dfs。第一遍dfs，预处理出这棵树每个点的父结点、结点深度、子树大小、重儿子是谁，第二个dfs需要记录先序dfs序、每个重链中的结点的链顶结点编号。链上操作只需要不断跳重链就可以实现。

+ 长链剖分

  类似于重链剖分，惟一的区别是重儿子指向的是向下能够走出路径最长的一个子节点，类似的可以分析出每个结点到根结点的轻重链切换次数都是$O(\sqrt{n})$的。

  应用：DP优化、K级祖先查找优化

  + 快速求K级祖先

  + 树形DP优化

----

#### 换根操作

大多数的换根都是唬人的，都只需要考虑dfs序上面的操作。

+ 例题1：洛谷P3979 遥远的过度

  链覆盖可以直接树剖解决，主要讨论树剖过后的换根子树查询。假设我们以1作为树剖的根，讨论换完以后根不是1的情况。假设换过以后的根是$root$，要查询的子树以$x$为根：

  + $lca(x,root)=root$：说明在以1为根的时候，$x$在$root$的子树里面，对应$[dfn[x],dfn[x]+size[x]-1]$。
  + $lca(x,root)=x$：说明$root$在$x$的子树里面，此时用倍增法求出$root$的某个祖先$y$，使得$fa[y]=x$，可以看出此时对应的区间是全局剔除$[dfn[y],dfn[y]+size[y]-1]$这部分，即$[1,dfn[y]-1]与[dfn[y]+size[y],n]$两部分。
  + 以上两种情况以外：对应$[dfn[x],dfn[x]+size[x]-1]$。

+ 例题2：洛谷P4689 [Ynoi2016] 这是我自己的发明

  看明白了换根的思路，其实这个是版块“根号分治”里面数点问题。dfs序把树拍成序列，然后沿用出现次数少的用二维偏序，出现次数多的前缀和统计的思路就可以了。

----

#### 树上启发式合并

----

#### 虚树

----

#### 动态树

+ LCT
+ ETT

----

#### 点分治

----

#### 点分树

----

#### 边分治

----

#### 边分树

----

#### 树分块

----

#### 一类树上距离求和问题

+ 例题1：洛谷P4211 [LNOI2014] LCA
+ 例题2：洛谷P3241 [HNOI2015] 开店
+ 例题3：

#### 树形动态DP

----

### 维护图的数据结构

----

#### 圆方树

----

#### 动态图

----

### 根号分治专题

----

#### 模剩余系下标的求和

+ 例题1：洛谷P3396 哈希冲突
+ 例题2：洛谷P5309 [Ynoi2011] 初始化

----

#### 涉及元素出现次数的分治

众所周知若一个多重集大小为$n$，则内部出现次数大于$\sqrt{n}$的元素种类不会超过$\sqrt{n}$种，利用这个性质可以进行数据分治。

+ 例题1：洛谷P5268 [SNOI2017] 一个简单的询问
  + 解法1：把式子拆开成询问跑莫队
  + 解法2：设这个序列为$a$，对于全局出现次数大于$\sqrt{n}$的元素，一共不会超过$\sqrt{n}$种。暴力的枚举每一种元素，做前缀和，给每个询问都暴力枚举一遍。对于出现次数小于$\sqrt{n}$的元素，考虑二维偏序，也就是说建立一个$n\times n$的平面，平面上一点$(x,y)$的权值为$1$当且仅当$a[x]=a[y]$。显然固定一个$x$，令$(x,y)$处的值为$1$的$y$不超过$\sqrt{n}$个位置。直接枚举就可以。对于询问$[l,r]$，就是求解二维平面上$l\le x \le r$，$l\le y \le r$的矩形元素和。此时问题转化为有$O(n\sqrt{n})$个点，$O(m)$个询问的的二维偏序，用一个$O(1)$单点加法，$O(\sqrt{n})$的值域分块维护。
  
+ 例题2：洛谷P5072 [Ynoi2015] 盼君勿忘

  注意到这个形式就是考虑贡献，考虑一个元素$x$在多少个子序列里出现过，正难则反考虑全集减去不出现的情况，设这个区间的长度为$len$，$x$就在$(2^{len}-1)-(2^{len-cnt(x)}-1)=2^{len}-2^{len-cnt(x)}$这么多个序列中出现过，$cnt(x)$就是在这个询问区间内$x$出现的次数，这个区间的答案就是$x$乘上对应出现次数的和，也就是
  $$
  ans=\sum_{x\in a[l,r]} x(2^{r-l+1}-2^{r-l+1-cnt(x)})
  $$
  考虑对出现次数进行分治，出现次数小于$\sqrt{n}$的元素，记录$sum1(i)$表示出现次数为$i$的数的和，也就是按照出现次数相同的进行分类，统计时直接计算；出现次数大于$\sqrt{n}$的元素，全局记录多少数出现次数大于$\sqrt{n}$，显然不会超过$\sqrt{n}$个，直接枚举每一个进行统计即可。出现次数可以用莫队直接维护，不同的模数采用光速幂根号打表实现。

### bitset专题

----

### STL容器专题

----

#### 线性数据结构

+ stack
+ queue&deque
+ vector
+ unordered_set
+ unordered_map

----

#### 非线性数据结构

+ set
  + 使用手法
  + 珂朵莉树
+ map
+ pbds
+ rope

----

### 字符串数据结构专题

----

#### 序列自动机

----

#### AC自动机

----

#### 后缀数组

----

#### 后缀自动机

----

#### 后缀树

----

#### 后缀平衡树

----

#### 回文自动机

又称之为回文树，是一个有两个树形结构的有向图。用于记录一个字符串的所有回文子串。
