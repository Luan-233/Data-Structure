# 有关各种数据结构&求解思想及应用

编者注1：这里的数据结构是一个广义的概念，只要是能够支持快速的利用性质存储、合并信息，以快速求解的算法都算入广义数据结构里面。这里面绝大多数是竞赛用数据结构与算法，少部分为工程应用里面的数据结构。所有的代码均为个人喜好写法。

编者注2：阅读之前请有一定的离散数学、概率论、组合数学、动态规划、摊还分析基础。后续会考虑往里面加一些图片，以及一些讲解优秀的博客链接。

by Luan_233

### 线性数据结构

----

#### 链表-List

一种线性数据结构，支持维护一个序列，快速在某个位置插入或者删除一个元素。

+ 单链表

  需要维护初始位置也即链表头，以及每个结点的下个位置，一般记为$next$指针。插入删除元素需要提前预知所在结点的前一个位置，然后改动$next$指针解决。

  ```c++
  int head, nxt[maxn], ptr;
  inline void init() { head = ++ptr; }
  inline int newnode() { return ++ptr; }
  inline void insert(int pre, int cur) { nxt[cur] = nxt[pre], nxt[pre] = cur; }
  inline void remove(int cur) { nxt[cur] = nxt[nxt[cur]]; }
  ```

  从代码来看就是惰性删除，也就是说某个被删除的结点的出边仍然有效，但是如果从头指针开始访问则永远不会被访问到。

  遍历的时候需要从头开始。所以说查找链表内部是否存在某一个特定的元素的复杂度是$O(n)$的。

  ```c++
  for (int i = head; i; i = nxt[i]) {
  	//do something
  }
  ```

  接下来直接以应用的形式讲解。

  + 邻接表

    用于存储图。一般来讲邻接表适用于存储稀疏图如树。图上每个点对应一个链表，存储其所有的出边。

    下面给出一个存储无向图的邻接表。

    ```c++
    int head[maxn], nxt[maxm], to[maxm], cnt;
    inline void add(int u, int v) {
    	nxt[++cnt] = head[u], head[u] = cnt, to[cnt] = v;
    	nxt[++cnt] = head[v], head[v] = cnt, to[cnt] = u;
    }
    ```

  + 哈希表

    本质就是一个散列表实现的集合容器，可以用来存储映射或者是单纯的存储元素。

    一般来讲键值都是非负整数，考虑如何压缩数据至一起，那么考虑模一个数，得到一个剩余系，但是显然不同的原数会在模剩余系下有冲突，所以每个模剩余系下的数都会对应一个链表，串起所有模剩余系下相同的数。

    一般来讲模数选一个稍大的质数使得冲突概率降低，同时使数据分布更均匀。

    下面给出一个重载运算符实现的哈希表。可以用来维护整型变量的映射。
    
    ```c++
    struct hash_table {
    	int head[mod], nxt[maxn], key[maxn], val[maxn], cnt;
    	int & operator [] (const int& x) {
    		int tmp = x % mod;
    		for (int i = head[tmp]; i; i = nxt[i]) if (key[i] == x) return val[i];
    		nxt[++cnt] = head[tmp], head[tmp] = cnt, key[cnt] = x, val[cnt] = 0;
    		return val[cnt];
    	}
    };
    ```
    
    由于哈希表本身在数据较少的情况下运行很快，单次查找可以近似看做是$O(1)$的，那么可以用来代替STL的map实现更快的映射存储。
    
    + 例题1：洛谷P5358 [SDOI2019]快速查询
    
      题中存在总共$nq$次操作，那么容易想到总复杂度是$O(nq)$，不能使用传统的log级数据结构维护。容易发现没有区间修改区间求和等操作，那么考虑类似于区间加区间求和打标记的过程，用一个哈希表记录被单点修改的特例，全局维护加法标记$Add$、乘法标记$Mul$（标记对哈希表也生效）与全局和$Sum$、不在哈希表内元素的值$Res$，线性预处理逆元，对6种操作处理：
    
      + 单点修改：修改$Sum$，在哈希表内查一下，将哈希表内此元素的值赋为$(val-Add)\times Mul^{-1}\ mod\ P$。
    
      + 全局加：修改$Sum$与$Res$，修改$Add$。
    
      + 全局乘：修改$Sum$与$Res$，修改$Add$与$Mul$。特殊的，全局乘0可以转化为赋值0规避逆元处理。
    
      + 全局赋值：修改$Sum$与$Res$，清空修改$Add$与$Mul$，清空哈希表。
    
        容易发现这一步需要一个$O(size)$的清空操作，由摊还分析知，其清空总量与前面的单点修改总量相同，所以总的清空复杂度不会超过$O(nq)$。
    
      + 单点询问：查这个元素是否在哈希表内存在，若存在直接返回，若不存在则返回$Res$，先乘后加得到其真实值。
    
      + 全局和：直接返回$Sum$即可。
    
      容易发现经过以上分析，总复杂度$O(P+nq)$。

+ 双向链表

  实现了单链表无法快速查询前驱元素的问题。也就是说每个结点有两个指针，指向前一个结点与后一个结点。

  插入删除与单链表的原理相同，只不过需要额外维护指向前一个位置的指针。

  ```c++
  int head, nxt[maxn], pre[maxn], ptr;
  inline void insert(int prec, int cur) {
  	pre[cur] = prec, nxt[cur] = nxt[prec];
  	pre[nxt[prec]] = cur, nxt[prec] = cur;
  }
  inline void remove(int cur) {
  	nxt[pre[cur]] = nxt[cur], pre[nxt[cur]] = pre[cur];
  }
  ```

  下面给出一些与双向链表有关的例题。多数时候链表只是辅助工具。

  + 例题1：洛谷P1081 [NOIP2012 提高组] 开车旅行

    显然AB要去的城市就在东边第一或二个比它高或低的位置里面。考虑如何求解快速找到这四个位置：将所有的城市按照海拔排好序修建链表，记录每个城市在链表内的位置。从东向西逐一枚举所有的城市，显然在这个双向链表内查找前后两个结点的元素就可以了。查询完以后就直接把这个点在链表内删掉，保证了后续枚举点的时候就不会有西边的城市干扰。并且由于链表内部剩余元素的有序性，使得后续的前驱后继查找也是正确的。

    后续实现依赖于倍增，不在这里的讨论范围内。

  + 例题2：洛谷P3620 [APIO/CTSC 2007] 数据备份

  + 例题3：洛谷P1792 [国家集训队]种树

    上面这两道题需要配合堆使用。故放在堆的版块讲解。

+ 循环链表

  就是把链表头尾套接到一起。一般用于处理有环的问题。

+ 十字链表

  需要维护上下左右四个指针，用于DLX算法精确覆盖的快速实现。这里不做赘述。

----

#### 栈-Stack

一种线性数据结构，支持在一个容器内访问栈顶元素、插入一个新元素作为栈顶、移除栈顶等操作。

下面给出简单的封装实现。多数情况下由于操作简单，并不需要封装实现。

```c++
struct stack {
    int stk[maxn], tp;
    inline void init() { tp = 0; }
    inline void push(int x) { stk[++tp] = x; }
    inline int top() { return stk[tp]; }
    inline void pop() { stk[tp--] = 0; }
};
```

+ 括号匹配

  也就是给定一个左右括号匹配的序列，里面可能包含各种各样的括号比如小括号方括号花括号，然后递归的定义匹配合法性：

  + 空序列是合法的。
  + 若括号序列$S$是合法的，那么$(S)$、$[S]$、$\{S \}$都是合法的括号序列。
  + 若括号序列$S_1$与$S_2$均是合法的，那么$S_1S_2$是合法的括号序列。

  解法：遇到左括号就压栈，遇到右括号就检查栈顶，若栈顶括号不与之匹配或者栈空就是不合法的，否则弹掉栈顶继续操作，结束以后若栈为空就是合法的括号序列。

  正确性：这个就是表达式运算排除掉运算符以及常数和代数数后的剩余部分，那么需要考虑运算的优先级，建出相应的语法树，若自右向左运算优先级递降那么直接弹栈处理即可，若遇到运算优先级变化的情况，就需要把优先级高的这一部分先处理掉，显然优先级高的部分括号嵌套层数越多，按照这个语法树深度的优先级处理即可。

+ 单调栈

  用于求解一个序列中，某一个元素向左或向右第一个大于或小于它的位置。

  单调栈保证栈内元素单调递增或者递减，每插入一个元素就要先检查栈顶与其相对关系，弹栈维护单调关系以后再插入元素。

  以求解第一个小于其位置的元素的左端点位置$+1$为例给出代码。注意若左边没有比它小的那么答案就是$1$。其含义为求解其作为区间最小值时左端点可以取到的最左位置。

  ```c++
  int n, s[maxn], stk[maxn], top;
  for (int i = 1; i <= n; ++i) {
  	while (top && (s[stk[top]] >= s[i])) --top;
  	lsid[i] = top ? (stk[top] + 1) : 1, stk[++top] = i;
  }
  ```

  正确性：仍然以上面的代码为例，注意到每一次弹栈都是去掉了大于等于当前位置的元素，每个栈内元素加入之前也会进行弹栈，同样也是弹掉大于等于其值的元素，这个过程满足单调性，也就是说弹掉的元素以及弹掉的这个元素入栈的时候所弹掉的元素都是大于当前位置的值的，那么只有小于关系能够保留下来，原先所有的不单调的地方都不会成为答案，也就是说弹掉的部分完全不会对后方产生贡献。由栈内自底到顶的单调性，取栈顶位置就是第一个满足比较结果变号的位置。

  单调栈例题：

  + 例题1：POJ2559 Largest Rectangle in a Histogram

    一个极大子矩形一定下面贴底线上面某条线碰到最高位置，那么一个朴素的想法就是枚举每一个位置的高度作为最高点，向左右扩张到最远的距离，显然就是求解左右第一个小于高度的位置，单调栈处理即可。

  + 例题2：洛谷P4147 玉蟾宫

    考虑枚举下边界在哪一条线上，然后预处理出每个位置自下而上能延伸到的最长位置，问题就可以转化为例题1的求解。总复杂度$O(nm)$。

  + 例题3：洛谷P1169 [ZJOI2007]棋盘制作

    黑白相间的不好处理，于是对斜对角线不相邻的格子反色，那么就变成了求解最大同色块的正方形与矩形。第一问使用DP求解不做介绍，第二问求解就是上面那个最大子矩形的问题。
    
  + 例题4：洛谷P1823 [COI2007] Patrik 音乐会的等待

    考虑类似于单调栈的过程，栈内保存严格递降的高度，那么容易发现先前被弹掉的一定不会和后面的配对成为答案，因为有一个更高的在其后面。那么在逐一弹栈的过程中，当前弹掉的一定可以和要入栈的高度配对，因为中间没有比两端点还高的高度（单调栈的性质）。
    
    这个题中存在相同高度且只要满足最大值不超过两端点就会有贡献，那么在这个栈内额外维护一个元素个数，也就是记录高度和在这个高度的数有多少个，用`pair`维护，若弹栈后栈顶高度等于要加入的高度，那么栈顶记录的数目个位置都会和新加入的产生贡献，并且在这个前提下，若栈内不止这一个高度，其左面第一个比它高的位置也可以产生配对，需要再加$1$。
    
  + 例题5：洛谷P3722 [AH2017/HNOI2017] 影魔

    问题可以分成两个部分解决，分别为：一个子区间的左右端点是区间的最大值与次大值，以及左右端点中恰有一个是最大值，且另一个不是次大值。

    对于第一个子问题，当左右端点成为区间的最大值与次大值的时候，考虑让右端点成为最大值且左端点成为次大值，一个暴力的思路是从右端点开始找第一个比右端点大的左部的值，这个就成为了限制条件，然后如果令左端点成为次大值，那么左端点一定大于区间内部的所有值。这个过程和单调栈是等价的，即自左到右维护一个递减的单调栈，如果栈顶小于要入栈的数，那么从栈顶到当前数这个区间一定满足条件。这个由单调栈的性质可以得出。且左端点是次小值，右端点是最小值。同时，当右端点成为次小值的时候，就是栈不为空，且栈顶大于当前数。所以用单调栈即可求得所有的第一类问题的合法区间。并且由于单调栈的线性性质，这种合法区间总共是$O(n)$的，统计答案的时候将左右端点用横纵坐标表示，用二位数点即可解决。

    对于第二个子问题，考虑枚举区间内部的最大值在哪里取到，即枚举题目中的$c$，用单调栈求出左右第一个大于它的位置。假设左侧第一个大于$i$位置数的位置在$L$，右侧在$R$，以左端点成为区间最大值为例，区间$[L,i+1],[L,i+2],\dots [L,R-1]$均会产生$p2$的贡献，于是把贡献放在右端点上面统计，同样离线处理，按照单调栈求出的左端点$L$降序排序，询问的左端点也降序排序，扫到一个单调栈的左端点时将$[i+1,R-1]$对应位置$+1$，然后区间求和计算贡献。用区间加区间求和的数据结构即可实现。同理右端点成为最大值的情况。

+ 表达式的求值

  这里只考虑只含有加减乘除以及小括号的表达式。容易发现只使用小括号标定优先级，也是可以替代中括号大括号发挥作用的。以下假设表达式是合法的，即括号、运算符与数字匹配，且没有除以$0$的情况。
  
  表达式求值本质上也是单调栈的利用。首先按照语法树的形式表示一个运算的过程，开两个栈，一个记录数字一个记录运算符与括号。在此基础上定义弹栈操作：取出数字栈中最上面两个元素以及符号栈中栈顶，进行一次运算后将结果放回数字栈。
  
  容易发现当计算的优先级自左向右递增的时候，直接自左向右用栈记录数字以及操作顺序，然后弹一遍栈即可。但是绝大多数表达式运算优先级都是不固定的，那么需要考虑处理表达式的时候，一旦运算优先级下降，就处理前面一部分表达式的结果，让栈内运算优先级自栈底向栈顶递增。这也就是这个做法的正确性所在。
  
  那么按照基础的词法分析操作，将一句表达式拆成数字与符号，然后考虑自左向右处理表达式：
  
  + 若遇到数字则压入数字栈。
  + 若遇到左括号则压入符号栈。
  + 若遇到加减号，则一直弹栈直到符号栈空/栈顶为左括号，将这个运算符压入符号栈。
  + 若遇到乘除号，则一直弹栈直到符号栈空/栈顶为左括号或加减号，将这个运算符压入符号栈。
  + 若遇到右括号，则一直弹栈直到弹出一个左括号为止。
  
  然后最终做一遍弹栈，数字栈内部唯一的元素就是表达式的结果。
  
  + 例题1：洛谷P1054 [NOIP2005 提高组] 等价表达式
  
    把$x$看做是一个常数，随机几个大数进去算，取模判断结果即可。

----

#### 队列-Queue

线性表的一种，允许查询一个序列的首尾元素，支持在队头或者队尾插入或者删除一个元素。

下面给出一个常用的封装实现双端队列（即首尾均可支持操作）。其中存放有效元素的区间是$[head,tail)$。

```c++
struct queue {
    int q[maxn], head, tail;
    inline void init() { head = tail = 0; }
    inline void push_back(int val) { q[tail++] = val; }
    inline void pop_back() { --tail; }
    inline void push_front(int val) { q[--head] = val; }
    inline void pop_front() { ++head; }
    inline int back() { return q[tail - 1]; }
    inline int front() { return q[head]; }
};
```

+ 单调队列

  用于求解左右端点均向一个方向单调变化的区间内的最大最小值。

  + 例题1：洛谷P1886 滑动窗口

    以这个例题直接阐述滑动窗口类问题的做法。滑动窗口问题指的是多次询问区间最值，并且所有的询问保持左右端点均单调不降。比如最经典的朴素滑动窗口问题，也就是说询问所有的长度为$K$的子区间的最大最小值。

    以求解序列$a_i$的区间最大值为例，假设现在要处理第$i$个位置，并且获得区间$[i-K+1,i]$的最值，这个队列内存放序列下标，自左向右下标递增，并且自左向右对应序列中的元素值递降。当一个新元素到来的时候，需要做两件事：

    + 第一步，若队首已经小于$i-K+1$，说明队首已经不在这个区间内部，可以直接弹掉。
    + 第二步，若队尾所在位置的元素小于等于$a_i$，那就一直弹队尾直到队列为空或者队尾位置元素大于$a_i$，把$i$放入队尾。

    下面给出一个求解区间最大值的代码。

    ```c++
    int a[maxn], q[maxn], head, tail, n, k;
    for (int i = 1; i <= n; ++i) {
    	while ((head < tail) && (q[head] < i - K)) ++head;
    	while ((head < tail) && (q[tail - 1] <= a[i])) --tail;
    	q[tail++] = i;
    }
    ```

    复杂度：显然复杂度在于入队和出队，每一次入队或者出队需要$O(1)$的复杂度，那么由于每个元素恰好入队一次，至多出队一次，也就是说总的出入次数不超过$2n$，其总复杂度就是$O(n)$。

    正确性：显然前$K$个元素组出来的单调队列实质就是单调栈，不涉及队头操作，那么考虑在$i>K$时，双向修改这个单调栈，队头弹掉的部分由于不满足区间长度限制而永远不会成为区间最值，队尾弹掉的部分由于其右侧存在一个比它大的数，故不会成为当前和后续的区间最大值（因为既靠左，数值还小，不可能有贡献），只有留存下来的部分“有潜力”成为某个区间的最大值。并且由于单调性，队头所指的位置就是区间最大值。

    那么类比长度固定的滑动窗口，询问左右区间单调不降的区间最值也可以使用同样的方法实现查询。

  + 例题2：洛谷P2216 [HAOI2007]理想的正方形

    问题可以转化为求解每一个子正方形的最大值与最小值，那么任何一个$K\times K$的子正方形的最值都可以拆分成求解所有的$1\times K$个子矩形求最值，然后再把连续的$K$个$1\times K$个子矩形的最值拿出来再求一个最值，显然可以用两遍单调队列实现。具体而言，以求解最大值为例，设$max1(i,j)$表示以$(i,j)$为最上面的方格时，其向下延伸$K$个单位形成的矩阵内的最大值，对每一列使用单调队列求出，然后再设$max2(i,j)$表示以$(i,j)$为一个$K\times K$正方形的左上角时，这个正方形内元素最大值，可以发现$max2(i,j)=max\{max1(i,l) \}$，其中$j\le l \le j+K-1$, 也可以使用单调队列求出。每个方格进出队最多一次，故两遍单调队列分别都是$O(nm)$的复杂度。同理最小值的求解。

  + 例题3：洛谷P3512 [POI2010]PIL-Pilots

    考虑枚举一个左端点，向右扩展到一个最长的位置，保证这两个端点作为左右端点的序列中，最大最小值的差不超过$K$，那么考虑将左端点右移一个位置，那么此时左右端点形成的序列也满足约束条件，并且右端点可能继续向右扩展，获得更优的答案。容易发现这个类似于双指针的过程中，左端点单调递增，右端点单调不降，需要实现区间最大最小值的查询，于是使用单调队列维护即可。

  + 例题4：洛谷P3594 [POI2015]WIL

    显然一定把长度为$d$的区间全部置$0$是最好的，那么考虑固定一个左端点向右寻找一个最靠右的位置，使得区间和减去区间内最大的长为$d$的子段满足最大且不超过$p$。

    接下来证明，右端点单调递增的同时，区间和减去区间内长为$d$的最大子段和也是单调变化的。考虑在$[l,r]$合法的基础上，拓展到$[l,r+1]$，若最大子段不变，那么这个值会增大$a_{r+1}$，若最大子段变化，那么显然只能变成$[r-d+2,r+1]$，因为先前所有长度为$d$的子段都不比最大子段优；在此基础上先前最大子段的和（设为$maxd$）大于等于$[r-d+1,r]$的区间和，也就是大于$[r-d+2,r]$的区间和。那么设$sum(l,r)$表示$[l,r]$的区间和，那么求解前后的变化：
    $$
    sum(l,r+1)-sum(r-d+2,r+1)-(sum(l,r)-maxd)\\
    =a_{r+1}-sum(r-d+2,r+1)+maxd\\
    =maxd-sum(r-d+2,r)> 0
    $$
    那么在此基础上可以使用双指针求解左端点固定的时候的最大右端点，区间和的最值则只需要对前缀和维护单调队列，因为双指针的左右端点都是单调变化的。

+ 单调队列实现DP优化
  
  + 区间最值型优化
    + 例题1：洛谷P3957 [NOIP2017 普及组] 跳房子
    
      容易发现当$g$越来越大的时候，能得到的最优解一定是单调不降的，并且向右跳可以等价转化为从左跳过来，所以二分一个最小的$g$进行DP：设$f(i)$表示最后跳到第$i$个格子上，前面能够得到的最大值。容易发现转移的约束条件是一个自左向右滑动的窗口，取窗口里面的最大DP值转移。
    
    + 例题2：洛谷P2254 [NOI2005] 瑰丽华尔兹
  
      $t$很大，于是按照时间段进行DP，设计状态为$f(x,y,t)$表示第$t$个时间段结束，到达$(x,y)$时最长的移动距离，以从上面向下移动为例，假设船体向下倾斜的时间长度为$t_i$，那么有$f(x,y,t)=max(f(x',y,t-1)+x-x')$，其中$x-x'\le t_i$。若$(x,y)$为障碍物那么$f(x,y,t)=-INF$即可，容易发现这样即使不考虑转移点是否为障碍物都是合法的。这个形式可以使用单调队列优化。剩余的三个方向同理。
    + 例题3：洛谷P2569 [SCOI2010]股票交易
    
      容易看出是一个二维DP的模型，设状态为$f(i,j)$表示前$i$天手里有$j$张股票的最大收益，其隐含了最后一次交易不会发生在第$i$天后。那么考虑三种状态：
    
      + 当天不买，$f(i,j)=max\{f(i,j),f(i-1,j) \}$。
      + 当天买入股票，$f(i,j)=max\{f(i,j),f(i-w-1,k)-(j-k)\times AP_i \}$，约束条件为$j-AS_i\le k \le j$，容易拆开方程得到$f(i,j)=max\{f(i-w-1,k)+k\times AP_i \}-j\times AP_i$，对前者以$k$为下标维护单调队列即可实现$O(1)$转移。
      + 卖出股票与买入同理，$f(i,j)=max\{f(i-w-1,k)+k\times BP_i \}-j\times BP_i$，约束条件为$j\le k \le BS_i+j$。
    
      需要初始化前$w$天的情况，因为这几天只能买入不能卖出，并且由于$f$隐含前若干天的最优情况，需要对初始化的结果做前缀和。DP要从第$w+1$天开始。
    + 例题4：洛谷P5665 [CSP-S2019] 划分
    + 例题5：洛谷P7832 [CCO2021] Bread First Search
    
  + 斜率优化
    + 例题1：洛谷P3195 [HNOI2008]玩具装箱
  
      考虑一个朴素的DP，设$f(i)$表示前$i$个玩具都被放进箱子里面时的最小代价，那么有$f(i)=min(f(j)+(sum(i)+i-sum(j)-j-L-1)^2)$，其中$sum(i)=\sum_{j=1}^{i}C_j$。简化这个式子，设$g(i)=sum(i)+i-L-1$，$t(i)=sum(i)+i$，那么$f(i)=min\{f(j)+(g(i)-t(j))^2\}$。
    
      拆开$f(i)$的式子得到$f(i)=g(i)^2+min\{f(j)+t(j)^2-2g(i)t(j)\}$，对于每个$i$，设其转移点为$p$，那么就会有$f(i)=g(i)^2+f(p)+t(p)^2-2g(i)t(p)$，变化一下形式得到$f(p)+t(p)^2=2g(i)t(p)+f(i)-g(i)^2$。
  
      对于所有可能的转移点$k$，设$y=f(p)+t(p)^2$，$k=2g(i)$，$x=t(p)$，$b=f(i)-g(i)^2$，就有了一次函数斜率式的情况。容易发现对于转移点$p$，其$xy$都在前面处理好，所以可以把它们放在一个二维平面上，变成若干决策点，那么在处理$i$的时候$k$已知，那么此时最小化$f(i)$，就是最小化$b$，其几何意义很明确：拿一条斜率固定的直线经过二维平面上的若干点，使得纵截距最小，显然只能取在点集的下凸包上面。
    
      这时候拿一个数据结构维护下凸包序列，由于$x=t(p)$单调递增，在这个前提下有两种思路：
    
      + 用一个栈维护下凸包，栈里面存入所有的决策点，并且从栈底到栈顶的相邻决策点之间的斜率单调递增，插入的时候就考虑比较栈顶和插入决策点、栈顶与栈顶下的第一个决策点之间斜率的关系，若不满足单调递增就直接弹栈顶，直到斜率满足单调关系或者栈内只有一个点为止。由于斜率的单调性，那么已知切线斜率的前提下直接在栈内二分决策点位置，总复杂度$O(nlogn)$。
      + 用一个队列维护下凸包，注意到切线斜率也单调递增，那么先前不会成为决策点的位置以后也不会成为决策点，所以直接按照栈的实现方法，维护一个相邻决策点斜率递增的单调队列，队头处的斜率若达不到当前切线斜率就直接弹出，队尾的实现方式与栈一样维护，总复杂度$O(n)$。
    
    + 例题2：洛谷P3628 [APIO2010]特别行动队
    
      只不过把下凸包改为上凸包，其实现思想是一样的。
    
  + 多重背包的优化
  
    考虑多重背包在实现的时候的转移方程，设$f(i,j)$表示前$i$件物品里面花至多$j$元的情况下能够得到的最优解，那么有转移方程
    $$
    f(i,j)=max\{f(i-1,j-k\times cost)+k\times value \}(0\le k \le min\{nums,\lfloor\frac{j}{cost}\rfloor \})
    $$
    设$j=p\times cost+q$，其中$0\le q <cost$，那么转移方程写作：
    $$
    f(i,j)=max\{f(i-1,q+(p-k)\times cost)+k\times value \}(0\le k \le min\{nums,\lfloor\frac{j}{cost}\rfloor \})
    $$
    换元，令$t=p-k$，则$\lfloor \frac{j}{cost} \rfloor-min\{nums,\lfloor \frac{j}{cost} \rfloor \} \le t \le \lfloor \frac{j}{cost} \rfloor$，转移方程变化为
    $$
    f(i,j)=max\{f(i-1,q+t\times cost)+(p-t)\times value \}(\lfloor \frac{j}{cost} \rfloor-min\{nums,\lfloor \frac{j}{cost} \rfloor \} \le t \le \lfloor \frac{j}{cost} \rfloor)
    $$
    那么容易发现所有的转移点取值在模$cost$意义下相同，那么以在转移之前，对于所有不同的$q$，维护一个单调队列来记录模$q$相同的花费下的$f(i-1,q+t\times cost)-t\times value$，显然建立这些单调队列的时间复杂度是$O(V)$的。
    
    下面我们说明$t$的取值区间左右均是单调的：显然右端点随着$j$的增大单调不降；对于左端点，当$\lfloor \frac{j}{cost} \rfloor$逐渐增大的时候，其大小未达到$nums$之前的左端点一直是$0$，达到$nums$以后左端点是$\lfloor \frac{j}{cost} \rfloor-nums$，也随着$j$的增大单调不降，故可以使用单调队列优化。容易发现每个状态入队恰好一次，出队至多一次，故复杂度$O(nV)$。

----

### 维护集合的树形数据结构

----

#### 堆-Heap

堆是一种用于维护集合最值、插入元素、删除最值的数据结构，其逻辑形态为一棵二叉树。

+ 普通堆的维护：

  首先介绍数据的堆式存储形式。堆式存储以$1$号结点为堆顶结点，设某个结点编号为$x$，那么其左儿子结点编号为$2x$，右儿子结点为$2x+1$，父节点为$\lfloor \frac{x}{2} \rfloor$，结点标号连续。下面以大根堆为例给出一个代码实现以及讲解。容易发现在这种存储形式下，若这个堆有$n$个结点，那么其高度为$\lceil log_2(n+1)\rceil$。

  介绍线性建堆算法。这个算法的思路在于循环不变式的应用。我们认为一个结点是一个堆，对于一个结点，若两个子树均满足堆性质，但算上这个结点以后有可能不满足堆性质，那么可以通过调整它的位置，把两个小堆结合成一个更大的堆。容易发现只要取出两个子堆里面堆顶元素较小的那个作为交换，把堆顶换下去变成一个子问题，就可以在上界为子堆深度的复杂度内维护这个堆。

    ```c++
    int val[maxn], siz;
    inline void make_heap(){
        for (int i = siz; i; --i) {
            int cur = i;
            while ((i << 1) <= siz) {
                int son = (cur << 1);
                if ((son < siz) && (val[son] < val[son + 1])) ++son;
                if (val[cur] >= val[son]) break;
                std::swap(val[cur], val[son]), cur = son;
            }
        }
    }
    ```

  其复杂度为$T(n)=\sum_{i=1}^{log_2n}2^{i-1}(log_2n-i+1)=O(n)$。

  下面介绍插入操作，每插入一个元素，首先在数组尾部加入这个新元素，然后考虑调整数据结构，维护这个结点到根上面所有的包含它的子树。若某个结点以下的二叉树不满足大根堆性质，就把父节点换下去，若依然不满足，就继续交换直到满足为止。由插入前各个结点元素信息之间的单调性可知这样做可以正确维护信息。

  ```C++
  inline void push(int x) {
  	int cur = ++siz, fa;
  	val[siz] = x;
  	while ((cur > 1) && (cur >> 1)) {
  		fa = cur >> 1;
  		if (val[cur] <= val[fa]) break;
  		std::swap(val[cur], val[fa]), cur = fa;
  	}
  }
  ```

  最后是删除堆顶元素的操作。首先取出堆尾部元素覆盖到堆顶，然后类似于建堆操作向下调整。

    ```c++
    inline void pop() {
        int cur = 1, son;
        val[1] = val[siz], val[siz--] = 0;
        while ((cur << 1) <= siz) {
            son = cur << 1;
            if ((son < siz) && (val[son] < val[son + 1])) ++son;
            if (val[cur] >= val[son]) break;
            std::swap(val[cur], val[son]), cur = son;
        }
    }
    ```

  显然单次操作复杂度上界为这棵树的高度，为$O(logn)$。

+ 一些直接实现最值查找的例题

  + 例题1：洛谷P1631 序列合并

    把这$n^2$个数组成一个矩阵，矩阵中$f_{ij}=a_i+b_j$，那么考虑把其中的$b_i$从小到大排序，每一行维护一个头指针，每一行的值都单调不降，那么可以看做是这$n$个单调序列的合并，求出前$K$大即可，显然可以用堆来维护每一行的指针，即用一个二元组维护当前指针指向的矩阵内的值以及其对应$b$中的排名，用小根堆维护，每一次取出一个最小值，然后二元组内的指针后移一位，排序关键字加上$b$差分序列的值以后再插入回堆内，持续$K$次得到前$K$最小值。复杂度$O(klogn)$。

  + 例题2：洛谷P2048 [NOI2010] 超级钢琴

    考虑固定右端点的情况下左端点的范围是一个连续的区间，那么设四元组$f(l,r,pos,val)$为左端点位于$[l,r]$内，右端点位于$pos$时，最大的区间和是多少，假设位置$x$满足$l\le x\le r$且区间$[x,pos]$的区间和最大，那么考虑类似于$n$路归并的过程，下一个位置要寻找次大值，显然在是左端点位于区间$[l,x-1]$或者$[x+1,r]$内的最大值，用前缀和加上一个支持查询区间最值位置的数据结构维护，所有的四元组用小根堆维护。堆内每取出一个元素，就在区间最值处分裂成两侧的区间最值再插入回来，反复操作$K$次就可以得到结果。总复杂度$O((n+k)logn)$。

+ 堆实现贪心优化例题

  + 例题1：洛谷P1090 [NOIP2004 提高组] 合并果子

    每一次都是合并集合内的两个数，那么考虑

  + 例题2：洛谷P3045 [USACO12FEB]Cow Coupons G

    这是一道调整型的贪心，然后考虑如何

  + 例题3：洛谷P3620 [APIO/CTSC 2007] 数据备份

    经典的堆配合链表实现的可以反悔的贪心。

  + 例题4：洛谷P1792 [国家集训队]种树

    把上面那道题的线性链表转为环形链表即可。

  + 例题5：例题4：洛谷P4331 [BalticOI 2004]Sequence 数字序列

  + 例题6：洛谷P5470 [NOI2019] 序列

+ 哈夫曼编码的实现

  哈夫曼编码是一种数据压缩算法，其思想是用不同的01串（变长编码）代替原文件中每一种字符，且出现次数多的字符使用的01串短，出现次数少字符的使用的01串长，来让压缩后的01串尽可能短，且所有的对应01串互不为前缀，保证数据解压缩的时候只要做前缀匹配，一旦匹配出一个可以替换的串就进行替换。下面讲述如何建立哈夫曼树，也就是所有01串的Trie树，满足其$\sum_{leaf\in T}deep(leaf)\times frequency(leaf)$最小。

  

  + 例题1：洛谷P2168 [NOI2015] 荷马史诗

  堆还可以用于诸如最小生成树的Prim算法、最短路Dijkstra算法、最大流HLPP算法（最高标号预流推进）等的优化实现，在此不一一赘述。

+ 对顶堆

  对顶堆不是严格的数据结构，任意两个单调性相反的堆均可以用做对顶堆。其功能是维护一个集合，支持每次插入一个元素并询问当前集合内元素的中位数。

  其具体手法是维护两个单调性不同的堆，满足两个堆内部元素数目差值至多为$1$，小根堆堆顶元素大于等于大根堆内部元素。当插入一个元素的时候考虑其与两个堆顶的元素的大小关系，若小于大根堆堆顶则放入大根堆，若大于小根堆堆顶则放入小根堆，若在两个元素之间就任意放入一个元素数目较少的堆即可。注意到前两种情况下可能会破坏性质“两个堆内部元素数目差值至多为$1$”，但此时至多差值为$2$，那么从元素数目较多的堆里面拿出来堆顶元素放入另一个就可以了。查询中位数就是查询元素数目较多的那个堆的堆顶元素。显然复杂度为$O(nlogn)$。

  + 例题1：洛谷P1168 中位数

    模板题直接套用即可。

  + 例题2：洛谷P1801 黑匣子

    这个做法由对顶堆扩展而来，由于询问限制只是集合并且询问排名单调，那么考虑用一个类似于对顶堆的数据结构维护，插入就按照对顶堆的形式插入，但注意要维护大根堆的大小，其容量始终为当前询问的排名，以保证大根堆顶元素就是当前要查询的那个数。每次做完一个询问就把小根堆中的堆顶放入大根堆，显然调整时进行操作的次数是常数，总共询问排名的增量不会超过$n$，所以总复杂度为$O(nlogn)$。不需要别的求解区间第K大的数据结构，常数十分优秀。

+ 左偏树

  可并堆的一种。可以用于可持久化。

  对于所有的二叉树引入一个概念，对于任意一个二叉树结点$cur$，定义$dist(cur)$表示从$cur$出发至少需要向下走多少步才能走到一个空结点。我们认为，若一个结点不存在某个子结点，那么这个子节点可以直接设为哨兵。那么在这个基础上，哨兵结点满足$dist(cur)=0$，否则$dist(cur)=min\{dist(ls),dist(rs)\}+1$。

  接下来证明，对于一个根结点的$dist$为$x$的树，其结点总数不少于$2^{x}-1$，因为在结点数最少的情况下是一棵满的完全二叉树（否则多余的结点可以被删掉而不影响根结点的$dist$），需要保证从根结点能够走到所有$2^{x-1}$个可能的叶子结点，才不会在$x-1$步内走到哨兵，此时结点总数为$2^x-1$。所以对于一个$n$个结点的二叉树，其根结点$dist$一定是$O(logn)$的。这一点对于所有的二叉树都成立，而不仅仅局限于要讲到的左偏树。

  左偏树正是依赖于$dist$的性质保证复杂度。任何时候，对于一个左偏树内部结点$cur$，都满足$dist(ls)\ge dist(rs)$，这意味着$dist(cur)=dist(rs)+1$。

  对于合并操作，假设形态为小根堆，且合并两个堆的堆顶结点分别为$xy$，那么首先比较$x$与$y$对应的值大小，假设$val_x<val_y$，那么堆顶设为$x$，将$rs(x)$与$y$递归合并，直到至少有一个结点是哨兵，停止递归返回另一个点的下标。然后维护$x$的左偏树性质，也就是当$dist(ls)<dist(rs)$的时候交换左右子树，最后维护$dist(x)$。

  基于上面这个思路，可以写出如下的合并过程。

  ```c++
  int merge(int x, int y) {
  	if ((!x) || (!y)) return x | y;
  	if (val[x] > val[y]) std::swap(x, y);
  	rs[x] = merge(rs[x], y);
  	if (dist[ls[x]] < dist[rs[x]]) std::swap(ls[x], rs[x]);
  	dist[x] = dist[rs[x]] + 1;
  	return x;
  }
  ```

  复杂度证明：容易发现每一次递归，传入的$xy$有恰好一个满足$dist$下降$1$，因为递归一定是一个结点与另一个结点的右子树合并，当某个点的$dist$变为$0$的时候就是递归边界，$dist$的和至多下降$log(size_x)+log(size_y)$级别，所以合并的复杂度是$O(log(size_x)+log(size_y))$的。

  + 例题1：洛谷P3377 【模板】左偏树（可并堆）

    在上面维护合并的同时也考虑如何维护删除堆顶，容易发现每个点需要额外维护根结点信息以方便合并，需要维护并查集，每一次合并都需要并查集一步合并操作。考虑删除堆顶，对于左偏树来讲，删除堆顶就只需要合并左右儿子即可，然后同步维护并查集根结点改变的情况。

    具体而言，一开始所有的并查集指向自己，合并的时候两个根的并查集指向合并完后的左偏树根，删除堆顶的时候由于左右子树的并查集指向堆顶，首先把堆顶的并查集指向左右子树合并后的根结点，然后把左右子树的并查集连向堆顶，这时候已经被删除的堆顶在并查集内作为一个中间桥梁存在，此时并查集的连通性依然成立。

    ```c++
    int n, m;
    int link[maxn], val[maxn], ls[maxn], rs[maxn], dist[maxn];
    bool valid[maxn];
    int merge(int x, int y) {
    	if ((!x) || (!y)) return x | y;
    	if (val[x] > val[y]) std::swap(x, y);
    	if ((val[x] == val[y]) && (x > y)) std::swap(x, y);
    	rs[x] = merge(rs[x], y);
    	if (dist[ls[x]] < dist[rs[x]]) std::swap(ls[x], rs[x]);
    	dist[x] = dist[rs[x]] + 1;
    	return x;
    }
    inline void pop(int x) {
    	link[x] = merge(ls[x], rs[x]), valid[x] = false;
    	link[ls[x]] = link[x], link[rs[x]] = link[x];
    }
    int find(int x) {
    	return (link[x] == x) ? x : (link[x] = find(link[x]));
    }
    int main() {
    	read(n, m);
    	for (int i = 1; i <= n; ++i) read(val[i]), link[i] = i, dist[i] = 1, valid[i] = true;
    	while (m--) {
    		int type, x, y; read(type, x);
    		if (type == 1) {
    			read(y);
    			if (!(valid[x] && valid[y])) continue;
    			if (find(x) != find(y)) link[find(x)] = link[find(y)] = merge(find(x), find(y));
    		}
    		else if (type == 2) {
    			if (!valid[x]) puts("-1");
    			else print(val[find(x)]), std::puts(""), pop(find(x));
    		}
    	}
    	return 0;
    }

  + 例题2：洛谷P1552 [APIO2012] 派遣

    考虑枚举每一个管理者，然后在子树里面选择尽可能多的忍者，那么显然是价格从小到大选择，那么对于每个点维护子树的忍者价格集合，用一个大根堆存储起来，当堆内元素和超过价格限制的时候就一直弹出堆顶，用堆内元素个数与管理者能力之积更新答案，这个过程可以在DFS的时候用左偏树维护子树合并与弹出。

    对于正确性，子树内被弹掉的价格永远不会成为候选答案，因为子树的左偏树已经是候选答案，能够比这个更优只能保证有比堆顶更小的替换进来，被弹掉的价格不可能替换进去能得到更小的和，所以可以理所当然的弹掉。

  + 例题3：洛谷P3261 [JLOI2015]城池攻占

    容易发现在可并堆的基础上加上了集合加和集合乘的操作，那么需要维护加法标记与乘法标记，其实现手法与线段树的实现并无区别，于是只需要DFS整棵树，自下向上合并每个点的骑士的信息，当一个点合并完其子树信息以后就进行弹堆顶，将不满足血量限制的弹掉，同时维护答案即可。

  + 例题4：洛谷P3642 [APIO2016] 烟火表演

+ 配对堆

  可并堆的一种。复杂度假但是运行效率优秀，不能用于可持久化。

+ 可持久化可并堆

----

#### 并查集-Union Find Set

并查集用于集合的合并，以及查询两个元素是否在同一个集合内。下面介绍若干种并查集使用手法和扩展，以及适于求解的问题。

容易发现集合的实现可以用一个有向森林来表示，类似于树的父节点表示法，每个点有唯一的出边，要么指向自己，要么能从自己出发，通过有向边走到一个出边指向自己的点。这个指向性的数组就是并查集，称这些出边指向自己的点为它所在集合的代表元素。在这种表示方法下，称两个元素在同一个集合内当且仅当两个元素对应在并查集内有相同的代表元素。集合的合并只需要把一个集合的代表元素的根指向另一个集合的代表元素，就可以实现合并与连通性查询的维护。

那么容易写出如下代码。

```c++
int fa[maxn];
int find(int x) { return (fa[x] == x) ? x : find(fa[x]); }
inline void merge(int x, int y) {
	x = find(x), y = find(y);
	if (x != y) fa[x] = y;
}
inline void init() { for (int i = 1; i <= n; ++i) fa[i] = i; }
```

但是这棵树的高度没有保证，有可能这棵树会退化成一条链使得每一次跳链寻找代表元素都是$O(n)$的，需要优化。

+ 路径压缩

  容易发现我们维护集合连通性的时候只关注代表元素，并不需要关注这棵树的形态。也就是说只要代表元素维护正确，所有的操作就是正确的。那么就可以想办法变化这棵树的形态快速降低树高。

  + 实现手法

    在寻找代表元素的时候把路径上面的点均指向代表元素即可。把$find$如下修改。

    ```c++
    int find(int x) { return (fa[x] == x) ? x : (fa[x] = find(fa[x])); }

  + 复杂度分析

    实际上这个复杂度并不是所谓的$O(n\alpha (n))$。但是就是架不住随机合并时的小常数。一般来讲在$2\times 10^6$的数据范围内，不加按秩合并随便用。

    但是只使用路径压缩依然可以做到比较优秀的复杂度，《算法导论》中提到：若在长度为$n$的序列上做$m$次$find$操作，只使用路径压缩策略，其时间复杂度为$\Theta(n+m+m\log_{2+\frac{m}{n}}n)$。

    实际上要达到$O(m\alpha(n))$的复杂度不仅需要路径压缩，还需要按秩合并。以下的摊还分析按照同时使用按秩合并和路径压缩的并查集来实现。
    
    

+ 按秩合并
  
  并查集也可以有类似于集合逐个元素合并的按秩合并手法。
  
  + 实现手法
  
    集合合并的时候只需要把小集合的代表元素指向大集合的代表元素。需要额外记录一个$siz$表示子树大小，然后如下修改`merge`的过程。初始化所有集合的$siz$为$1$。
  
    ```c++
    inline void merge(int x, int y) {
    	x = find(x), y = find(y);
    	if (x == y) return;
    	if (siz[x] < siz[y]) std::swap(x, y);
    	fa[y] = x, siz[x] += siz[y];
    }
  
  + 复杂度分析
  
    注意到每向上一步都代表了先前的一步从小集合到大的合并操作，而合并完以后相比较于小集合，其大小至少翻了一倍，那么每向上走一步子树大小都至少翻一倍，所以`find`的过程是$O(logn)$的。
  
+ 普通并查集的例题

  + 例题1：洛谷P1197 [JSOI2008]星球大战

    注意到只有删除边的情况，所以时光倒流变删边为加边，那么这时候就变成了集合合并，查询连通块数的简单问题。

  + 例题2：洛谷P2502 [HAOI2006]旅行

    把边按照边权从小到大排序，考虑暴力的枚举最小边，然后按边权自小到大加边，第一次$s,t$联通的时候那条加入的边就是最大边，然后用最大边除以枚举的最小边更新答案。集合的连通性用并查集维护。

    正确性可以这样理解：由于要求是最大边除以最小边最小，那么上述过程显然是求解出了一棵生成树，那么把生成树$st$以外的路径全部拿掉，显然最后加入的最大边一定会保留，那么若最小边在$s,t$路径之上，答案不会变化，若最小边不在$st$路径上，那么可以在$st$路径上找到一条更大的最小边，让答案更优，而这种更优的情况会在后续枚举更大的最小边的时候处理到，而且最优解一定存在于某种方案之中，故做法正确。

  + 例题3：洛谷P2906 [USACO08OPEN]Cow Neighborhoods G

  + 例题4：洛谷P3295 [SCOI2016]萌萌哒

    一个显然的暴力是$O(nm)$暴力合并并查集，然后求解连通块数量计算答案，显然会超时。

    考虑倍增的实现这个并查集，也就是说对每个位置$x$记录$[x,x],[x,x+1],[x,x+3],[x,x+7]\dots [x,x+2^{\lfloor log_2n\rfloor}-1]$的并查集，区间相等可以等价转化为RMQ问题的前后拆分（见ST表部分），$O(n\alpha(n))$把这一层的并查集进行合并，然后从长到短枚举并查集，把长度为当前枚举长度一半的并查集对位合并到当前层并查集的根所在位置，也就是说$[x,x+2^i-1]$与$[y,y+2^i-1]$对应相等，意味着$[x,x+2^{i-1}-1]$与$[y,y+2^{i-1}-1]$相等，并且$[x+2^{i-1},x+2^i-1]$与$[y+2^{i-1},y+2^i-1]$也相等。那么从长到短枚举向下合并，长度为$1$的时候就可以直接统计答案。时间复杂度$O(nlogn\alpha(n))$。

  + 例题5：洛谷P3623 [APIO2008]免费道路

    类似于跑Kruskal的过程，初始判断连通性，然后先加入鹅卵石路再加入水泥路，此时加入的水泥路是必须要加进去的，再反着跑一遍得到必须加入的鹅卵石路，把必须加入的边加进去，非必要边只需要加入调整至恰好$K$个即可。

  + 例题6：ICPC上海2021H Life is a Game

    原题解使用的是重构树，但注意到询问并不要求在线，那么考虑集合的合并，对每个点开一个`set`记录所有询问，按照边权自小到大加入边让图联通，容易发现若某一次加边以后答案没有变化，那么随着后续边权的增大，再向后答案也不再变化，这时只需要弹出set前面不能再更新的询问更新答案，然后剩余的答案可以继续增大的部分整体增加另一个连通块的权值和，对整个`set`打一个加法标记记录，然后集合合并维护连通块内的询问。集合的合并只需要按秩合并，注意不同集合合并的时候需要处理两个加法标记。

+ 带有偏移量的并查集（扩展域并查集）

  一般来讲并查集维护集合连通性关系，但有时候需要额外处理集合内部的分类情况，以及辨别两个物品之间的分类关系，就需要额外维护偏移量。

  一般来讲对于一个元素，其偏移量$d$是它到集合代表元素的偏移量，在执行`find`的时候动态维护。但更严格的讲，$d(x)$表示$x$到$fa(x)$的偏移量，下面以例题的形式讲解应用场景、实现方式以及正确性。

  + 例题1：洛谷P1196 [NOI2002] 银河英雄传说

    用集合的合并代替队列的合并，集合内每个元素的偏移量就是它到队头的距离，对每个集合维护它的$size$，便于后续的合并。

    假设把队列$Q_1$合并到$Q_2$的后面，那么$Q_1$内所有元素的偏移量都应当增加$Q_2$的$size$，然后把$Q_1$的并查集合并入$Q_2$。我们先给出这个过程采用带有偏移量的并查集的实现，然后说明正确性。

    ```c++
    int find(int x) {
    	if (fa[x] == x) return x;
    	int rt = find(fa[x]);
    	d[x] = d[x] + d[fa[x]];
    	return (fa[x] = rt);
    }
    inline void merge(int x, int y) {
    	int rx = find(x), ry = find(y);
    	if (rx != ry) d[rx] = siz[y], fa[rx] = ry;
    }
    ```

    接下来证明这个过程的正确性。首先容易发现，如果一个元素是代表元素，那么它一定满足$d=0$。因为初始化的时候满足条件，并且后续的过程中没有对$d$执行变化的操作。

    然后考虑非代表元素，若并查集中有一个元素$x$，其代表元素不是$fa(x)$，说明先前经过了若干步合并，但合并以后没有及时更新偏移量。考虑这样一条由$fa$数组形成的链，即$x-fa(x)-fa(fa(x))-\dots -root$，此时数组中$d_x$表示$x$到$fa(x)$的偏移量，$d_{fa(x)}$表示$fa(x)$到$fa(fa(x))$的偏移量，如此嵌套，那么会发现实际上真正的到代表元素的偏移量$d_x'=d_x+d_{fa(x)}+\dots d_{root}$，也就是这条链上面的$d$的和。所以在`find`的时候路径压缩，直接维护了元素到代表元素的距离，并且由于$d$本身的含义是偏移量，不会影响后续的`find`的结果。

    此时问题转化为维护带有偏移量的并查集，查询集合连通性，查询某个元素的偏移量大小。

  + 例题2：洛谷P2024 [NOI2001] 食物链

    由于环形的捕食关系，可以想到使用模意义下的距离表示捕食关系。那么对于$x$到$y$的距离，若$d(x)-d(y)\equiv 0\ mod \ 3 $，那么说明$xy$是同类，$d(x)-d(y) \equiv 1 \ mod \ 3$，说明$x$吃$y$，同理可以得到$x$被$y$吃的情况。由此可以发现，若$d(x)-d(y) \equiv 1 \ mod \ 3$，那么必然有$d(y)-d(x) \equiv 2 \ mod \ 3$成立，也就是说维护了正向关系的同时，反向的关系也同步被维护了。

    所以在`find`过程中维护距离的时候，需要额外加上一步取模。合并的时候只需要依据$xy$的$d$来计算偏移量的变化，查询只需要检查同一个集合内两个$d$差值的大小是否满足上述关系即可。

    详细来讲，假如说$xy$不在同一个集合内，且新增加的关系是$x$吃$y$，那么把$x$所在的并查集合并入$y$，设两个集合代表元素分别为$rx$与$ry$，那么在合并以后，且没有更新$x$集合内其它元素偏移量的时候，真正的偏移量$d'(x)$应该满足$d(x)+d(rx)-d(y)\equiv 1 \ mod \ 3$，由此解出$d(rx)$应该改变的值。同理$x$与$y$是同类的条件。

+ 允许暴力修改的区间操作

  + 例题1：洛谷P2391 白雪皑皑

    考虑反向求解，相当于每个位置只需要进行一次染色，染色过的位置只需要跳过即可，考虑一个暴力，每个位置记录一个$next$表示当前位置下一个需要被染色的位置，初始化$next$为自己，每一次区间赋值只需要枚举区间内每一个数，检查$next$是否为自己，若是则进行一次染色，然后把$next$赋值为右端点$+1$的地方，否则直接不断跳$next$至$next$为自己，继续如上操作。容易发现这个过程与并查集中$find$的过程一样，所以跳$next$的时候进行一下路径压缩就可以了。容易发现每一次染一个新的位置需要至多一次$find$，那么其复杂度是$O(m+n\alpha(n))$的。

+ 实体化的并查集应用：Kruskal重构树

  Kruskal重构树用于求解在一张图上面经过不超过某个值的边到达的点集，一般只用于强制在线情况。实际上就是一个记录了Kruskal的过程，这棵树越接近根的点代表了越后来加入的边，具有自下而上的单调性，以例题的形式讲解。

  + 例题1：洛谷P4768 [NOI2018] 归程

    考虑按照海拔递降的顺序修建重构树，每个树上结点的子树的叶子代表了一个原图上的连通块，这个连通块内的点可以通过边权不超过某个定值的边集相连，那么在这个基础上记录连通块中点的最短路最小值，在树上不断向上跳即可完成操作。具体而言，每个点初始化一个二元组记录点集最小最短路，以及此连通块内最小的道路海拔。初始点的集合最短路最小值为其最短路值，其海拔为$INF$，然后每一次加入一条边就新开一个点连接两个连通块的重构树的根，并查集维护重构树的根结点位置，倍增维护最上方能够到达的点，因为这个最上方的点的子树代表了从出发点开始经过限制之内的边能够到达的所有点的集合，那么维护这个集合中最小的最短路距离即可。

  + 例题2：洛谷P7834 [ONTAK2010] Peaks 加强版

    按照边权从小到大修建重构树，然后对重构树的DFS序建立主席树，在重构树上倍增找到最上方可达点，子树查询$K$大值即可。

  + 例题3：洛谷P4899 [IOI2018] werewolf 狼人

    考虑直接按照点集修建重构树，一棵权值自下向上递增，一棵递减，那么修建的时候，枚举每一个点以及出边，按照这棵树的单调性单调的连边即可。由于一个子树对应一个原树中的连通块，那么直接从出发点按照限制条件倍增就能找到重构树最上方的点，那么现在问题变成两棵树中是否存在编号相同的点。那么此时对两棵树均求出DFS序，每个点放到二维平面上，横纵坐标为其在两棵重构树中的DFS序，那么此时问题变成矩阵查询，即横纵坐标的范围是两个子树中DFS序的区间，离线扫描线即可。

----

#### 字典树-Trie树

+ 维护字符串

  一个树形结构，从根结点向下到某一个有终止标号的一条路径代表一个字符串。

  下面给出一个可以支持插入的Trie树模板。要求字符串由小写字符组成。其中$end(i)$表示Trie树上结点$i$是否为某个字符串的末尾。

  ```c++
  int ch[maxn][26], cnt;
  bool end[maxn];
  inline void insert(char* str) {
  	int len = std::strlen(str), cur = 0;
  	for (int i = 0; i < len; ++i) {
  		int ver = str[i] - 'a';
  		if (!ch[cur][ver]) ch[cur][ver] = ++cnt;
  		cur = ch[cur][ver];
  	}
  	end[cur] = true;
  }
  ```

  Trie树例题：

  + 例题1：POJ 2001 Shortest Prefixes

    把所有的串插入Trie树，考虑什么情况下某个单词的前缀可以成为其唯一标识符，显然从这个单词在Trie树上面的结尾向上跳，若这个结点子树里面只有一个单词的结尾，就一直是合法的。需要特殊判断某个单词是别的单词的前缀的情况。

  + 例题2：POJ 2945 Find the Clones

    把所有的串插入Trie树，改变终止标号为计数标号，即每插入一个串，末尾的计数标号就加1，然后对于长度开一个桶$bax(i)$记录有多少种本质不同的字符串出现了恰好$i$次即可求解。

  + 例题3：POJ 3630 Phone List

    对所有电话号码建出Trie树，对Trie树进行DFS，若某个点是一个字符串的结尾并且其存在继续向下的路径，那么就是不合法的。

+ 01-Trie

  + 维护集合

    可以充当权值线段树用。若其高度为$h$，则等价于值域为$[0,2^{h-1}-1]$的线段树。不做展开叙述。

  + 位运算贪心

    一般用于求解给定一个集合，多次一个数字$x$，求解$x$与这个集合内的元素异或结果的最大值。以例题的形式讲解。

    + 例题1：洛谷P4551 最长异或路径

      首先由于异或的性质，一棵树上随便找一个点作为根进行一遍dfs，记录这个点到根上边的异或和，那么由异或运算满足交换律结合律，且逆元就是自己，可以知道任何两个结点之间简单路径的异或和就等于两个点到根异或和的异或。由此可以设计一个暴力，即两两配对。这个过程本质就是在找集合内的异或最大值。考虑从01Trie的根向下出发，每条边都代表了当前位填$0$或者$1$，那么根据位运算贪心的性质，若要最大化则尽量要让高位填$1$，那么从高到低枚举查询元素的每一位，在01Trie上看是否存在一条边让这一位异或出来的值为$1$，有就向下走，否则走另一个子结点。在这个过程中记录一下哪些位变成了$1$就可以了。

    + 例题2：洛谷P4735 最大异或和

      在原先01Trie的基础上加上了区间查询，那么只需要按照时间顺序建立可持久化01Trie，由于01Trie的结构与值域为$[0,2^n-1]$的线段树等价，故只需要使用与可持久化线段树一样的手法建立即可。

    + 例题3：洛谷P5283 [十二省联考 2019] 异或粽子

      这题就是“最大异或和”加上“超级钢琴”两道题，只不过最值查找需要放在可持久化01Trie上面。

  + 反向建树的应用

    可以用于实现映射或集合，但不能用于位运算贪心。以例题的形式讲解。

    + 例题1：ByteCamp2021Winter选拔（F）

      考虑如何实现一个集合内元素的加减1以及异或一个数，显然后者直接修建一个01Trie，然后对每个结点打标记，若对应位为1那么就进行左右子树的交换，并且标记具有可合并性。容易发现这个问题不需要求解形如第K大的问题，那么反建01Trie，也就是从根到叶子结点的过程是从低位到高位的。可以发现打标记的过程在这个过程中依然成立，那么考虑如何实现一个集合内数字+1的操作，可以知道若低位为0，那么就会变成1，否则就是推平连续的一段1并把第一个0变成1，可以通过在01Trie里面插入结点、交换子树求出。同理减法的实现。

---

#### 二叉查找树-Binary Search Tree

用于维护有序集合的数据结构。这里只讲解概论部分，其维护复杂度的技巧放在下面讲解。

二叉查找树是一课二叉树，满足对于任一个结点，其左子树内元素大小均小于结点元素，右子树内元素大小均大于结点元素，更进一步的，其中序遍历元素值递增，那么对于往这个集合内部增删元素，一定会导致这棵树形态发生变化，那么只考虑维护树性质的前提下，只需要保证中序遍历的单调性即可。那么可以写出以下这样的初始化以及插入代码。

以下代码按照可重集实现，即同一种数值可以出现多次，并且若有多个相同元素，则将其排布于不同结点上。那么上述单调关系需要改为“小于等于”或者“大于等于”。

````c++
struct Binary_Search_Tree {
private:
	int ls[maxn], rs[maxn], val[maxn], siz[maxn], cnt;
	inline void init() { cnt = 0; }
	inline void pushup(int cur) { siz[cur] = siz[ls[cur]] + siz[rs[cur]] + 1; }
	inline int newnode(int x) { val[++cnt] = x, siz[cnt] = 1; return cnt; }
public:
    int root;
	void insert(int& cur, int x) {
		if (!cur) { cur = newnode(x); return; }
		if (x <= val[cur]) insert(ls[cur], x); else insert(rs[cur], x);
		pushup(cur);
	}
};
````

下面考虑删除操作，容易发现当左右子树均不存在的时候，直接删除这个结点不会有任何问题，当左右子树恰好有一个存在的时候，把那个存在的子树提上去，代替要被删除的结点，容易发现这样做仍然满足单调性。但现在要处理左右子树均存在的情况，下面介绍若干种实现删除的手法。

+ 第一种方式比较朴素，需要对即对于一个要删除的结点，考虑使用左子树内最大的元素（或右子树内最小的元素）代替这个结点，那么变成一个子树内最值查找问题，以查找左子树内最大的元素为例，容易发现只需要从要被删除的结点的左儿子开始，一直向右子树走，直到不能够再走为止，这个结点就是左子树最大元素，且其右子树不存在，那么沿用上面“至多一个子树”的情况删除后，把这个位置的值补到要删除结点上即可。同理可以实现使用右子树最小值进行覆盖的删除操作。

+ 第二种称之为惰性删除，即在这个要删除的结点上标注一个删除标记，然后在后续的维护与查找中不把这个结点计入，在重构维护形态的时候将带有删除标记的结点统一删除，这个方法被应用于替罪羊树的重构维护中。

+ 第三种为旋转删除，在介绍这种方法之前，首先介绍二叉查找树的旋转操作。

  旋转操作的核心是，改变树的形态的同时不改变其中序遍历，下图清晰的展示了对一个结点左旋以及右旋的操作。

  （图）

  旋转有若干种不同的实现，下面介绍两种常用的旋转实现。

  第一种写法被应用于Treap以及AVL树的维护，即直接对某个点进行旋转。
  
  ```c++
  inline void rotatel(int& cur) {
  	int tmp = rs[cur];
  	rs[cur] = ls[tmp], ls[tmp] = cur, pushup(cur), pushup(tmp), cur = tmp;
  }
  inline void rotater(int& cur) {
  	int tmp = ls[cur];
  	ls[cur] = rs[tmp], rs[tmp] = cur, pushup(cur), pushup(tmp), cur = tmp;
  }
  ```

  第二种写法被应用于Splay的维护，即把当前结点转到其父结点的位置，易于自下向上的维护。只需要一个`rotate`函数即可实现，其判断依据为：当前结点是其父结点的左/右儿子。这里左右儿子用一个二维数组记录，便于使用位运算规避讨论。
  
  ```C++
  inline void rotate(int cur) {
  	int x = fa[cur], y = fa[x], z = (cur == ch[x][1]);
  	ch[x][z] = ch[cur][z ^ 1], ch[cur][z ^ 1] = x;
  	fa[x] = cur, fa[cur] = y, fa[ch[x][z]] = x;
  	if (y) ch[y][x == ch[y][1]] = cur;
  	pushup(x), pushup(cur);
  }
  ```

这两种具体的删除方法可以在Treap与Splay相关版块内获知。

由于被删除掉的结点不会再被访问到，不妨将其进行内存垃圾回收，即开一个线性表存储所有被删掉且没有被恢复的结点编号，然后新申请内存空间时首先考虑从这个线性表内取走编号，否则去申请新内存。在结点删除总量很大的时候有利于高效利用内存。

```c++
int pool[maxn], ptr;
inline void newnode(int x) {
	int cur = ptr ? (pool[ptr--]) : (++cnt);
	ls[cur] = rs[cur] = 0, val[cur] = x;
	return cur;
}
inline void remove(int& cur, int x) {
	if (...) pool[++ptr] = cur;
}
```

在这个集合内容易实现查找第$K$大、查找$x$的排名、查找前驱后继等操作，只需要依据左右儿子的单调性，利用每个结点左右子树大小即可维护。由于下面代码的含义是：求解集合内排名为$rank$的元素，以及求解集合内比$x$小的数的个数$+1$，那么前驱后继的求解可以借助这两个函数来实现。

```c++
int query_val(int cur, int rank) {
	int offset = siz[ls[cur]] + 1;
	if (rank <= siz[ls[cur]]) return query_val(ls[cur], rank);
	else if (rank > offset) return query_val(rs[cur], rank - offset);
	else return val[cur];
}
int query_rank(int cur, int x) {
	if (!cur) return 1;
	int offset = siz[ls[cur]] + 1;
	if (x <= val[cur]) return query_rank(ls[cur], x);
	else return query_rank(rs[cur], x) + offset;
}
inline int lower_bound(int x) { return query_val(root, query_rank(root, x) - 1); }
inline int upper_bound(int x) { return query_val(root, query_rank(root, x + 1)); }
```

容易发现单次操作的复杂度上限是这棵树的树高，当插入时数据经过构造，那么这棵树的树高会达到$O(n)$，后续介绍若干种平衡树的实现，其通过若干性质维护其树高，并将总复杂度控制在一个可接受的范围内。

---

#### 树堆-Treap

用于维护集合的数据结构。每个节点含有两个关键字，一个用于维护元素，使得整棵树满足中序遍历单调；另一个用于维护树的形态，使得树随时满足堆的性质。所以说Treap是笛卡尔树的一种。

+ 具体实现手法

  每个二叉树结点记录一个随机出来的优先级，单点插入后只需要进行左旋右旋保证堆性质，删除也需要将要被删除的结点一直旋转到底，并维护堆性质。

+ 复杂度分析

  以下分析以及代码实现均以小根堆作为关键字实现。证明步骤是对《算法导论》课后题的详细阐述。

  首先说明，对于一个有$n$个结点的Treap，若其结点的优先级两两互异，那么这棵Treap形态唯一。显然取出其中序遍历以后，可以找出全局优先级最小的位置，作为树根，然后左右变成一个子问题继续向下修建子树。

  由于关键字随机，那么Treap可以看做是一个随机构建出来的二叉树，接下来证明：**对于一个随机建立的有$n$个结点的二叉树，其期望高度为$O( logn)$**。

  考虑设随机变量$X_i$表示结点数为$i$的树的高度，设左子结点中有$i$个点，那么容易发现$X_i=1+max\{X_i,X_{n-i-1} \}$，再设$Y_i=2^{X_i}$那么套入期望得到：
  $$
  E(Y_i)=2E(max\{Y_i,Y_{n-i-1} \})
  =\frac{2}{n}\sum_{i=0}^{n-1}max\{Y_i,Y_{n-i-1} \} 
  =\frac{2}{n}\sum_{i=0}^{n-1}\int\int f_{Y_i}(x_1) f_{Y_{n-i-1}}(x_2) max\{x1,x2 \}dx_1dx_2 \\
  \le \frac{2}{n}\sum_{i=0}^{n-1}\int\int f_{Y_i}(x_1) f_{Y_{n-i-1}}(x_2) (x_1+x_2)dx_1dx_2 
  =\frac{2}{n}\sum_{i=0}^{n-1}(E(Y_i)+E(Y_{n-i-1}))
  = \frac{4}{n}\sum_{i=0}^{n-1}E(Y_i)
  $$
  接下来说明这个递归式有一个上界满足$E(Y_n)\le \frac{1}{4} C(n+3,3)$。

  第一步先验证边界条件，定义$Y_0=0\le \frac{1}{4} C(3,3) =\frac{1}{4}$且$Y_1=1=\frac{1}{4} C(4,3)$成立。

  然后证明一个等式：$\sum_{i=0}^{n-1}C(i+3,3)=C(n+3,4)$：
  $$
  \sum_{i=0}^{n-1}C(i+3,3)=\frac{1}{6}\sum_{i=0}^{n-1}(i+3)(i+2)(i+1)=
  \frac{1}{6}\sum_{i=0}^{n-1}i^3+6i^2+11i+6\\
  =n+\frac{1}{6}\sum_{i=1}^{n-1}i^3+\sum_{i=1}^{n-1}i^2+\frac{11}{6}\sum_{i=1}^{n-1}i\\
  =n+\frac{(n-1)^2n^2}{24}+\frac{(n-1)n(2n-1)}{6}+\frac{11n(n-1)}{12}\\
  =\frac{24n+n^4-2n^3+n^2+8n^3-12n^2+4n+22n^2-22n}{24}
  =\frac{n^4+6n^3+11n^2+6n}{24}\\
  =\frac{(n+3)(n+2)(n+1)n}{4!}=C(n+3,4)
  $$
  考虑代入上面的表达式，用数学归纳法验证猜想：
  $$
  E(Y_n)\le \frac{4}{n}\sum_{i=0}^{n-1}E(Y_i)\le \frac{4}{n}\sum_{i=0}^{n-1}\frac{1}{4}C(i+3,3)=\frac{C(n+3,4)}{n}=\frac{(n+3)(n+2)(n+1)}{24}=\frac{C(n+3,3)}{4}
  $$
  再由$f(x)=2^x$的凸性，由琴生不等式的积分形式得到$2^{E(x)}\le E(2^x)$，最终代入原式得到：
  $$
  2^{E(X_i)}\le E(2^{X_i}) =E(Y_i) \le \frac{C(i+3,3)}{4}\\
  E(X_n)\le  log_2(\frac{C(n+3)}{4})=O(logn)
  $$
  注：琴生不等式在期望形式下即：若$f(x)$二阶导函数恒正/原函数下凹，那么$f(E(x))\le E(f(x))$。
  
  其实到这里就已经可以说明，Treap的单次操作的期望值均为$O(logn)$的，并且旋转的次数是$O(logn)$的。但最早设计出Treap的时候考虑到了计算机读写速度的差距，一般来讲计算机读入速度比写入速度快，那么对Treap进行操作的时候，就尽量少调用旋转等会使其形态结构发生变化的操作。那么接下来更进一步证明结论：**每一次插入或删除需要进行的旋转次数期望值是单次$O(1)$的**。
  
  首先考虑定义一个二叉树的左右脊柱，左脊柱即：二叉树根结点一直向左子结点走，直到中序遍历第一个结点为止所走出来的路径。同理可以推出右脊柱的概念。
  
  那么以插入为例，插入完一个结点以后显然需要对其进行若干调整，设二叉查找树关键字为$val$，堆关键字为$key$，考虑其最终调整完成以后的位置，容易画图证明，一个结点的调整次数为其左子树的右脊柱长度加上右子树的左脊柱长度。
  
  设随机变量$X_{xy}$表示结点$x$是否在结点$y$的左子树的右脊柱中，那么$X_{xy}=1$当且仅当$x.val<y.val$，$x.key>y.key$，且对于任意一个结点$z$，若$z$满足$x.val<z.val<y.val$那么必然要满足$x.key<z.key$。前两者显然要成立，最后一个条件保证了其必须位于右脊柱上面，若子树$y$的中序遍历中，$x$后面存在一个结点$z$是其在Treap上面的祖先节点，显然$x.key>z.key$，此时$x$一定位于$z$的左子树中不满足右脊柱的定义。
  
  具体而言，考虑Treap修建的过程，取出Treap的中序遍历，假设两组关键字$val$与$key$均互异，固定一个区间修建一个二叉树，固定$y$，那么自左向右第一个找到的合法$x_0$是$y$的左子树根，因为单调性保证其在左子树对应中序遍历区间中$key$最小，然后再向右找，显然下一个找到的$x_1$在$x_0$的右子树内，且这个过程是上一个过程的子问题，$x_1$是$x_0$的右子结点。如此迭代即可逐一求出右脊柱。由这个构造的过程也就说明了上述条件的正确性。
  
  为了便于计算，默认Treap上面的关键字两两不同，并考虑将Treap上面的$val$离散化，其值域为$1\dots n$，那么考虑计算$P\{X_{xy}=1 \}$，那么对于中序遍历顺次出现的$xzy$，满足$y.key<x.key<z.key$，由上述离散化后的结果得到$x.val=x$，$z$的不同可能结点编号有$y-x-1$种，只考虑这些结点，那么所有的$z$连带$xy$的$key$取值有$(y-x-1+2)!=(y-x+1)!$种，但是其中合法的情况只有在$y.key$取最小，$x.key$取次小值的时候才能取到，共$(y-x-1)!$种，那么就有：
  $$
  P\{X_{xy}=1 \}=\frac{(y-x-1)!}{(y-x+1)!}=\frac{1}{(y-x+1)(y-x)}
  $$
  那么容易发现，左子树的右脊柱长度的期望值为：
  $$
  \sum_{i=1}^{y-1}1 P\{X_{iy}=1 \}=\sum_{i=1}^{y-1}\frac{1}{(y-i+1)(y-i)}=1-\frac{1}{y}
  $$
  由对称性可知右子树的左脊柱长度期望值为$1-\frac{1}{n-y+1}$。相加一下，就证明了旋转的次数期望值小于$2$，也就是$O(1)$的。

提供一个不在一个结点内记录多重元素的写法。

```c++
struct Treap {
private:
	int ls[maxn], rs[maxn], key[maxn], val[maxn], siz[maxn], cnt;
	inline void init() { ls[0] = rs[0] = siz[0] = 0, key[0] = INF; }
	inline void pushup(int cur) { siz[cur] = siz[ls[cur]] + siz[rs[cur]] + 1; }
	inline int newnode(int x) {
		int cur = ++cnt;
		val[cur] = x, key[cur] = std::rand(), siz[cur] = 1;
		return cur;
	}
	inline void rotatel(int& cur) {
		int tmp = rs[cur];
		rs[cur] = ls[tmp], ls[tmp] = cur, pushup(cur), pushup(tmp), cur = tmp;
	}
	inline void rotater(int& cur) {
		int tmp = ls[cur];
		ls[cur] = rs[tmp], rs[tmp] = cur, pushup(cur), pushup(tmp), cur = tmp;
	}
public:
    int root;
	void insert(int& cur, int x) {
		if (!cur) { cur = newnode(x); return; }
		if (x <= val[cur]) {
			insert(ls[cur], x), pushup(cur);
			if (key[cur] > key[ls[cur]]) rotater(cur);
		}
		else {
			insert(rs[cur], x), pushup(cur);
			if (key[cur] > key[rs[cur]]) rotatel(cur);
		}
	}
	void remove(int& cur, int x) {
		if (!cur) return;
		if (!(ls[cur] | rs[cur])) { cur = 0; return; }
		if (x < val[cur]) remove(ls[cur], x);
		else if (x > val[cur]) remove(rs[cur], x);
		else {
			if (key[ls[cur]] < key[rs[cur]]) rotater(cur), remove(rs[cur], x);
			else rotatel(cur), remove(ls[cur], x);
		}
		pushup(cur);
	}
	int query_val(int cur, int rank) {
		int offset = siz[ls[cur]] + 1;
		if (rank <= siz[ls[cur]]) return query_val(ls[cur], rank);
		else if (rank > offset) return query_val(rs[cur], rank - offset);
		else return val[cur];
	}
	int query_rank(int cur, int x) {
		if (!cur) return 1;
		int offset = siz[ls[cur]] + 1;
		if (x <= val[cur]) return query_rank(ls[cur], x);
		else return query_rank(rs[cur], x) + offset;
	}
	inline int lower_bound(int x) { return query_val(root, query_rank(root, x) - 1); }
	inline int upper_bound(int x) { return query_val(root, query_rank(root, x + 1)); }
};
```

----

#### 伸展树-Splay

---

#### 替罪羊树-Scapegoat Tree

用暴力重构的手法维护集合的数据结构。

+ 具体实现手法

  每个二叉树结点记录子树的$size$，设定一个阈值$\alpha$，我们认为一个结点不平衡当且仅当$\frac{max(size(ls),size(rs))}{size} > \alpha$，在插入时候若不平衡，则取出中序遍历按照建立二叉树的方式重构子树。一般$\alpha$取值在$0.75-0.85$。

  插入的时候只需要按照一般二叉查找树的插入手法实现即可。删除的时候采用惰性删除，即在要删除的结点上面打标记，在查找的时候只需要查找没有标记的结点即可。在重构的时候顺带回收有标记的结点。

+ 复杂度分析

  对于一棵替罪羊树，设势能函数
  $$
  \phi(T)=c\sum_{cur \in T} |size(cur.ls)-size(cur.rs)|
  $$

  其中$c$是一个与$\alpha$有关的常数，容易证明一棵替罪羊树的高度一定是对数级别的，考虑一次插入一个点会最多给势能提升多少，显然是$c$倍的树的高度，是$O(logn)$的。一棵子树重构以后这个结点以及它所有的子结点的势能函数变成$0$，此时容易发现对于一个被重构的结点，我们用$O(n)$的代价让势能函数至少减少了$(2\alpha-1)cn$，此时只需要调结$c$的大小，使得其能够支配住重构过程的常数即可。容易发现每次不用连续重构自上而下的一段结点，只需要重构最上方的不平衡结点即可，此时重构常数极大减小。

提供一个常数一般的写法。其中`pushup`维护子树里面结点数以及有效结点数，有效结点数指的是结点上面元素出现次数的总和。

```c++
struct scapeGoat_Tree {
private:
	#define alpha 0.75
	int ls[N], rs[N], root;
	int v[N], siz[N], valid[N], num[N], cnt;
	int top1, stk1[N], top2, stk2[N];
	inline void pushup(int cur) {
		siz[cur] = siz[ls[cur]] + siz[rs[cur]] + (num[cur] > 0 ? 1 : 0);
		valid[cur] = valid[ls[cur]] + valid[rs[cur]] + num[cur];
	}
	void dfs(int cur) {
		if (ls[cur]) dfs(ls[cur]);
		if (num[cur]) stk1[++top1] = cur;
		else stk2[++top2] = cur;
		if (rs[cur]) dfs(rs[cur]);
	}
	void build(int L, int R, int& cur) {
		int mid = (L + R) >> 1;
		cur = stk1[mid], ls[cur] = rs[cur] = 0;
		if (L == R) { siz[cur] = 1; valid[cur] = num[cur]; return; }
		if (L < mid) build(L, mid - 1, ls[cur]);
		if (R > mid) build(mid + 1, R, rs[cur]);
		pushup(cur);
	}
	inline void rebuild(int& cur) { dfs(cur), build(1, top1, cur), top1 = 0; }
	inline int newnode(int val) {
		int cur = top2 ? (stk2[top2--]) : (++cnt);
		ls[cur] = 0, rs[cur] = 0; v[cur] = val;
		siz[cur] = 1, num[cur] = 1, valid[cur] = 1;
		return cur;
	}
	inline bool balance(int cur) {
		return (double)std::max(siz[ls[cur]], siz[rs[cur]]) < alpha * (double)siz[cur];
	}
    void insert(int& cur, int val) {
		if (!cur) { cur = newnode(val); return; }
		++valid[cur], ++siz[cur];
		if (v[cur] == val) { ++num[cur]; return; }
		if (val < v[cur]) {
			insert(ls[cur], val);
			if (balance(cur) && (!balance(ls[cur]))) rebuild(ls[cur]);
		}
		if (val > v[cur]) {
			insert(rs[cur], val);
			if (balance(cur) && (!balance(rs[cur]))) rebuild(rs[cur]);
		}
	}
    void remove(int cur, int val) {
		--valid[cur], --siz[cur];
		if (v[cur] == val) { --num[cur]; return; }
		if (val < v[cur]) {
			remove(ls[cur], val);
			if (balance(cur) && (!balance(ls[cur]))) rebuild(ls[cur]);
		}
		if (val > v[cur]) {
			remove(rs[cur], val);
			if (balance(cur) && (!balance(rs[cur]))) rebuild(rs[cur]);
		}
	}
public:
	inline void Insert(int val) {
		insert(root, val);
		if (!balance(root)) rebuild(root);
	}
	inline void Remove(int val) {
		remove(root, val);
		if (!balance(root)) rebuild(root);
	}
	inline int query_rank(int val) {
		int cur = root, res = 1;
		while (cur) {
			if (val < v[cur]) cur = ls[cur];
			else if (val == v[cur]) return res + valid[ls[cur]];
			else res += valid[ls[cur]] + num[cur], cur = rs[cur];
		}
		return res;
	}
	inline int query_value(int rank) {
		int cur = root;
		while (cur) {
			if (rank <= valid[ls[cur]]) cur = ls[cur];
			else {
				if (rank <= valid[ls[cur]] + num[cur]) return v[cur];
				else rank -= valid[ls[cur]] + num[cur], cur = rs[cur];
			}
		}
	}
	inline int lower_bound(int val) { return query_value(query_rank(val) - 1); }
	inline int upper_bound(int val) { return query_value(query_rank(val + 1)); }
};
```

----

#### AVL树-AVL Tree

平衡树的鼻祖。以树的高度以及旋转操作维护树的平衡性。

AVL树满足对于树上的任意一个结点，其左右子树的高度差值的绝对值为$1$。高度的定义为一个结点到其子树内所有叶子节点的距离的最大值。定义叶子结点的高度为$1$。

首先证明一个$n$个结点的AVL树的高度为$O(logn)$的。设$f(n)$表示高度为$n$的AVL树的最小结点数，显然要让整个树尽可能的不平衡，那么左右子树高度差一定为$1$，且对这棵树上的除叶结点以外的点均满足。那么$f(n)=f(n-1)+f(n-2)+1$，设$g(n)=f(n)+1$，那么容易发现$g(n)=g(n-1)+g(n-2)$，其初值满足$g(0)=1$，$g(1)=2$，显然是一个斐波那契数列的形式，其增长速度是指数级别的，那么$f(n)$也是指数增长的。所以说AVL树的高度是对数级别的。

考虑插入删除一个结点后如何调整数据结构使之平衡。

---

#### 红黑树-Red Black Tree

应用于STL底层集合容器实现的数据结构。通过对结点进行染色，以及一些性质维护其树高。

----

#### WBLT-Weight Balanced Leafy Tree

奇怪的数据结构，复杂度不对但是跑得很快，好写，难卡。可以看做是可以旋转的线段树。

----

#### B-Tree & (B+)-Tree

应用于磁盘存储数据用的集合数据结构。通过极多的分叉数快速压低树的高度，以适用于磁盘快速读取的场景。

----

### 维护定长序列的数据结构&算法

----

#### 树状数组-Fenwick Tree

适用于运算存在逆元或有特殊单调性的序列单点修改前缀查询问题。

+ 基本操作

  + 单点加法，区间求和

    以这个作为基本操作讲述树状数组的写法，并说明其复杂度。

    首先定义$lowbit(i)$表示取出$i$二进制意义下最低的非零位，由补码的性质可以知道$lowbit(i)=i\&(-i)$。

    树状数组是一个类后缀和的数组，又称之为二叉索引树，对于一个普通的数组$a[i]$，设其对应的树状数组为$t[i]$，那么$t[i]$保存原数组中区间$[i-lowbit(i)+1,i]$这个区间的元素和。容易画图验证两个树状数组对应原序列的区间要么不相交，要么一个被一个包含。由这个关系可以把区间嵌套抽象成一棵树。故得名树状数组。

    对于前缀查询，假设要求$a[1...x]$的和，从$x$开始，首先给返回值加上$t[x]$，然后$x$再减掉$lowbit(x)$，如此迭代直到$x=0$为止。因为$x$对应区间为$[x-lowbit(x)+1,x]$，所以找到下一个区间需要$x$再减$lowbit(x)$。容易看出每一次迭代都让$x$在二进制意义下的$1$的个数减少$1$，而对于一个长度为$n$的树状数组，$popcnt(x)$的最大值为$log_2n$，故单次查询是$O(logn)$的。

    ```C++
    inline int query(int pos) {
    	int res = 0;
    	while (pos) res += t[pos], pos -= lowbit(pos);
    	return res;
    }
    ```

    对于单点修改，假设给位置$x$的数加上$val$，那么需要找到所有包含$x$的区间维护一下即可。下面不加证明的给出这个做法：首先给$t[x]$加$val$，然后给$x$加上$lowbit(x)$，如此迭代直到$x>n$。

    容易看出，$x$加上$lowbit(x)$的过程就是每一次找到$x$二进制下最下面的一段$1$，将其赋为$0$以后把下一位赋为$1$。其至多进行$log_2x$次操作就会把$x$变成$2$的整数次幂，然后再进行加法就会让$x$翻一倍，至多进行$log_2n$轮操作就会退出，故单点修改的复杂度也是$O(logn)$的。

    ```C++ 
    inline void modify(int pos, int val) {
    	while (pos <= n) t[pos] += val, pos += lowbit(pos);
    }
    ```

  + 区间加法，单点查询

    这类问题的维护套路就是对原序列做差分，查分以后某个元素的实际值就是差分序列的前缀和，区间修改只会涉及到差分序列两个位置的变动，为此只需要用树状数组维护这个差分序列即可。

  + 区间加法，区间查询

    考虑沿用上面差分的思路，设差分以后的序列为$a[i]$，那么求原数列中$[1,x]$的和就可以写成
    $$
    sum(x)=\sum_{i=1}^{x}\sum_{j=1}^{i}a[i]
    =\sum_{i=1}^{x}a[i]\times(x-i+1)
    =x\sum_{i=1}^{x}a[i]-\sum_{i=1}^{x}(i-1)\times a[i]
    $$
    由此可知只需要维护$a[i]$的前缀和以及$(i-1)a[i]$的前缀和就可以进行快速修改与查询了。区间加法和区间求和只需要拆成前缀进行操作即可。

+ 统计应用例题

  + 例题1：洛谷P1972 [SDOI2009] HH的项链

    询问离线，按照右端点为关键字存入链表，对于每个元素记录$pre(i)$表示$i$前面最后一个和$i$颜色相同的位置，没有就设为$0$，考虑一个暴力的实现，从左向右扫描，如果某种颜色是第一次出现则进行记录，否则不会产生贡献。以此维护一个$01$序列，考虑固定右端点，向左扫描时记录所有的第一次出现的位置，若这个位置是第一次出现则赋为$1$，否则为$0$，那么此时右端点为$r$，左端点为$x$的答案就是$x$到$r$的区间求和。考虑右端点向右移动一位以后这个$01$序列会发生哪些变动，显然只有$r+1$这个位置会变成第一次出现，那么上一次出现$r+1$这个位置的颜色就会从第一次出现变成第二次出现，赋成$0$即可，只需要一个单点修改前缀求和的树状数组即可完成操作。

  + 例题2：洛谷P4113 [HEOI2012] 采花

    考虑依然沿用上一题记录$pre$的思路，维护上一次出现相同元素的位置。依然考虑暴力，显然每种颜色遇到第二次的时候才会记录一次，所以只需要维护从右向左的第二次出现某个元素的位置为$1$，其余的为$0$即可。

  + 例题3：洛谷P2184 贪婪大陆

    考虑一种地雷能够被计入答案，其充要条件就是这种地雷的区间与查询区间有交集，正难则反求解所有与查询区间无交集的区间，具体而言，假设查询区间为$[L,R]$，一个区间$[l,r]$与$[L,R]$无交集，要么满足$r<L$，要么满足$l>R$，容易发现这两种情况无交集，那么对所有加入的区间维护两个树状数组，一个维护左端点，一个维护右端点，再记录总共有多少区间被插入，然后排除掉无交集的区间就是最终有交集的区间的个数。

  + 例题4：洛谷P2154 [SDOI2009]虔诚的墓主人

    首先离散化横纵坐标，考虑暴力的枚举每一个空位，显然一个空位的贡献可以由上下左右的树的数量用组合数算出，考虑优化这个过程，直接枚举同一列树的间隙，那么此时上下部分的组合数已经固定，只需要知道每个间隙内位置左右的组合数贡献之和就可以了。那么使用一个满足单点修改，区间查询的树状数组，从左向右扫描每一列，枚举纵向间隙，树状数组查询横向组合数计算贡献，处理完一列就更新横向组合数贡献，显然每个障碍点会恰好更新一次一个位置的贡献，组合数杨辉三角预处理即可。总复杂度$O(nlogn)$。

  + 例题5：洛谷P3616 富金森林公园

    首先只考虑一个石头的时候，显然水面高度不高于石头的时候答案为$1$，其余为$0$。那么可以首先看做是有$n$个独立的石头，然后逐一把相邻的石头合并，最后求解联通块数。显然，当水面高度低于两个相邻的石头的较小高度时，两个就可以合并。

    于是将所有的询问离线，高度离散化，默认$0$位置与$n+1$位置有两个高度为0的石头，设$ans(i)$表示水面高度为$i$时的答案，首先计算每个石头分立的答案，然后两两合并，容易发现这个放在$ans$数组上就是一个区间加单点询问的问题。同理修改，只需要把合并的过程反过来，修改完高度再合并回去。

  + 例题6：P3221 [HNOI2012]双十字

    预处理出每个点向上下左右能扩展出的最大长度，然后枚举某一列，自上而下枚举每一个极长连续段，这时候每个位置左右能延伸到最长的位置已经确定，设为$maxlen$。考虑枚举下方十字中心，然后用一个数据结构维护上侧十字中心的信息，那么某一个下十字位置的贡献就是
    $$
    \sum_{pos} down(now)\times\sum_{i=1}^{maxlen(now)} \sum_{j=1}^{min\{i-1,maxlen(pos) \}} up(pos)
    $$
    考虑把$min$拆开，按照上下两个中心的大小关系进行讨论：

    + $maxlen(pos)\ge maxlen(now)$：拆成
      $$
      down(now)\sum_{pos}up(pos)\sum_{i=1}^{maxlen(now)}\sum_{j=1}^{i-1}1\\
      =down(now)\sum_{pos}\frac{1}{2}maxlen(now)(maxlen(now)-1)up(pos)\\
      =\frac{1}{2}down(now)(maxlen^2(now)-maxlen(now))\sum_{pos}up(pos)
      $$
      
    + $maxlen(pos)< maxlen(now)$：拆成
      $$
      down(now)\sum_{pos}up(pos)(\sum_{i=1}^{maxlen(pos)}\sum_{j=1}^{i-1}1+\sum_{i=maxlen(pos)+1}^{maxlen(now)}maxlen(pos))\\
      =down(now)\sum_{pos}up(pos)(\frac{1}{2}maxlen^2(pos)-\frac{1}{2}maxlen(pos)+(maxlen(now)-maxlen(pos))maxlen(pos))\\
      =down(now)[\sum_{pos}-\frac{1}{2}(maxlen^2(pos)+maxlen(pos))up(pos)
      +maxlen(now)\sum_{pos}maxlen(pos)up(pos)]
      $$
      于是使用树状数组配合扫描线，以$maxlen$作为下标维护$\sum up(pos)$，$\sum maxlen(pos)up(pos)$，$\sum maxlen^2(pos)up(pos)$三者即可。

  + 例题7：洛谷P3760 [TJOI2017]异或和

    套路就是枚举每一位，看这一位是$1$的数最终出现了多少次。考虑当前枚举$2^x$这一位，有多少个区间和满足$2^x$这一位为1，显然高位是没有用的，直接舍弃即可。然后从前缀和的角度出发，枚举每一个右端点，左端点信息由一个数据结构维护。每一轮枚举都对前缀和求模$2^{x+1}-1$后的值，设为$sum(i)$。考虑当前枚举到的前缀和为$sum(i)$：

    + 若$sum(i)$的$2^x$位权为$0$，那么这一位出现$1$的条件是：存在一个在左面的前缀和，满足其大小为$[sum(i)+1,sum(i)+2^x]$。因为首先要减掉$sum(i)+1$，变成形如$11\dots 11$的样子，然后保证最高位为$1$，至多再减掉$2^x-1$。
    + 若$sum(i)$的$2^x$位权为$1$，则在上述基础上还需要加上查询有多少左面的前缀和满足其大小小于等于$sum(i)-2^x$。正确性显然成立。

    容易发现上面这几个过程的本质是单点加区间查询，使用权值树状数组实现即可。

+ 树状数组二分

  用于在一个权值数据结构里求第$K$大。类似于线段树二分，首先从最大的前缀区间开始，设$pos=2^{\lfloor log_2n \rfloor}$，查树状数组$[1,pos]$之内的元素数量和，设为$offset$，如果$K>offset$则令$K$减掉$offset$进入树状数组$[pos+1,n]$部分进行查询，否则保持$K$的值，然后变成查询区间$[1,pos]$部分，容易发现$[1,pos]$也是树状数组，而且注意到$[pos+1,n]$这部分形态和树状数组一样，只不过下标额外多了$pos$，查询的时候给下标加上偏移量即可，如此枚举$2$的若干次方，进行迭代就可以求出第$K$大。注意到任何一个时候$K>0$成立，也就是说最终求出来的时候恰好是第$K$大的前一个数，故返回的位置需要额外加$1$。

  ```C++
  int lg2[maxn], t[maxn];
  inline int query(int rank) {
  	int res = 0;
  	for (int i = lg2[n]; ~i; --i) {
  		if (res + (1 << i) > n) continue;
  		if (t[res + (1 << i)] < rank) rank -= t[res += (1 << i)];
  	}
  	return res + 1;
  }
  int main() {
  	lg2[0] = -1;
  	for (int i = 1; i <= n; ++i) lg2[i] = lg2[i >> 1] + 1;
  	...
  }
  ```

  下面给出一些树状数组二分例题：

  + 例题1：洛谷P3997 [SHOI2013]扇形面积并

    容易发现一个扇形可以用扫描线维护，强制规定$x$轴为起始扫描线，那么一个扇形能够拆成至多两个小扇形。扫描线随着角度旋转，两个扫描线之间的扇形堆叠使用一个树状数组维护，维护所有的扇形半径，那么二分寻找最大的那个半径，满足这个半径内的扇形被覆盖至少$k$次。使用树状数组二分即可实现扫描线的维护以及最大半径查询。

  + 例题2：洛谷P3960 [NOIP2017 提高组] 列队

    容易想到的是，对于每一行的前$m-1$个人使用一个线性数据结构维护，对第$m$列的$n$个人使用同样的方法维护，发现这个数据结构只需要做到：从里面拿走第$K$个数，以及在末尾补入一个数。此时已经能够用动态开点线段树实现。

    考虑每一行补入的元素都是在序列末尾，那么可以把原来这一行的数和后补入的数分开维护，并且由于每一个询问至多伴随着一个补入操作（不考虑最后一列的维护），总的补入是$O(q)$的，且每一行原来就存在的数相互独立，所以可以对每一行分开模拟这个过程。

    具体而言，首先离线所有的询问，把询问按编号存储在对应的行内，枚举每一行，对这一行维护一个最长为$m-1+q$的$01$序列，$0$代表这个数不存在，$1$代表存在。每次拿走第$K$个数代表把第$K$个$1$变成$0$，然后在这个序列尾部增加一个$1$（长度随之增加$1$），可以发现树状数组二分可以很好的维护这个过程。若二分查找出的位置在$[1,m-1]$内，可以直接求出移出的人的编号，否则这个人是后面补入的，记录其补入的顺序，编号的求解在下一步处理。

    做完第一步离线，第二步离线则直接按照顺序枚举所有的操作，以下着重讨论$y<m$的情况。对于每一行都开一个`vector`，记录后续补入的人编号，并专门开一个树状数组维护最后一列，同时存下每个位置的对应编号。此时若在第一步已经求出了编号，就直接拿来使用，否则直接在`vector`内按照顺序$O(1)$找到。这时候在树状数组内二分求出这一行最后一个人的编号，在`vector`内维护当前行的补入情况，并在树状数组上移除它，在末尾加入一个$1$代表归队，并更新编号。

    容易发现这个过程只用到了树状数组，在$n,m,q$同阶的条件下复杂度$O(nlogn)$。

+ DP优化

  一般用于二维偏序的优化。以例题形式讲解。
  
  + 例题1：洛谷P3431 [POI2005]AUT-The Bus
  
    设$f(i)$表示以$i$号车站作为结尾的最长车站序列，显然有$f(i)=f(j)+1$，限制条件为$j.x\le i.x$且$j.y\le i.y$，把所有的点以$x$为第一关键字升序，$y$为第二关键字升序排序，保证每一个位置的前驱转移点都已经被处理完成。用一个维护前缀最大值的树状数组维护已经处理完成的DP状态，转移完成一个点就放入数据结构更新。显然横坐标已经满足单调性了，只需要额外处理纵坐标的情况，此时转移就是在已经处理完的点内，求一个纵坐标小于某个值的位置的DP最大值，这个树状数组可以这样写：
  
    ```c++
    inline void update(int pos, int val) {
    	while (pos <= n) t[pos] = std::max(t[pos], val), pos += lowbit(pos);
    }
    inline int query(int pos) {
    	int res = -INF;
    	while (pos) res = std::max(res, t[pos]), pos -= lowbit(pos);
    	return res;
    }
    ```
    
	  可以看出，这个树状数组维护的是：已经处理好的DP值以$y$为下标的前缀最大值。
	  
	  这个树状数组更新过程的正确性可以这样理解：由于DP过程就是要求前缀最大值，每个位置都存储的是纵坐标固定时的最大的DP值，由于相同的$y$的DP值取较优者，所以区间最大值一定是单调不降的，这个更新的过程就是一个新元素和旧元素取最大值的结果。

----

#### 线段树-Segment Tree

由于绝大多数实现思路都可以用线段树及其变式完成，故把大多数典型题目类型放到这个版块，充分讲解线段树的应用。

+ 基本操作

  + 区间加法，区间求和

    现存若干种常见的线段树写法，主要介绍记录左右子树的写法。这种写法适合推广到动态开点写法。

    信息的记录：

    ```c++
    int root, ls[maxn << 1], rs[maxn << 1], cnt;//根结点编号、左儿子编号。右儿子编号、内存池计数器
    long long sum[maxn << 1], tag[maxn << 1];//区间数值和、区间加法标记
    ```

    建树：

    ```c++
    void build(int L, int R, int& cur) {
    	cur = ++cnt;
    	if (L == R) { read(sum[cur]); return; }
    	int mid = (L + R) >> 1;
    	build(L, mid, ls[cur]), build(mid + 1, R, rs[cur]);
        sum[cur] = sum[ls[cur]] + sum[rs[cur]];
    }
    ```

    对于别的维护区间信息的线段树，更加一般化的写法如下：（左右均为闭区间）

    ```c++
    void build(int L, int R, int& cur) {
    	cur = ++cnt;
    	if (L == R) {
            //初始化叶子结点信息
            return;
        }
    	int mid = (L + R) >> 1;
    	build(L, mid, ls[cur]), build(mid + 1, R, rs[cur]);
        pushup(cur);
    }
    ```

    其中`pushup(cur)`的意义是通过$cur$的左右子树信息合并，得到$cur$对应区间的信息，例如区间加法的`pushup`就可以这样实现：

    ```c++
    inline void pushup(int cur) {
    	sum[cur] = sum[ls[cur]] + sum[rs[cur]];
    }
    ```

    然后考虑区间求和，我们直接在线段树上面dfs，若当前结点代表区间与询问有交集就继续向有交集的子树走，将查询到的信息合并返回；若结点区间被询问区间包含，就直接返回这个区间的信息即可。

    ```c++
    ll query(int L, int R, int l, int r, int cur) {//LR即当前cur对应的区间，lr对应询问区间
    	if ((l <= L) && (r >= R)) return sum[cur];//被包含就直接返回
    	int mid = (L + R) >> 1;
        ll res = 0;
    	if (l <= mid) res += query(L, mid, l, r, ls[cur]);
    	if (r > mid) res += query(mid + 1, R, l, r, rs[cur]);//分割区间
    	return res;
    }
    ```

    在这个基础之上加上区间加法，显然不能把每个叶子节点都暴力加一遍，所以我们要利用标记，维护这个子树对应的区间内每个叶子结点加上了多少，并且实时更新结点对应的和。写出来以后会发现操作和查询是一样的。

    另外，由于加上了修改操作，我们首先需要考虑实时的维护每个我们需要的结点的信息，也就是标记的下推。更具体的，标记最好理解为“在这个子树内每个叶结点都进行了这样一次操作，这个结点的信息已经更新完成”。这样有利于在之后的代码书写中搞清楚。另外一般的标记需要有可合并性，也就是对于一个已经有标记的结点，要能在这个基础之上再额外进行快速修改。

    所以标记下推与区间修改可以如下写：（个人写法问题，只在dfs的时候记录区间左右端点）

    ```c++
    inline void pushdown(int L, int R, int cur) {
    	int mid = (L + R) >> 1;
    	tag[ls[cur]] += tag[cur], tag[rs[cur]] += tag[cur];
    	sum[ls[cur]] += tag[cur] * (mid - L + 1);
    	sum[rs[cur]] += tag[cur] * (R - mid);//维护子结点的标记与区间和
    	tag[cur] = 0;//标记下推完以后，它的历史使命就完成了，清空
    }
    void modify(int L, int R, int l, int r, int cur, long long val) {
    	if ((l <= L) && (r >= R)) {
    		sum[cur] += val * (R - L + 1), tag[cur] += val;
    		return;
    	}
    	if (tag[cur]) pushdown(L, R, cur);//没有标记就不需要下推
    	int mid = (L + R) >> 1;
    	if (l <= mid) update(L, mid, l, r, ls[cur], val);
    	if (r > mid) update(mid + 1, R, l, r, rs[cur], val);
    	pushup(cur);
    }
    ```

    同时，由于标记的存在，在查询的时候需要下推标记更新信息，使得我们查询到的区间信息就是正确的：

    ```c++
    ll query(int L, int R, int l, int r, int cur) {
    	if ((l <= L) && (r >= R)) return sum[cur];
    	if (tag[cur]) pushdown(L, R, cur);
    	int mid = (L + R) >> 1;
        ll res = 0;
    	if (l <= mid) res += query(L, mid, l, r, ls[cur]);
    	if (r > mid) res += query(mid + 1, R, l, r, rs[cur]);
    	return res;
    }
    ```

    这样我们就得到了能够维护区间加法、区间求和的线段树。

    当然了，由于加法的特殊性质，有另一种不需要下推标记的写法，叫做标记可持久化。也就是说每个结点维护这个区间内叶子都加上了多少，区间加法就仍然采取打标记的策略，但查询的时候需要额外记录一个标记和而不将标记下推，返回区间和的时候需要额外加上区间长度乘标记和。这个写法由于适用面较窄，故不做太多讨论。

  + 区间加法，区间乘法，区间求和

    这个相对于上面多加上了一个乘法操作，自然可以多加上一个标记维护乘法。序列中每个元素可以用$a[i]\times mul+add$的形式表示，其中$mul$代表乘法标记，初值为$1$，$add$代表加法标记，初值为$0$。那么考虑给区间内每个数加上一个定值，只需要修改加法标记；给区间内每个数乘上一个定值，需要给加法标记与乘法标记同时乘上这个定值。标记下推的时候优先下推乘法标记然后下推加法标记合并，乘法标记也需要处理左右儿子的乘法标记与加法标记。

    讨论：能不能维护成$(a[i]+add)\times mul$的形式？在这个形式下，假设给一个区间加上$x$，那么考虑加法以后每个数会变成$(a[i]+add+\frac{x}{mul})\times mul$，当在模意义下的时候$x$可能不存在逆元，不能作除法，且若在大质数取模的情况下，复杂度会额外多上快速幂求解逆元的复杂度。故这个做法不通用。

  + 定长01序列的操作例题

    + 例题1：洛谷P2894 [USACO08FEB] Hotel G

      里面涉及了区间最长0段的位置查询，那么在线段树上向下走的时候只需要讨论两个子结点区间的最长0段长度，以及跨区间的情况，选择合法的最靠左的区间即可。

    + 例题2：洛谷P2572 [SCOI2010] 序列操作

      综合考察区间赋值，区间异或1，区间求和，区间最长1段长度。需要记录信息为区间0/1数量，区间前后缀0/1长度，最长0/1长度；标记记录区间覆盖、区间是否被异或过1。打标记以及信息下推的时候需要考虑所有可能。

      ```c++
      struct Node {
      	int l0, r0, l1, r1, max0, max1, sum, len;
      	Node() { l0 = 0, r0 = 0, l1 = 0, r1 = 0, max0 = 0, max1 = 0, sum = 0; }
      } node[maxn];
      inline Node pushup(const Node& x, const Node& y) {
      	Node res;
      	res.len = x.len + y.len;
      	res.l0 = (!x.sum) ? (x.len + y.l0) : x.l0;
      	res.r0 = (!y.sum) ? (y.len + x.r0) : y.r0;
      	res.l1 = (x.sum == x.len) ? (x.len + y.l1) : x.l1;
      	res.r1 = (y.sum == y.len) ? (y.len + x.r1) : y.r1;
      	res.max0 = std::max(x.r0 + y.l0, std::max(x.max0, y.max0));
      	res.max1 = std::max(x.r1 + y.l1, std::max(x.max1, y.max1));
      	res.sum = x.sum + y.sum;
      	return res;
      }
    
    + 例题3：洛谷P3968 [TJOI2014] 电源插排
    
      在这个基础上套上动态开点即可。动态开点手法见下。需要额外注意新结点的信息以及哨兵结点信息的维护。
    
    + 例题4：洛谷P4344 [SHOI2015] 脑洞治疗仪
    
      在前面基本的01序列操作的前提下加上一个二分区间长度区间求和，然后区间覆盖即可。

+ 线段树区间操作的复杂度证明：

  显然单点修改的复杂度是树高级别的，为$O(logn)$。那么主要讨论区间查询与区间修改复杂度。容易发现两者的线段树上递归形式一样，故放在一起统称为操作。

  我们认为一次“进入子树”操作，指的是下一层递归时，结点对应区间不完全包含于操作区间内。那么注意到线段树本身的区间分割形式，可以指出：至多存在一个结点，操作时需要两次“进入”子树操作。另外注意到线段树上面每一个结点以及其对应的子树都是一棵线段树，此时在这个特殊的结点处会把操作区间划分为子线段树上的一个前缀操作与一个后缀操作。以线段树前缀操作为例，若左子结点区间被完全包含，那么直接返回左子树信息，然后递归进入右子树查询，否则只需要进入左子树。显然所有复杂度都是以线段树高度为上界的。那么向下寻找分割位置、分成两半分别求解前后缀，再合并信息的总复杂度就是单次$O(logn)$的。

+ 区间修改区间查询类线段树能够维护的信息特点

  容易看出，这类信息需要能够做到：

  + 对于修改操作，能够用延迟标记实现信息合并与信息下推，也就是说标记具有可覆盖性，可实时更新。比如加法、乘法、赋值、01序列的01相翻转等可以用延迟标记维护信息的。
  + 对于查询操作，本质上是线段树若干个节点的顺次合并，也就是说区间信息具有可合并性。比如说区间和、区间最大值、最大子段和（合并方式见最大子段和板块），由此可以发现存在$O(n)$分治解法的问题也可以迁移到线段树上。
  
+ 数学相关的线段树维护例题

  + 例题1：洛谷P1471 方差

    考虑区间方差的形式，展开得到$D=\frac{1}{n}\sum_{i=1}^{n}(a_i-\bar{a})^2=\frac{1}{n}\sum_{i=1}^{n}a_i^2-\bar{a}^2$。故需要维护区间和与区间平方之和。

    再加上区间加，区间和的变化容易维护，然后考虑区间平方和的变化，容易发现$\sum_{i=1}^{n}(a_i+x)^2=\sum_{i=1}^{n}a_i^2+2x\sum_{i=1}^{n}a_i+nx^2$，那么只需要维护区间平方之和、区间和和延迟标记，更新时优先更新区间平方和然后更新区间和。
  + 例题2：洛谷P6327 区间加区间sin和

    容易发现$sin(a+x)=sina\ cosx+sinx\ cosa$，$cos(a+x)=cosa\ cosx-sina\ sinx$，那么维护区间$sin$和与区间$cos$和就可以同步维护。
  + 例题3：洛谷P2221 [HAOI2012]高速公路

    考虑每一条边的贡献，可得答案为$\sum_{i=L}^{R-1}(i-L+1)(R-i)v_i$，拆开得到$\sum_{i=L}^{R-1}(R-LR)v_i+\sum_{i=L}^{R-1}(R+L-1)iv_i-\sum_{i=L}^{R-1}i^2v_i$，于是维护零次项、一次项与二次项的变化即可。具体的，区间加的时候，除开裸的区间加法以外，还需要计算$\sum_{i=L}^Ri$、$\sum_{i=L}^Ri^2$，有公式$\sum_{i=1}^{n}i=\frac{n(n+1)}{2}$，$\sum_{i=1}^{n}i^2=\frac{n(n+1)(2n+1)}{6}$，前缀和相减即可得到区间和。
  + 例题4：洛谷P3707 [SDOI2017]相关分析

    首先是考虑相关系数的求解，可以得到$b=\frac{\sum xy-n\bar{x}\bar{y}}{\sum x^2-n\bar{x}^2}$，那么在此基础上维护每个区间的$\sum xy$、$\sum x^2$、$\sum x$、$\sum y$四个信息。容易发现可以维护是否赋值的标记，赋值过后再进行加法可以等价转化为赋值标记，下推时优先考虑是否存在赋值标记。分别考虑两种操作对区间的影响：（以下设$LR$为闭区间左右端点）

    + 区间加法：

      + $\sum (x+S)(y+T)=\sum xy +S\sum y+T\sum x+(R-L+1)ST$
      + $\sum (x+S)^2=\sum x^2 +2S\sum x+(R-L+1)S^2$
      + $\sum x$与$\sum y$容易维护。

    + 区间赋值：

      + $\sum xy =\sum_{i=L}^{R} (i+S)(i+T)=\sum_{i=L}^{R}i^2+(S+T)\sum_{i=L}^{R}i+(R-L+1)ST$
      + $\sum x^2=\sum_{i=L}^{R}(i+S)^2=\sum_{i=L}^{R}i^2+2S\sum i+(R-L+1)S^2$
      + $\sum x=\sum_{i=L}^{R}(i+S)=\sum_{i=L}^{R}i+(R-L+1)S$，同理$\sum y$的维护。

      容易发现区间赋值需要维护$\sum i$与$\sum i^2$，显然有公式$\sum_{i=1}^{n}i=\frac{n(n+1)}{2}$，$\sum_{i=1}^{n}i^2=\frac{n(n+1)(2n+1)}{6}$，套用即可。
    
  + 例题5：洛谷P6144 [USACO20FEB]Help Yourself P

    考虑将$k$次幂的形式转化为第二类斯特林数表达，那么$\sum num^k=\sum_{i=0}^k S(k,i)i!\sum C_{num}^i$。

    接下来考虑如何维护线段交集个数，把所有的线段按左端点升序排序，然后按照右端点维护，设$f(i,j)$表示最右边一条线段的右端点在$i$，所有方案的$C_{num}^j$之和，接下来枚举每一条线段加入已经维护好的线段集合，考虑先前加入的线段与当前线段的关系，不妨设当前线段表示的区间范围是$[L,R]$，前面第$i$条线段的区间为$[l_i,r_i]$：

    + 对于$r_i<L$的线段，说明两条线段没有交集，将当前线段加入集合后会使连通块数增加$1$，由于$C_n^m=C_{n-1}^{m}+C_{n-1}^{m-1}$，$n-1$恰好对应前面线段$i$的所有信息，利用$f$的前缀信息累加更新。
    + 对于$L\le r_i \le R$，说明两条线段有交集，但不是包含关系，将当前线段加入集合以后连通块数不变，由于维护的是每一种方案的组合数，所以可以直接利用$f$的前缀累加。
    + 对于$r_i>R$，说明当前线段被$i$线段所包含，那么需要更新$f(r_i,j)$的所有信息。由于加入了当前线段以后连通块数不变，选或不选当前线段的方案一样，也就是相当于方案数翻了一倍，所有的$f(r_i,j)$都要翻一倍。

    对于一个新加入的线段，由于选它只有$1$个连通块，所以初始化是$C_1^0=C_1^1=1$，做完后需要把当前线段的答案插入，用一个支持单点加法，区间乘法，区间求和的线段树实现。复杂度$O(nklogn)$。

    若直接使用线段树直接维护$\sum (num+1)^k$，则需要预处理组合数，并且滚动更新$0-k$次幂的答案，复杂度$O(nk^2logn)$。

+ 动态开点

  这个写法可以在线段树有用信息稀疏的情况下节省空间，同时为后面的线段树合并做铺垫。很多时候可以替代平衡树进行集合操作。如果对于线段树记录左右儿子的写法比较熟练，那么对动态开点应该会感到很亲切。具体而言，在线段树上DFS的时候，若一个结点不存在，则动态的申请出它的空间。

  ```C++
  void insert(int& cur, int pos, int L, int R) {
  	if (!cur) cur = newnode();
  	if (L == R) return;
  	int mid = (L + R) >> 1;
  	if (pos <= mid) insert(ls[cur], val, L, mid);
  	else insert(rs[cur], val, mid + 1, R);
  	pushup(cur);
  }
  ```

  假如总区间长度为$V$，那么其占用空间上界是$O(V)$的，但实际操作中只需要$O(mlogV)$的空间即可。

  很多时候动态开点可以处理平衡树题目或者是需要离散化的区间操作问题。实际上例题往往不很典型。

  + 例题1：第21次CCF计算机软件能力认证T5星际旅行

    在动态开点的基础上加上了三个区间加法一个区间乘法一个轮换，加法乘法混合就是简单的基础操作，轮换的时候需要轮换值与其对应的加法标记，标记下放的顺序应该是先轮换标记再乘法标记再加法标记。

+ 可持久化（主席树）

  考虑对某个序列进行单点修改，单点修改对线段树能够发生变化的结点只有叶子到根这一连串$O(logn)$个点，那么只需要额外记录这些发生变动的信息即可做到快速查询某个历史版本。其余没有变动的结点只需要把儿子指针指过去即可。空间复杂度$O(nlogn)$。

  下面以权值线段树的可持久化为例给出代码。

  ```c++
  void insert(int L, int R, int pos, int& cur, int pre) {
  	num[cur = ++cnt] = num[pre] + 1;
  	if (L == R) return;
  	int mid = (L + R) >> 1;
  	if (pos <= mid) rs[cur] = rs[pre], insert(L, mid, pos, ls[cur], ls[pre]);
  	else ls[cur] = ls[pre], insert(mid + 1, R, pos, rs[cur], rs[pre]);
  	pushup(cur);
  }
  ```

  下面给出一些可持久化线段树的例题。

  + 例题1：洛谷P3834 【模板】可持久化线段树 2

    以所有的下标为版本，离散化后的权值为位置建立权值线段树，初始版本为空树；考虑获取一个区间的权值线段树，即可完成查询区间第$K$大的操作。注意到$offset$的本质是查询左子树中元素数目，而这个可以做前缀减法实现查询，即若查询区间$[l,r]$的第$K$大，那么从版本$L-1$与版本$R$两个位置的根结点向下走，每一次查询左子树元素数目相减作为$offset$，走到叶子结点的时候答案就确定了。

  + 例题2：洛谷P3567 [POI2014]KUR-Couriers

    考虑暴力枚举所有可能被推平的一段，这时候问题可以转化成“给定一些数，求一个$x$使得所有数与$x$的差的绝对值的和最小”，显然选择中位数。那么只需要维护这固定的$K$长度的中位数即可。一遍处理下来使用可持久化权值线段树实现查询。若拆成扫描线的形式可以用树状数组二分实现，有更优的常数以及空间复杂度。

  + 例题3：洛谷P3302 [SDOI2013]森林

    树上路径第$K$大可以使用主席树，（洛谷P2633 Count on a tree）那么这个结点的版本以其树上父节点作为历史版本建立，每个点对应的线段树都是维护了这个点到根结点路径上的值集合，利用树上差分的套路拆成$x$，$y$处加法，$LCA(x,y)$，$fa[lca(x,y)]$处减法就可以获得$offset$的值。树上合并只需要按秩合并重构主席树，LCA的维护只需要倍增。

  + 例题4：洛谷P3248 [HNOI2016]树

    考虑把每一次加入原树的一个子树看做是一个连通块，容易发现连通块之间也能形成有向树，对于每个连通块需要维护：根结点对应于原树中的结点下标、这个连通块的下标范围、连通块的根指向父向连通块内的结点对应于原树中的结点、连通块形成树的深度。在修建这棵树的时候，通过二分定位挂载结点所在的连通块，用主席树配合DFS序求解对应于原树中的编号。然后在这个基础上实现一个连通块间的倍增，设$fa(i,j)$表示连通块$i$向上跳$2^j$步走到的连通块编号，并设$len(i,j)$表示从连通块$i$的根到连通块$fa(i,j)$的根中间的距离。

    考虑如何求解答案，设两个端点分别为$xy$：

    + 若两个点所在的连通块相同，那么直接把这两个点映射回原树，用LCA与深度实现查询。
  + 若两个点所在的连通块满足一个是另一个的祖先，那么从深度较大的那个开始（假设是$x$），首先把$x$跳到$x$所在连通块的根，然后倍增跳到$y$所在连通块下方，此时需要知道$x$所在连通块的根指向父向树的点对应于原树中的编号，然后用“两个点所在连通块相同”的策略处理最后一步的答案。
    + 否则需要将$x$与$y$同时倍增，类似于倍增LCA，需要首先调整$xy$到其所在连通块的根，然后把连通块较深的点先调整到和另一个同样深度，然后一起倍增累加距离，最后仍然沿用连通块相同的方案求最后的答案。

  + 例题5：洛谷P3293 [SCOI2016]美味

    考虑从高到低按位贪心，若答案中高位已经确定为$x$，当前要确定$2^i$这一位是否可以为$1$，那么考虑是否存在$a_i$使得$b\ xor \ (a_i+x) \in [res+2^i,res+2^{i+1}-1]$，由于低位中$0$到$2^i-1$均出现了一次，低位再异或上$b$以后会变成$0$到$2^i-1$的一个排列，其低位值域没有发生变化，那么上述等式转化为$(a_i+x)$的$i+1$位及以上和$(res+2^i)xor \ b$一样，低位任意填，变成了区间查询是否存在一个值，其在某个值域区间内，主席树实现即可。

+ 线段树合并

  用于合并两个线段树的所有信息。需要以动态开点为前提。

  线段树合并的时候需要同时从两棵树的根向下走，当至少一个结点不存在的时候就直接把另一棵树的结点接过来使用。走到叶子结点时特殊处理信息。一般来讲若把树$x$合并到树$y$上，那么访问树$x$时不会被与$y$上的信息所影响。其返回值为合并完的新树的根。

  ```c++
  int merge(int x, int y, int L, int R) {
      if ((!x) || (!y)) return x | y;
      if (L == R) {
          //do something
          return y;
      }
      int mid = (L + R) >> 1;
      ls[y] = merge(ls[x], ls[y], L, mid);
      rs[y] = merge(rs[x], rs[y], mid + 1, R);
      pushup(y);
      return y;
  }
  ```

  需要注意的是线段树合并的复杂度正比于两棵线段树重合部分的大小，故没有启发式合并这种说法。

  例题选取了若干经典同时也较为容易实现的题目。

  + 例题1：洛谷P3224 [HNOI2012]永无乡

    权值线段树合并即可。集合第$K$大只需要线段树二分。

  + 例题2：洛谷P3521 [POI2011]ROT-Tree Rotations

    显然两个子树换位不会对两个子树内部的逆序对产生影响，只会影响前后的逆序对数贡献。那么每个子树都采用一个维护集合的数据结构维护，那么在集合合并的时候考虑孰前孰后分别产生的逆序对数，取较小者即为贡献。考虑如何用线段树合并维护前后产生的逆序对数贡献，显然在权值数据结构的加持下，一棵树的左儿子会对另一棵树的右儿子产生贡献，同一侧儿子对儿子的贡献只需要递归下去在合并儿子结点时求解。

  + 例题3：洛谷P4556 [Vani有约会]雨天的尾巴

    考虑树上差分，将路径加法变化为$x$，$y$处加法，$LCA(x,y)$，$fa[lca(x,y)]$处减法，线段树维护所有的元素出现次数以及最大值，自下向上线段树合并，合并完一个结点的所有子树信息就更新这个结点的答案。

+ 区间历史最值

  + 例题1：洛谷P4314 CPU监控

    考虑如何维护一个区间内带修改的区间历史最值，由于标记分为加法和赋值，所以分开打标记，初始时为加法标记加$0$，每个结点额外记录状态表示当前生效的是哪个标记。

    然后考虑对一个线段树结点反复做加法的情况下，会使区间历史最值如何变化，以及如何记录区间信息对子结点的影响。容易看出是在加法标记最大的时候可能对子结点区间的信息产生影响，那么需要记录加法标记，以及加法标记出现过的的最大值。考虑带上赋值操作，显然赋值过后加法标记不再起作用，但由于查询的是历史最值，最大赋值与最大加法标记都会起作用。赋值过后再赋值只需要标记覆盖，同理加法操作需要记录最大的赋值标记是多少；赋值后的加法可以转化成区间赋值，套用赋值的信息变动方式处理。

    下推标记的时候，首先下推加法标记，更新加法操作过后的最大值，然后再检查是否存在赋值标记进行下推，标记下推完成以后注意清空加法相关的标记，将生效标记转换为加法。

    提供一个代码。这种方式实现比较长且常数大，但分开了赋值与加法的下推易于理解。

    ```C++
    int root, ls[maxn], rs[maxn], cnt;
    ll mx[maxn], hmx[maxn], add[maxn], equ[maxn], mxadd[maxn], mxequ[maxn];
    bool tag[maxn];
    inline void modify1(int cur, ll val) {
    	mx[cur] += val;
    	hmx[cur] = std::max(hmx[cur], mx[cur]);
    	if (tag[cur]) equ[cur] += val, mxequ[cur] = std::max(mxequ[cur], equ[cur]);
    	else add[cur] += val, mxadd[cur] = std::max(mxadd[cur], add[cur]);
    }//加法标记下推
    inline void modify2(int cur, ll val) {
    	mx[cur] = val;
    	hmx[cur] = std::max(hmx[cur], val);
    	if (!tag[cur]) add[cur] = 0, equ[cur] = val, mxequ[cur] = val, tag[cur] = true;
    	else equ[cur] = val, mxequ[cur] = std::max(mxequ[cur], equ[cur]);
    }//赋值标记下推
    inline void pushup(int cur) {
    	mx[cur] = std::max(mx[ls[cur]], mx[rs[cur]]);
    	hmx[cur] = std::max(hmx[cur], std::max(hmx[ls[cur]], hmx[rs[cur]]));
    }
    inline void pushdown(int cur) {
    	if (tag[cur]) {
    		modify1(ls[cur], mxadd[cur]), modify2(ls[cur], mxequ[cur]), modify2(ls[cur], equ[cur]);
    		modify1(rs[cur], mxadd[cur]), modify2(rs[cur], mxequ[cur]), modify2(rs[cur], equ[cur]);
    		add[cur] = 0, mxadd[cur] = 0, tag[cur] = false;
    	}
    	else {
    		modify1(ls[cur], mxadd[cur]), modify1(ls[cur], add[cur] - mxadd[cur]);
    		modify1(rs[cur], mxadd[cur]), modify1(rs[cur], add[cur] - mxadd[cur]);
    		add[cur] = 0, mxadd[cur] = 0;
    	}
    }
    void build(int L, int R, int& cur) {
    	hmx[cur = ++cnt] = -INF;
    	if (L == R) { read(mx[cur]), hmx[cur] = mx[cur]; return; }
    	int mid = (L + R) >> 1;
    	build(L, mid, ls[cur]), build(mid + 1, R, rs[cur]), pushup(cur);
    }
    void modify1(int L, int R, int l, int r, int cur, ll val) {
    	if ((l <= L) && (r >= R)) { modify1(cur, val); return; }
    	int mid = (L + R) >> 1; pushdown(cur);
    	if (l <= mid) modify1(L, mid, l, r, ls[cur], val);
    	if (r > mid) modify1(mid + 1, R, l, r, rs[cur], val);
    	pushup(cur);
    }//区间加法
    void modify2(int L, int R, int l, int r, int cur, ll val) {
    	if ((l <= L) && (r >= R)) { modify2(cur, val); return; }
    	int mid = (L + R) >> 1; pushdown(cur);
    	if (l <= mid) modify2(L, mid, l, r, ls[cur], val);
    	if (r > mid) modify2(mid + 1, R, l, r, rs[cur], val);
    	pushup(cur);
    }//区间赋值
    ll query1(int L, int R, int l, int r, int cur) {
    	if ((l <= L) && (r >= R)) return mx[cur];
    	int mid = (L + R) >> 1; ll res = -INF; pushdown(cur);
    	if (l <= mid) res = std::max(res, query1(L, mid, l, r, ls[cur]));
    	if (r > mid) res = std::max(res, query1(mid + 1, R, l, r, rs[cur]));
    	return res;
    }//区间最大值
    ll query2(int L, int R, int l, int r, int cur) {
    	if ((l <= L) && (r >= R)) return hmx[cur];
    	int mid = (L + R) >> 1; ll res = -INF; pushdown(cur);
    	if (l <= mid) res = std::max(res, query2(L, mid, l, r, ls[cur]));
    	if (r > mid) res = std::max(res, query2(mid + 1, R, l, r, rs[cur]));
    	return res;
    }//区间历史最大值
    ```

  + 例题2：SPOJ1557 GSS2 - Can you answer these queries II

    在最大子段和的问题上加上了只算一次的条件，考虑将询问按照右端点离线，暴力一点，从左向右枚举右端点向左扫描，在左边所有的点处更新以这个点作为子区间左端点的最大值，也就是说处理到$r$的时候，对于所有左端点$l \le r$，设$a[l]$表示区间$[l,l]$，$[l,l+1]\dots [l,r]$只出现一次元素的区间和的最大值，再设$b[l]$表示区间$[l,r]$的只出现一次元素的区间和的最大值，那么容易看出$a[i]$就是$b[i]$的历史最大值。处理完一个右端点就处理所有在这个位置的询问，显然是求解数组$a$的区间最大值。考虑在右端点向右移动一位的时候如何更新所有左端点的信息，对于数组$b$，首先所有左边位置都先加上新右端点的权，然后上一次出现新右端点元素的位置向左出现重复，就减去这个权，本质就是实现一个区间加法，然后再维护数组$a$，查询只需查询区间历史最大值，那么此时只需套用为区间加区间历史最大值的模板即可。

+ 区间历史和

  即用于维护以下形式：维护序列$A_i$以及$B_i$，使得对每次$A_i$变动以后，$B_i=A_i+B_i$，即一个所有历史版本的求和。

  首先考虑一个最朴素的问题，在上面的前提下，对$A$做区间加法，对$B$求历史和。

  这里采用的讲解是设一个所谓的操作队列，即对于一个结点，施加在上面的操作用一个连续的队列来实现，操作有两种，一个是对这个结点的对应区间做加法，另一个是更新历史和。那么我们需要维护的标记信息不仅有加法标记，还增加了加法标记历史和、施加的加法标记次数。

  下面是一些例题：

  + 例题1：洛谷P8868 [NOIP2022] 比赛
  + 例题2：洛谷P5009 [yLOI2018] 不老梦

+ 区间最大子段和

  + 单点修改区间最大子段和

    使用朴素的线段树，每个结点记录这个结点代表的区间的和、以区间左/右端点作为开头/结尾的最大前/后缀和，叶子结点这四个值就对应序列上的值；向上合并的时候区间和最易于维护，考虑左端点为开头的最大前缀和，要么跨越中间要么不跨越中间，前者对应左子区间的左端点为开头的最大前缀和，后者显然左区间已经全部被选上，对应左子区间的和加上右子区间的左端点为开头的最大前缀和；同理右端点为结尾的最大后缀和；区间最大子段和依然考虑能否跨区间，不跨区间就对应左右子区间的最大子段和，否则对应左子区间的右端点为结尾的最大后缀和，加上右子区间的左端点为开头的最大前缀和，如此维护。

    ```c++
    inline void pushup(int cur) {
        lmax[cur] = std::max(lmax[ls[cur]], sum[ls[cur]] + lmax[rs[cur]]);
        rmax[cur] = std::max(rmax[rs[cur]], sum[rs[cur]] + rmax[ls[cur]]);
        maxv[cur] = std::max(lmax[rs[cur]] + rmax[ls[cur]], std::max(maxv[ls[cur]], maxv[rs[cur]]));
        sum[cur] = sum[ls[cur]] + sum[rs[cur]];
    }
    ```

    + 例题1：SPOJ1043 GSS1 - Can you answer these queries I
    + 例题2：SPOJ1716 GSS3 - Can you answer these queries III

  + 区间最大子段和的变式

    + 例题1：洛谷P3488 [POI2009] LYZ-Ice Skates

      

    + 例题2：洛谷P2839 [国家集训队] middle

      考虑离散化以后二分答案，将$[a,d]$这一段区间内大于等于$mid$的权设为$1$，否则设为$-1$，如果$mid$能够成为某个子序列的中位数，那么这一段的数字和一定等于$0$或$1$，那么考虑当$mid$越来越大的时候，最大的权值和一定越来越小以致于小于$0$，在二分一个值的时候，按照上述说法处理这一段序列，求出左端点在$[a,b]$，右端点在$[c,d]$的最大子段和，若大于等于$0$则上调二分下界，这个正负$1$的序列可以通过权值递降的顺序建可持久化线段树求得。

    + 例题3：洛谷P3582 [POI2015] KIN

      考虑固定一个右端点向左暴力，第一次看的就加上其权值，第二次碰到就抵消加上负的权值，再碰到就是$0$，利用“区间不同种类颜色数”中记录$pre$的思想，就可以转化为一个单点修改、前缀的后缀最大值的问题。

    + 例题4：SPOJ2916 GSS5 - Can you answer these queries V

      注意到给定的区间可能重合也可能不重合，那么大力讨论一下所有的情况，不重合的情况比较简单，只需要左右分开求前缀后缀最大值，加上中间的和即可。考虑左右区间有交集的情况，分为两端点均在交集部分、有至少一个端点不在交集部分两种情况，前者就是最大子段和模板，后者用不重合的情况处理交集两侧的前后缀最大值的和即可。

    + 例题5：SPOJ6779 GSS7 - Can you answer these queries VII

      序列问题上树就用树剖，区间赋值就考虑每个结点打标记，讨论赋值的正负对区间最大子段和、前后缀最值的影响，同理标记下推的过程。

+ 允许暴力修改的线段树

  这类题目的特点是区间修改区间求和，每个元素至多被暴力处理一个比较小的数字次。那么可以暴力的在线段树上DFS，对每个叶子结点都进行一次操作，其唯一需要的剪枝就是在进入某个区间的时候检查这个区间内所有的元素是否已经不需要再修改。

  + 例题1：洛谷P4145 上帝造题的七分钟 2

    每个元素开平方根下取整，在整型范围内至多只需要开$5$次根就会变成$1$或者$0$，后续不再变化。那么只需要维护区间最大值，若区间最大值大于$1$则暴力修改下去即可。

  + 例题2：CF438D The Child and Sequence

    对于一个数，考虑一次取模会带来哪些影响，设原数为$x$，模数为$p$，容易发现当$x<p$时不会发生任何变化，当$\lceil \frac{x}{2} \rceil \le p \le x$的时候$ x \ mod \ p=x-p \le \lceil \frac{x}{2} \rceil$，$1\le p< \lceil \frac{x}{2} \rceil$的时候$x\ mod \ p <p<\lceil \frac{x}{2} \rceil$。所以若一次取模使得某个数字发生变化，那么必定会使这个数字减少一半，那么在后两种情况下至多取模对数级别次就会把$x$变成$0$，允许暴力操作。那么只需要维护区间最大值，递归时最大值小于模数的时候就不再递归下去，否则暴力递归下去修改。

  + 例题3：CF920F SUM and REPLACE

    容易发现，对于一个数的约数个数$d(x)$，其大小不会超过$2\sqrt{x}$，由除法分块的性质可以比较容易的推出。那么每一次操作相当于给区间里的数至少下降开一次根号量级，至多乘上$2$，当$x$变成$1$或者$2$的时候就不再操作，于是记录区间最大值，最大值大于$2$的情况下暴力修改下去，约数个数可以使用枚举倍数的手法$O(VlnV)$的时间内预处理出。

  + 例题4：洛谷P3747 [六省联考 2017] 相逢是问候

    由扩展欧拉定理知，幂次取模可以转化成指数取模，指数嵌套的情况下可以继续用扩展欧拉定理转化，对一个数不断算其欧拉函数，至多对数级别次会变成$1$。这是因为若$x$是偶数，与其互质的数字一定不会是偶数，$\phi(x)\le \frac{x}{2}$，若$x$是奇数，那么由其计算公式知$\phi(x)$必然为偶数，故上述命题成立。暴力修改计算即可。注意到可能的指数与模数取值较少，那么采用光速幂预处理快速求解即可。

+ 李超线段树

  用于维护二维平面上的若干线段，支持插入一条线段然后求在某一个给定的横坐标处最高的线段位置。

  线段树上每个结点存一个线段编号，称为其优势线段，其特点是：在所有包含这个区间的线段内，相比于其他线段，在这个区间内这条优势线段都有超过一半在上侧。插入时，首先按照线段树的套路，把线段放到其对应的线段树结点上面，然后考虑这些结点优势线段的变化：

  + 若在整个区间内新线段都在优势线段下方则退出。
  + 若在整个区间内新线段都在优势线段上方则直接修改退出。
  + 若两线段在这个区间里有交集，则取出这个区间的中点，若新线段中点更高，那么说明优势线段被新线段替换，然后取出老线段端点比新线段高的一侧，将其下放到对应一侧子结点区间里；否则将新线段下放。

  ```c++
  double k[maxn], b[maxn];
  inline double f(int Id, int x) { return k[Id] * (double)x + b[Id]; }
  void update(int L, int R, int l, int r, int cur, int Id) {
  	if ((l <= L) && (r >= R)) {
  		if (!id[cur]) { id[cur] = Id; return; }
  		bool left = f(id[cur], L) <= f(Id, L), right = f(id[cur], R) <= f(Id, R);
  		if (left && right) { id[cur] = Id; return; }
  		else if ((!left) && (!right)) return;
  		else {
  			int mid = (L + R) >> 1;
  			if (f(id[cur], mid) < f(Id, mid)) {
  				if (left) update(L, mid, l, r rs[cur], id[cur]);
  				else update(mid + 1, R, l, r, ls[cur], id[cur]);
  				id[cur] = Id;
  			}
  			else {
  				if (left) update(L, mid, l, r, ls[cur], Id);
  				else update(mid + 1, R, l, r, rs[cur], Id);
  			}
  		}
  		return;
  	}
  	int mid = (L + R) >> 1;
  	if (L <= mid) update(L, mid, l, r, ls[cur], Id);
  	if (R >= mid) update(mid + 1, R, l, r, rs[cur], Id);
  }
  ```

  查询时只需要自上而下查询所有包含询问横坐标的区间，在所有结点处都算一下优势线段那一点的纵坐标，取最大值即可。

  容易发现查询是$O(logn)$的，插入时由于首先按照普通线段树分割成了$O(logn)$个区间，然后在这些区间上每一次至多走一侧至多走到一个叶子结点，由于线段树高度是$O(logn)$的，那么插入的总复杂度就是$O(log^2n)$的。

  下面给出一些例题。

  + 例题1：洛谷P4097 [HEOI2013]Segment

    裸题，只需要额外注意一下左右端点连成的线段垂直于$y$轴的情况。

  + 例题2：洛谷P4254 [JSOI2008]Blue Mary开公司

    比上面那道题还要裸。

  + 例题3：洛谷P4069 [SDOI2016]游戏

    套入一个树剖即可。

+ 线段树维护单调栈

  + 例题1：洛谷P4198 楼房重建

    考虑线段树每个结点维护其对应区间形成的单调栈的长度，显然叶子结点的答案为$1$，考虑自下向上维护的过程，定义函数`pushup(cur,k)`表示计算将$cur$这个结点对应的区间建成一个首元素大于$k$的单调栈，栈内元素的数量是多少。线段树维护一个区间最大值，考虑如何实现区间信息的维护，设结点$cur$的子树修成单调栈的答案为$len(cur)$，那么显然对于一个结点$cur$，其对应区间的单调栈长度等于$len(ls)+pushup(rs,ls.maxh)$。

    我们着重考虑如何实现这个单调栈，显然当$K$要求大于一个区间内的所有值的时候长度就是$0$，剪枝优化掉这个情况后，利用分治的思想，从下向上考虑：

    + 当前结点为叶子结点，只需要判断元素值是否大于$K$即可。
    + 当前结点为非叶子结点，首先检查左子结点中的最大值，若最大值小于等于$K$，则直接递归右子结点；否则左子树中尾部信息保留，当前区间构成的单调栈中来自于右子树的部分可以完全保留。

    ```c++
    int pushup(int L, int R, int cur, double k) {
        if (k >= maxh[cur]) return 0;
    	if (l == r) return (maxh[cur] > k) ? 1 : 0;
    	int mid = (L + R) >> 1;
    	if (maxh[ls[cur]] <= k) return pushup(mid + 1, R, rs[cur], k);
    	else return pushup(L, mid, ls[cur], k) + len[cur] - len[ls[cur]];
    }
    ```

    由于自下而上的过程中，叶子结点的信息正确，在子结点的信息都是正确的情况下可以求出当前结点的正确答案。

  + 例题2：洛谷P4425 [HNOI/AHOI2018] 转盘

+ 线段树分裂

  用于把线段树中的一段连续区间分裂出来出来形成两棵线段树。以模板题（洛谷P5494 【模板】线段树分裂）为例进行说明。

  多重集的维护可以直接使用线段树动态开点维护，集合的合并使用线段树合并维护，对于分裂操作，需要维护一个新树的根结点指针，然后一边向下走一边判断，若新分裂出来的树也需要对应位置的结点保持形态，那么就动态开结点给新树用，直到结点区间被操作区间完全包含为止，这时候就可以把这个子树直接接到新树下方。使用传址调用可以极大地降低代码难度。

  ```C++
  void split(int L, int R, int& cur1, int& cur2, int l, int r) {
  	if ((l <= L) && (r >= R)) { cur2 = cur1, cur1 = 0; return; }
  	cur2 = top ? stk[top--] : (++cnt);//用一个栈实现内存池垃圾回收
  	int mid = (L + R) >> 1;
  	if (l <= mid) split(L, mid, ls[cur1], ls[cur2], l, r);
  	if (r > mid) split(mid + 1, R, rs[cur1], rs[cur2], l, r);
  	pushup(cur1), pushup(cur2);
  }
  ```

  + 例题1：洛谷P2824 [HEOI2016/TJOI2016] 排序

    我们可以把一个极长递增序列以及一个极长递减序列段用权值线段树维护，那么区间排序只需要分裂至多两端的段，然后合并连续的若干段，用摊还分析可以证明至多合并$O(n+m)$次，那么最终的序列都可以完全求解出来。

+ 线段树分治

  用于维护时间轴序列，把某个时间加入某个时间删除的操作转换为时间轴区间上插入。

  + 维护图连通性的例题：

    核心思想就是不好进行删边操作，那么就把所有的操作变成在某个时间点加入一些边。具体而言，把一条边的出现与删除转换成时间轴区间上的插入，然后把其分散到$O(logn)$个线段树结点上，然后自上而下dfs整棵线段树，每遇到一个结点就把所有保存在这个结点上面的出现的边用并查集合并维护连通性，再向下递归，若到达叶子结点就回答对应时间点的询问，返回时需要撤销并查集操作，那么并查集按秩合并开栈记录即可。

    + 例题1：洛谷P2147 [SDOI2008]洞穴勘测
    + 例题2：洛谷P5214 [SHOI2014]神奇化合物
    + 例题3：洛谷P4121 [WC2005]双面棋盘

  + 其他维护信息的题目：
    + 例题1：洛谷P4585 [FJOI2015]火星商店问题
    
      套入一个01Trie维护即可。
    + 例题2：洛谷P3733 [HAOI2017]八纵八横
    + 例题3：洛谷P3206 [HNOI2010]城市建设

+ 区间取最值型的操作

  直接介绍Segment Tree Beats（吉老师线段树）的实现方法。

+ 扫描线的维护

  + 例题1：洛谷P5490 【模板】扫描线（矩形面积并）

    考虑将所有的矩形上下线段拆开，然后按照纵坐标自下而上排序，容易发现只需要处理每一个不同的$y$值处发生的变动，求解当前有水平坐标多少位置有矩形覆盖，相邻两个$y$之间的部分可以直接用底乘高求解面积，然后求和即可。

    对于所有的矩形上下边界，记录其横坐标两个端点，纵坐标以及是否为下边界，自下向上做扫描线，若一条线段代表的是矩形下边界，就在区间数据结构内把这个区间加1，否则减1。在处理一个纵坐标之前，查询有多少位置满足非0，再乘上相邻两个不同的$y$之间的差值，非0位置个数可以用全长减去0的数量，又发现最小值永远不会小于0，那么可以特殊转化为维护最小值以及其出现次数即可。

    另外这个题目的$x$也很大，但注意到$2n$个横坐标最多会把横轴分成$2n-1$个区域，于是横坐标做一遍离散化，每个位置记录当前横坐标与下一个横坐标的距离差，转化为一段连续的区间加，使用线段树实现即可。

  + 例题2：洛谷P1856 [IOI1998] [USACO5.5] 矩形周长Picture

    考虑沿用上面的做法，发现周长可以分解为水平线段长度加上竖直线段长度，并且两个维度的求解等价，于是以求解水平线段长度为例。考虑什么地方的线段会成为周长的一部分，对于一个固定要处理的$y$上面的线段的部分，沿用上面累加线段树的做法，其成为边长的条件是：处理完后一个位置由0变为非0，或者由非0变成0，前者对应矩形下边界成为边长的一部分，后者对应矩形上边界。处理时，对于固定的一个$y$，先把所有下边界加入线段树，查询一遍前后变化量得到由0变非0的位置个数，再把所有上边界加入，查询变化量得到由非0变的位置个数，累加即可。同理竖直线段的求解。

  + 例题3：洛谷P3246 [HNOI2016] 序列

    首先有考虑贡献的套路，设这个序列为$a$，考虑每一个位置能够成为多少个区间的最小值，对于相同元素，我们令一个子段的最小值是这一段的最小值中最靠左的。那么利用单调栈处理出左面第一个小于等于当前位置的值的位置，以及右面第一个小于当前值的位置。设位置$i$能够向左最多延伸到$left(i)$，向右最多延伸到$right(i)$。

    定义一个二维平面，位置$(x,y)$上面的值是$a[x...y]$中最靠左的最小值，显然对于序列中的每个元素，平面中$left(i)\le x \le i$，$i\le y \le right(i)$的值就是$a[i]$，由此可以将二维平面$y=x$的上半部分分割成若干不相交的子矩形。考虑扫描线的过程，每个询问$[l,r]$就是在查询二维平面内$l\le x \le r$，$l\le y \le r$这一部分的矩阵和，进一步拆分成$x \le r$，$l\le y \le r$的和与$x \le l-1$，$l\le y \le r$的和。递增枚举横坐标，对于已经完全包含在左面的子矩形，直接区间加法维护和；对于跨越当前横坐标的子矩形，注意到我们要求的部分和就是$\sum (r-left(i))\times a[i]=r\sum a[i]-\sum left(i)a[i]$，用两个线段树分别维护当前未被完全扫描完的子矩形的$a[i]$与$left(i)a[i]$即可。

+ 优化建图

  + 例题1：洛谷P5025 [SNOI2017]炸弹
  + 例题2：洛谷P3588 [POI2015] PUS

+ DP优化

  + 例题1：洛谷P1848 [USACO12OPEN] Bookshelf G

    设$f(i)$表示把前$i$本书放在书架上时的最小高度，容易得到一个简单的暴力DP方程：$f(i)=min\{f(j)+max\{h_{j+1}\dots h_{i}\}\}$，约束条件为$\sum_{k=j+1}^{i}w_k\le L$。容易发现右端点固定的时候，约束条件的最左可达位置可以使用双指针求得，再发现对于最大值的维护，是一个自右向左的阶梯函数，每一次向右扩展一个位置就相当于进行一次区间覆盖，其左端点可以通过单调栈求得，那么线段树需要支持维护两个信息的和，一个是单点修改$f(i)$，另一个是区间覆盖$h_i$的最大值，并且支持查询$f(i)+max\{h_{i+1}\dots h_{now}\}$的最大值，区间维护$f$的最大值与$f+h$的后缀值，线段树需要两个修改一个查询实现即可。
  + 例题2：CF833B The Bakery

    设$f(i,j)$表示前$i$个数分了$j$段的方案数，然后考虑枚举最后一段转移，也就是$f(i,j)=max\{f(k,j-1)+count(k+1,i)\}$，其中$count(l,r)$表示区间$[l,r]$的不同数字个数，考虑沿用离线区间数颜色的思想，对于每个位置记录上一次出现相同数字的位置，统计就固定一个右端点然后向左寻找所有的第一次出现的颜色的位置，动态的维护每个位置$x$的$count(x,r)$，本质就是一个实现一个区间加法。然后外层循环枚举段数，内层循环枚举位置，把$f$与$count$结合，由于$f$满足所有的$f(i,j)$由$f(x,j-1)$转移而来，那么对于所有的$x$，$f(x,j-1)$已经在上一轮内层循环中处理完成，线段树初始化的时候就已经可以确定了，然后实现一个简单的区间加法，求解前缀中$f(x-1,j-1)+count(x,r)$的最大值转移即可。
  + 例题3：洛谷P3928 SAC E#1 - 一道简单题 Sequence2

    显然可以设计一个DP，$f(i,1/2/3/4)$表示强制选第$i$列的数，这个数在第一行/第二行/第三行且递增/第三行且递降，从左向右DP，对值域离散化以后，线段树以值域为下标维护所有的DP值，转移类似于最长上升子序列。

+ zkw线段树

----

#### 分块-Block Tech

+ 基本操作

  以hzwer的数列分块入门九题作为基础操作讲解。以下默认当询问左右端点在同一个块内的时候就是零散块的操作，设$B$为块长。

  + 数列分块1：区间加法，单点查询

    分块，每个块打一个标记，维护整个块内每个元素额外加上了多少。加法操作就枚举散块与整块，散块直接暴力加，整块只需要在标记上做加法即可。单点查询只需要取出序列中的数再加上所在块的标记即可。块长取$B=\sqrt{n}$的时候复杂度为$O(m\sqrt{n})$。

  + 数列分块2：区间加法，区间询问小于等于某个元素的数的个数

    分块，每个块打标记记录这个块每个元素额外加上了多少，还需要维护一个数组保存这个块中所有元素排序过后的结果。散块暴力给每一个元素做加法，排序重构排序数组；查询答案就暴力枚举散块元素，整块内部二分。块长取$B=\sqrt{n}$的时候复杂度为$O(m\sqrt{n}logn)$。

    当然了，注意到散块加法是给排好序的数组中的一部分数做加法，故在排序数组中每个数额外记录其在原序列中的位置，一遍扫描把排序数组分成两部分，其中一部分是需要做加法的，另一部分不需要做加法，这两部分可以通过归并实现排序数组的维护。调节块长，块长取$B=\sqrt{nlogn}$的时候复杂度为$O(m\sqrt{nlogn})$。

  + 数列分块3：区间加法，区间查询前驱

    实现手法和数列分块2相似，故不再赘述。

  + 数列分块4：区间加法，区间求和

    分块，每个块维护整个块的元素和，以及打标记，维护这个块内每个元素额外加上了多少。加法操作就枚举散块与整块，散块直接暴力加，维护整块元素和，整块需要在标记上做加法，元素和也相应的有变动。区间求和需要枚举零散块与整块，整块直接查询块内元素和，零散块部分暴力扫描，注意需要加上所在块的标记。

  + 数列分块5：区间每个数开方，区间求和

    分块，维护每个块内的元素最大值。注意到正整型范围内的每个元素开平方根下取整不超过5次就会变成1，变成1或者0以后就不再变化，所以每个元素暴力做就可以。对于零散块暴力开根号维护块和与最大值，在整块的最大值超过1的时候对整个块暴力，维护块和与最大值，否则直接跳过不计算。求和同理数列分块4。整块至多暴力$5B^2\times \frac{n}{B}=O(Bn)$数量级，在块长取$B=\sqrt{n}$的时候复杂度为$O((n+m)\sqrt{n})$。

  + 数列分块6：单点插入，单点询问

    这个将会放在维护序列的数据结构中的块状链表部分讲解。

  + 数列分块7：区间加法，区间乘法，区间求和

    类似于线段树做法，每个块维护加法乘法标记，注意标记下推的顺序，将数列分块4与乘法线段树结合一下就可以了。

  + 数列分块8：区间赋值，区间询问某个数的出现次数

    考虑怎么维护区间赋值，如果我们能做到在$O(x)$时间内定位、移除或增加一个颜色段，由摊还分析可以知道暴力修改（无查询的情况下）的复杂度是$O((n+m)x)$的，即移除所有被包含的颜色段，分割有交集的两端，插入一个连续的整段的总复杂度。

    维护$cnt(i,j)$实表示块$i$内$j$出现了多少次，再在每个块内实现现一个链表，维护这个块内的极长相同数字段，每一次零散块操作会让这个块内极长色段数减少$x(0\le x)$并且至多增加$2$，暴力重构一下维护；整块赋值就直接暴力遍历这个块的链表修改$cnt$数组，这一部分的复杂度是这个块的初始颜色段数加上后来零散块操作加上的颜色数，所有块的总量是$O(n+m)$的。查询就散块暴力整块查表。块长取$B=\sqrt{n}$的时候复杂度为$O((n+m)\sqrt{n})$。

  + 数列分块9：区间众数（洛谷P4168 [Violet] 蒲公英）

    设$cnt(i,j)$表示前$i$个块内$j$出现了多少次，前缀和处理；$ans(i,j)$表示从第$i$个块的开头到位置$j$这段区间的最小众数，枚举每个块的左端点向右暴力处理。求解答案的时候，若询问左右端点在同一个块内的时候暴力求解，否则先查$ans$数组求出一个临时解，扫描左右零散块，开一个$num(i)$记录零散部分$i$出现了多少次，枚举左零散块中的元素，利用$cnt$与$num$查询出现次数更新答案。求解完一次就撤销清空$num$数组。块长取$\sqrt{n}$的时候复杂度为$O((n+m)\sqrt{n})$。

+ 一些进阶分块题目

  + 例题1：洛谷P4108 [HEOI2015]公约数数列

    考虑到从序列开头到所有位置出现的本质不同的前缀最大公约数的出现数量级是$O(logV)$的，这允许我们暴力枚举前缀最大公约数并查找某个前缀异或和，但区间异或区间查找某个数是否出现不易于我们操作。考虑暴力分块，每个块维护这个块内的异或前缀，以及对应的异或前缀集合，一个块内数据的的最大公约数，从序列开头到这个块尾的最大公约数。查询的时候从序列开头枚举每一个块，若前缀经过这个块以后的最大公约数没有变化，就去这个块对应的异或前缀集合内查找，否则暴力扫一遍这个块求解。显然暴力的次数很少，当块长为$B$的时候，单次修改复杂度$O(BlogV+BlogB+\frac{n}{B}logV)$，单次查询复杂度为$O(Blog^2V+\frac{n}{B}logB)$，$B$在取一个比较小的数，约$\frac{\sqrt{n}}{4}$的时候运行速度比较优秀。

  + 例题2：洛谷P5046 [Ynoi2019 模拟赛] Yuno loves sqrt technology I

    对于在线区间逆序对，介绍两种复杂度一样的做法，均为时间复杂度$O((n+m)\sqrt{n})$，空间复杂度$O(n\sqrt{n})$。在此分别介绍跨块处理手法，零散块以及块内询问处理手法一样故放在后面。

    + $f(i,j)$表示前$i$个块内小于等于$j$的数有多少个，$ans(i,j)$表示第$i$个块的开头到第$j$个块的末尾这一段的答案，然后对于每个块处理前缀后缀的逆序对数，$ans(i,j)=ans(i,j-1)+ans(j,j)+calc()$，这个$calc$表示的是求解块$i$到$j-1$这一部分与块$j$产生的逆序对数贡献，只需要枚举块$j$内的元素，查$f$数组求得贡献。$ans(i,i)$可以在求解前后缀时顺带求出。每个单独的部分考虑完然后考虑互相的贡献，零散块之间采用归并，零散块对整块的部分用$f$数组，枚举零散块元素，查询f数组得到这个元素的贡献求和即可。

    + $f(i,j)$表示前$i$个元素对第$j$个块产生的逆序对数贡献，求解只需要把第$j$个块与整个序列做一遍归并，考虑元素$i$在这个块的前面还是后面（如果在块内的话就不产生贡献），$O(n)$求出一个块的信息，做一遍前缀和得到结果。然后上述做法中的$calc$可以直接查询$f$数组，进而在$O(n)$时间复杂度内求得$ans$数组，零散块对整块的贡献就枚举中间块，用数组$f$差分求解。

    将每个零散块复制一下进行排序，扫零散块的时候打标记，扫描排序数组得到零散部分的有序数列，然后归并求解逆序对。左右端点落在同一个块的询问只需要两个后缀相减再减去归并求得的贡献即可。

  + 例题3：洛谷P4117 [Ynoi2018] 五彩斑斓的世界

    首先在不考虑空间开销的情况下维护一个区间做减法的过程，对序列分块，每个块维护一个最大值，考虑若能够对于一个块在$O(x)$的复杂度内把一个块的元素极差缩小$x$，由摊还分析知道我们处理一个块的复杂度是$O(V+m)$的。对所有大于$x$的数减去$x$，考虑当一个块内的数值位于值域区间$[1,V]$的时候，$x\ge V$的时候跳过不考虑，主要考虑$1\le x <V$的情况，显然我们可以首先考虑一个暴力，把一个块内所有出现相同数字的位置都放到一起，然后枚举$x+1$一直到$V$，把集合合并到其所在的下标减$x$后的集合内。

    + $x> V-x$，那么要在$O(x)$的复杂度内让区间的极差减小$x$，显然直接枚举$[x+1,V]$的每一个数，对应减掉$x$以后集合合并即可。
    + $x\le V-x$，那么要在$O(x)$的复杂度内让区间的极差减小$x$，不能枚举大的部分就考虑枚举小的部分，这时候可以有等价操作：给序列中每个小于等于$x$的数加上$x$，然后查询$x$的出现次数的时候需要加上块内偏移量以后查询集合大小。

    显然，集合的合并可以使用并查集，每个块维护并查集，把所有一样的数合并，记录每个集合的根元素位置以及大小，对位合并即可。零散块暴力只需要减去偏移量以后重构并查集。注意到询问不需要在线，并且每个块的询问以及修改操作之间相互独立，只需要把操作离线逐块处理就可以做到空间线性。

  + 例题4：洛谷P5048 [Ynoi2019 模拟赛] Yuno loves sqrt technology III

  + 例题5：洛谷P6774 [NOI2020] 时代的眼泪

+ 值域分块

  一般要套序列分块一起使用，用于求解区间第K大。一般用$cnt1(i,j)$表示前$i$个块内$j$出现了多少次，$cnt2(i,j)$表示前$i$个块内值域有多少数位于值域的第$j$个块内，然后零散部分（如果询问跨块，那么零散部分就是左右两端，否则就是询问的序列）记录$cnt3(i)$为零散部分有多少$i$，$cnt4(i)$为零散部分有多少数落入值域块$i$，然后从小到大枚举值域块，类似于线段树二分，如果定位了某个块就枚举这个值域块内部的元素，求解完成后撤销零散块贡献。

  + 例题1：洛谷P4119 [Ynoi2018] 未来日记

    首先按照上面说的进行序列与值域分块，然后每个块记录一个映射，$f1(i)$表示当前块内$i$代表什么数，$f2(i)$表示当前块内什么数代表$i$，然后零散块修改直接重构，记录块内有多少$x$，整块考虑三种情况：

    + 没有$x$，那么直接跳过；

    + 有$x$，没有$y$，直接用上面提到的$f1$、$f2$进行映射，同时记录块内有多少个$x$；
    + 有$x$，有$y$，直接重构这个块，记录块内有多少$x$。

    然后对于修改，记录每个块有多少$x$被修改，求一个前缀和后对$cnt1$、$cnt2$进行修改维护。

    这个复杂度看起来是假的，但实际上仍然是$O(n \sqrt{n})$的（认为序列长度与询问量同阶）：考虑一个整块的重构会用$O(\sqrt{n})$的代价将这个块内的数字种类减少$1$，而一个块的数字种类至多是$\sqrt{n}$个，只有一次零散块的重构才可能会给这个数增加$1$，零散块的重构次数不超过$n+2m$，所以总的重构复杂度为$O((n+m)\sqrt{n})$，而在认为查询复杂度是$O(m\sqrt{n})$的情况下，总的重构代价与总复杂度的渐进表示一致，即$O((n+m)\sqrt{n})$。

----

#### 嵌套数据结构树套树

说白了就是外面一个维护序列的数据结构，里面一个维护集合的数据结构。具体而言就是维护序列的数据结构的每个结点都需要维护这个结点所代表的区间内所有元素的可重集。

树套树用于维护区间第K大、区间x的排名、区间查找前驱后继等应用。

除非内层是权值线段树，否则树套树求解区间第K大都需要多一个$log$，因为权值线段树虽然可能由于动态开点的缘故形态不同，但是所有不同的权值线段树上对应结点的代表区间一致，所以可以在若干棵线段树上同时二分向下走，省去了每一次再跑一遍外层数据结构的复杂度。

| 数据结构类型            | 空间复杂度     | 单点修改时间复杂度 | 区间x的排名   | 区间第K大       |
| ----------------------- | -------------- | ------------------ | ------------- | --------------- |
| 树状数组/线段树套平衡树 | $O(nlogn)$     | $O(log^2n)$        | $O(log^2n)$   | $O(logVlog^2n)$ |
| 树状数组套权值线段树    | $O(nlogVlogn)$ | $O(logVlogn)$      | $O(logVlogn)$ | $O(logVlogn)$   |

下面给出一些经典例题：

+ 带修区间数颜色

  + 单点修改（洛谷P1903 [国家集训队] 数颜色）

    考虑维护某一个位置的$pre$，那么区间内第一次出现的颜色满足$pre$小于询问区间左端点，转化成求解区间内有多少数小于$x$，显然$pre$只涉及两种元素的变动，考虑对于每一种颜色开一个set，记录所有这种颜色出现的位置，然后对于一个位置，求出当前颜色的后继、目标颜色的前驱后继，树套树单点修改（强制在线）或者CDQ分治求解（允许离线）。

  + 区间赋值（洛谷P4690 [Ynoi2016] 镜中的昆虫）

    考虑依然沿用上面记录$pre$数组的做法，然后把颜色相同的位置缩成一段，采用类似于珂朵莉树的形式维护，然后对于一段的修改操作，若一个颜色段完全位于区间内部则只需要修改这一段开头位置的$pre$值，否则需要修改这一段分裂后分裂处的$pre$值，至多需要修改$2$个位置。容易发现在这个过程中我们以$O(nlogn)$的代价使颜色段数的数目至少减少$n-2$个，在初始化以及后面的操作中颜色段数总量不会超过$O(n+m)$，利用摊还分析可以证明复杂度正确，同时$O(n+m)$也就是需要单点修改的$pre$的总量。只需要把这么多个操作放在树套树上或者CDQ分治就可以解决。

+ 三维偏序

  以洛谷P3810 陌上花开为例说明如何解决。
  
  考虑以第一维为最高关键字升序，第二维为次高关键字升序，第三维最低级关键字升序排序，沿用二维偏序的思路，这时候数据结构需要维护两个关键字，从左到右枚举元素，查询第二维与第三维均小于当前元素的有多少个，再把元素加进来。这时候可以以树套树下标作为第二维，权值为第三维维护，只需要支持单点插入一个数，前缀查询有多少个数比某个值小即可。
  
  一般这种题目都是允许离线的，CDQ分治相比于树套树在空间复杂度以及实现常数上有明显的优势，故这个应用不够practical。
  
#### 整体二分

这里以单点修改，区间第K大为例，讲解整体二分的实现方法。（洛谷P2617 Dynamic Rankings）

将序列中的每个初始的数表示为单点插入，然后将询问与修改都放进一个大数组里一起操作。询问的形式就是求解一个区间的第K大，序列初始化的形式是单点增加一个数，修改的形式是单点移除一个数再加入另一个数。所有的操作从左到右按照时间顺序递增。预先开好一个允许单点加区间求和的数据结构，以及两个栈$stk1$、$stk2$用来分离所有的操作。

在我们已知所有的元素的取值范围以及所有的操作以后，设函数`solve(L,R,l,r)`表示当前处理所有的修改的值域以及询问的答案均位于区间$[L,R]$内，这一部分在所有的操作序列$[l,r]$中。

考虑二分法检查答案，即检查区间内有多少数小于等于$mid$。令$mid=\lfloor \frac{R+L}{2} \rfloor$，然后从$l$到$r$枚举操作，若此时对应的增加/移除操作，且这个操作的权值小于等于$mid$，就在一个新的数组内把这个位置的值增加/减少$1$，并且把这个修改放入$stk1$，否则只需要放入$stk2$；若遇到查询操作，就在序列中查询这一段有多少个$1$，也就是检查当前这一段内值域位于$[l,mid]$中的数有多少，设这个数值为$offset$，若$rank \le offset$则把这个询问放入$stk1$，否则将$rank$减去$offset$，然后把询问放入$stk2$。这个过程类似于线段树上二分，也就是查询左子树中的元素个数以决定向哪一个子结点迭代。处理完以后就把$stk1$中的操作进行一遍撤销，将两个栈中的操作放回操作序列$[l,r]$，其中$stk1$在左，$stk2$在右，向下递归`solve(L,mid,l,l+top1-1)`和`solve(mid+1,R,l+top,r)`。当递归到某一段没有询问的时候就返回，当值域区间长度为$1$的时候，就可以直接更新对应操作区间内询问的答案了。

复杂度分析：显然一个操作只会出现在$logV$个值域区间内，每个操作恰好对应常数次数据结构的修改或者查询，故总复杂度$O((n+m)lognlogV)$。

提供一个单点修改，区间第K大的写法：

  ```c++
  struct option {
  	int id, x, y, z;
  } s[maxn << 1], stk1[maxn], stk2[maxn];
  //当id为0的时候为修改操作，把x位置移除/增加（对应z取值为-1/1）一个y
  //id为正的时候为询问编号，询问区间[x,y]的第z大
  void solve(int l, int r, int L, int R) {
  	if (l > r) return;
  	if (L == R) {
  		for (int i = l; i <= r; ++i) if (s[i].id) ans[s[i].id] = L;
  		return;
  	}
  	int mid = (L + R) >> 1, pos = l, top1 = 0, top2 = 0;
  	for (int i = l; i <= r; ++i) {
  		if (!s[i].id) {
  			if (s[i].y <= mid) modify(s[i].x, s[i].z), stk1[++top1] = s[i];
  			else stk2[++top2] = s[i];
  		}
  		else {
  			int k = query(s[i].y) - query(s[i].x - 1);
  			if (s[i].z <= k) stk1[++top1] = s[i];
  			else { s[i].z -= k; stk2[++top2] = s[i]; }
  		}
  	}
  	for (int i = 1; i <= top1; ++i) {
  		if (!stk1[i].id) modify(stk1[i].x, -stk1[i].z);
  		s[pos++] = stk1[i];
  	}
  	for (int i = 1; i <= top2; ++i) s[pos++] = stk2[i];
  	solve(l, l + top1 - 1, L, mid), solve(l + top1, r, mid + 1, R);
  }
  ```

别的可以用整体二分解决的题目：

+ 例题1：洛谷P3332 [ZJOI2013] K大数查询
  
  把树状数组换成线段树或者双树状数组维护区间加法区间求和即可。

+ 例题2：洛谷P1527 [国家集训队] 矩阵乘法
  
  换成二维树状数组即可。

+ 例题3：洛谷P3527 [POI2011] MET-Meteors

  二分最早收集到足够材料的时间，树状数组维护即可。

+ 例题4：洛谷P4175 [CTSC2008] 网络管理

  套入一个树剖即可。

+ 例题5：洛谷P3242 [HNOI2015] 接水果

  考虑二分答案以后如何检查一条路径被多少路径所包含，我们对子路径的种类进行分类：
  
  + 子路径在原树中直上直下，设路径端点为$x$与$y$，且满足$x$是$y$的祖先，那么作为子路径必须满足一个端点在$x$的子树外，一个端点在$y$的子树内，用DFS序表示，即一个端点DFS序，满足在$[1,dfn(x)]\or[dfn(x)+siz(x),n]$，另一个端点在$[dfn(y),dfn(y)+siz(y)-1]$内。
  + 路径折弯，也就是$x\neq lca(x,y)\neq y$，那么路径端点DFS序满足一个在$[dfn(x),dfn(x)+siz(x)-1]$，另一个满足在$[dfn(y),dfn(y)+siz(y)-1]$。
    
  
  综合上面两种情况，可以把所有的盘子看做是边，两个端点转化为相应的DFS序，进而转化为二维偏序问题，整体二分的时候维护二位数点问题即可。


----

#### 笛卡尔树-Descartes Tree

笛卡尔树是一棵二叉树，满足堆性质，其中序遍历为原序列。

+ 笛卡尔树的性质

  一般来讲最常用的就是：对于原序列中的区间最值，可以转化为其对应的笛卡尔树的LCA的求解。

+ 笛卡尔树的修建
  
  以下以小根堆为例说明其修建方式。

  + $O(nlogn)$做法
  
    显然可以取出全局最小值为根，然后两边作为子树递归修建下去，这个过程可以用线段树或者ST表预处理出区间最值以及其出现位置，然后记录区间左右端点递归即可。
  + $O(n)$做法
  
    例题就是洛谷P5854 【模板】笛卡尔树。
  
    考虑增量法构建，即已知中序遍历得到的序列，考虑从左向右一个一个的加入元素，并维护树的形态。
  
    容易发现越后加入的元素越应该出现在右子树内，设当前加入的是第$n+1$个元素，考虑用栈维护前$n$个元素构成的笛卡尔树根结点的右脊柱，即从根一直走右子树直到空结点形成的序列，然后考虑插入第$n+1$个元素到这棵树的右脊柱上面，为了维护堆性质，首先把不满足堆性质的一部分弹掉，然后寻找到第一个合法的栈顶，把栈顶的右儿子设为新加入的结点$cur$，然后把弹掉的一部分设为$cur$的左子树，最后将$n+1$入栈。容易发现这个过程中，前$n$个元素的中序遍历没有发生变化，并且$cur$出现在中序遍历末尾，且整棵树满足堆性质，容易发现用栈维护下，其时间复杂度为$O(n)$。
  
    下面提供一个写法，这个写法维护在弹栈的同时右子树信息。所以最终还要弹一遍栈维护最后的右子树信息。
  
    ```c++
    int n, s[maxn], ls[maxn], rs[maxn], stk[maxn], top;
    inline void build(){
    	for (int i = 1, las; i <= n; ++i) {
    		las = 0;
    		while (top && (s[stk[top]] > s[i])) {
    			las = stk[top--];
    			rs[stk[top]] = stk[top + 1];
    		}
    		if (las) ls[i] = las;
    		stk[++top] = i;
    	}
    	while (top) --top, rs[stk[top]] = stk[top + 1];
    }
  
+ 笛卡尔树例题
  + 例题1：洛谷P6453 [COCI2008-2009#4] PERIODNI

    考虑以全局最小值的高度来上下分割，可以发现把图形分割成了左右两部分与下面一个矩形，首先左右分别递归下去用背包计算放$x$个数字的方案数。然后考虑合并，显然放入的数字要么会放在下面的矩形中，要么放在左右上面的部分。左右上面的部分首先合并计入答案，这个过程就是背包数组的合并，然后考虑在这个基础上，在下面的矩形中放入数字，容易发现左右上部确定总共放多少以后，等价于确定了矩形中有多少列不能放，那么首先枚举上面的部分总共放了几个，然后枚举矩形中放几个，更新背包数组，这个过程使用组合数实现。容易发现这个过程本质是在笛卡尔树上面做一个背包DP。
  + 例题2：洛谷P5044 [IOI2018] meetings 会议
  
    考虑设计一个朴素的区间DP，设原序列为$s$，$f(l,r)$表示区间$[l,r]$的最优解，然后从区间最大值处进行分割，设区间$[l,r]$的最大值取于$pos$，那么有$f(l,r)=min\{f(l,pos-1)+(r-pos+1)\times s[pos],f(pos+1,r)+(pos-l+1)\times s_{pos}\}$，即有一侧跨过区间最大值的贡献一定是区间最大值。然后考虑使用笛卡尔树进行最值分治，即从区间最大值对应的笛卡尔树的位置一分为二，变成笛卡尔树上面前缀最大DP值与后缀最大DP值的求解。
  
    以求前缀最大值为例，对于结点$cur$，设其代表的区间最大值取于$pos$，其对应的区间为$[l,r]$，那么要求出$f(l,l)$，$f(l,l+1)\dots f(l,r)$，显然右$f(l,l)$一直到$f(l,pos-1)$都可以在左子树里面求出，$f(pos+1,pos+1)\dots f(pos+1,R)$可以在右子树里面求出，容易得出$f(l,pos)=f(l,pos-1)+s_{pos}$，然后考虑$x>pos$的时候$f(l,x)$的求解，可以考虑枚举最值出现的位置，可以得出$f(l,x)=min\{f(l,pos-1)+(x-pos+1)\times s_{pos},f(pos+1,x)+(pos-l+1)\times s_{pos}\}$。此时注意到笛卡尔树的大根堆性质，前一项随着$x$的递增而增加$s_{pos}$，后一项的增量一定小于等于$s_p$，其中$pos+1\le p\le x+1$，放缩一下得到$f(pos+1,x+1)\le f(pos+1,x)+s_p\le f(pos+1,x)+s_{pos}$，也就是后一项增量永远不会超过$s_{pos}$，也就是前一项可能会在未来的某一时刻永远超过后一项，于是二分这个临界位置，临界位置以左的$f(l,x)$是一个区间赋值等差数列，右侧是一个对$f(pos+1,x)$做区间加法然后变成当前前缀答案的一部分，使用线段树实现，由于只求解了前缀没有求解后缀，所以需要正向求解一遍，反向求解一遍取较小者得出答案。
  
    具体实现上，设当前DFS到笛卡尔树结点$cur$，设其代表的区间最大值取于$pos$，其对应的区间为$[l,r]$，那么在合并之前线段树左子树每个位置存储的内容为$f(l,l)\dots f(l,pos-1)$，右子树内为$f(pos+1,pos+1)\dots f(pos+1,r)$，在右子树对应区间内实现区间赋值等差数列以及区间加的实现。这样做完以后这个区间内每个位置在线段树里面的值是其到区间左端点的DP值，并且这样记录信息能够顺承后续的合并。由此发现需要将询问离线，挂载在笛卡尔树上，这一步通过快速LCA实现。

---

#### 能够快速预处理的静态区间查询

+ 倍增rmq，ST表

  以求解区间最大值为例，$f(i,j)$表示闭区间$[i,i+2^j-1]$的最大值，有递推式$f(i,j)=max(f(i,j-1),f(i+2^{(j-1)},j-1))$，初始化$f(i,0)=a[i]$，查询区间$[l,r]$则令$t=\lfloor log_2(r-l+1) \rfloor$，查询$max(f(l,t),f(r-2^t+1,t))$。同理可以应用于区间$min$、区间$and$、区间$or$、区间最大公约数最小公倍数、区间线性基等具有结合律、幂等运算或者至多能够产生一次贡献的操作。

  以求解静态区间最大值为例给出代码。

  ```c++
  const int maxn = 100005;
  int n, a[maxn], f[maxn][22], log2[maxn];
  inline int query(int l, int r) {
  	int tmp = log2[r - l + 1];
  	return std::max(f[l][tmp], f[r - (1 << tmp) + 1][tmp]);
  }
  inline void init() {
  	for (int i = 1; i <= n; ++i) f[i][0] = a[i];
  	log2[0] = -1;
  	for (int i = 1; i <= n; ++i) log2[i] = log2[i >> 1] + 1;
  	for (int i = 1; i <= 20; ++i) {
  		for (int j = 1; j <= n; ++j) {
  			f[j][i] = std::max(f[j][i - 1], f[std::min(j + (1 << (i - 1)), n)][i - 1]);
  		}
  	}
  }

+ 可以优化至$O(n+m)$的rmq

  + 随机数据下期望$O(n+q)$的区间最值求解（洛谷P3793 由乃救爷爷）

    对序列分块，预处理每个块前缀后缀的答案，以及块到块的答案，这两个操作均可以在$O(n)$内完成，然后对于跨块的询问，直接将询问拆成两个零散块与中间块的答案$O(1)$求出，否则直接暴力扫出落在一个块内的答案。

    为什么这个复杂度是对的呢？考虑有多少种情况需要暴力求解，在以长度为$B=\sqrt{n}$为块长分块的情况下，答案是$\Theta(n\sqrt{n})$级别的，所有的询问的情况是$\Theta(n^2)$级别的，在所有可能的询问出现概率相等的情况下，我们有$\Theta(\frac{1}{\sqrt{n}})$的概率进行一次暴力，这个部分的期望复杂度是$O(m\times\frac{1}{\sqrt{n}}\times\sqrt{n})$也就是$O(m)$的，其它的询问均可以在$O(1)$完成，故总复杂度的期望是线性的。

    而且这个东西也不好卡，如果要卡的话需要调小询问长度，显然就有着很大的风险把暴力选手放过去。

  + 约束rmq的$O(n+m)$求解

    ”约束“的意思是整个序列中的相邻元素的差的绝对值恰好为$1$，利用这个特殊条件可以将问题进行优化。

    + 首先进行分块，按照$size=\lceil\frac{(log_2n)}{2}\rceil$为一块进行分块，然后求出单块内部前缀后缀的最大值，整块间使用ST表处理，这一部分的复杂度是$O(n)$的。
    + 当询问跨块的时候，直接零散块查表以后大块rmq，考虑当询问落在一个块内的时候怎么处理，我们要充分利用差值的绝对值为正负1的条件，需要额外记录一下每个块中的最小值是多少，然后把这个块内的所有元素减去这个最小值，注意到块长很短，全做减法以后相邻差值不变，我们认为两个块不同当且仅当在减去块内最小值以后，块内存在若干元素不同。此时由于差分数组的取值只有$\pm 1$，本质不同的块至多有$2^{0.5log_2n}$种，这个是$O(\sqrt{n})$级别的，因此对这本质不同的$O(\sqrt{n})$种块跑$O(size^2)$的暴力处理结果，查询时直接映射即可。这部分处理复杂度亚线性，单次查询$O(1)$。查询完以后需要把减去的最小值加回来。

  + $O(n\alpha(n)+m)$的做法：

+ 猫树：分治实体化的产物

----

#### 莫队-Mo's Algorithm

+ 普通莫队

  用于一些可以在$O(nm)$复杂度下暴力求解的区间询问题目，可以在已知一个区间的所有信息以及这个区间的答案的情况下$O(1)$扩展到相邻区间。不带修改，允许离线。

  + 实现方式：将所有的询问排序，对序列分成$\sqrt{n}$块，以左端点所在块编号为第一关键字升序排序，右端点为第二关键字升序排序，维护两个指针左右移动，做完一个询问就暴力移动指针维护区间的信息与答案至下一个询问。

    下面给出一个常用的指针移动写法。其中`add`实现的是增加信息，`remove`实现的是删除信息。

    ```c++
    int L = 1, R = 0;
    for (int i = 1; i <= m; ++i) {
    	while (L > query[i].l) add(--L);
    	while (R < query[i].r) add(++R);
    	while (L < query[i].l) remove(L++);
    	while (R > query[i].r) remove(R--);
    	ans[query[i].id] = solve();
    }
    ```

    由于维护的是闭区间，所以初始化的时候需要令$L=R+1$保证代表的区间为空。

  + 复杂度证明：设块长大小为$B$，那么总的分块数就是$\frac{n}{B}$，考虑复杂度来源于哪个部分：

    + 左端点在一个块内移动：每个询问至多移动块长，$O(\frac{nm}{B})$。
    + 左端点跨块移动：每个块至多向右跨一次。$O(n)$。
    + 左端点所在块相同的时候，右端点移动：每个块都对应移动序列长度数量级，$O(\frac{n^2}{B})$。
    + 左端点跨块的时候，右端点移动：$O(\frac{n^2}{B})$。

    假设$n$与$m$同阶，当$B$取$\sqrt{n}$的时候总复杂度$O((n+m)\sqrt{n})$。

  + 例题：
    + 例题1：洛谷P1494 [国家集训队]小Z的袜子

      维护古典概型组合数统计量即可。

    + 例题2：洛谷P2709 小B的询问

      维护平方的变化即可。

    + 例题3：洛谷P3730 曼哈顿交易

      需要在莫队里面维护一个权值数据结构，使得可以快速查询第K大元素，由于插入删除操作总量为$O((n+m)\sqrt{n})$，询问总量为$O(m)$，那么使用一个值域分块在$O(1)$时间内实现单点修改，$O(\sqrt{n})$单次查询，以此平衡复杂度。

    + 例题4：洛谷P4137 Rmq Problem / mex

      在莫队内嵌一个权值数据结构，能够支持增删元素，查询某一段内是否有元素出现次数为$0$，那么使用值域分块，维护某个块内非零出现个数元素的个数以及块长，查询时只需要暴力枚举块以及块内元素即可。求解mex则需要把区间内所有数字以及其整数集合意义下的直接后继都考虑到，那么把这些元素离散化即可。

    + 例题5：洛谷P4396 [AHOI2013] 作业

      同上只需要维护一个值域分块。

    + 例题6：洛谷P4462 [CQOI2018] 异或序列

      开桶记录即可。

    + 例题7：洛谷P5355 [Ynoi2017] 由乃的玉米田

      考虑加减法的实现，使用bitset移位以及与运算实现快速查询，具体而言以加法为例，设$a_i+a_j=x$，转化为$a_i=x-a_j$，bitset维护$a_i$与$-a_i$，右移后与运算查询结果，单次复杂度$O(\frac{V}{64})$。乘法只需要暴力$O(\sqrt{V})$枚举即可。考虑除法的实现，使用值域分治，若查询的$x\ge \sqrt{V}$，直接$O(\sqrt{V})$枚举较小的数查询即可，若查询的$x\le \sqrt{V}$，考虑单独拿出来处理，枚举所有的询问中的$x$，设$pre(i)$表示$i$位置之前最靠近$i$的$xa_i$或者$\frac{a_i}{x}(x|a_i)$的位置，建立线段树查询区间最大值是否大于左端点即可。

+ 带修莫队

  若问题能够允许在$O(nm)$暴力求解，在已知某个区间信息以及答案的同时$O(1)$扩展到相邻区间，这里的区间不仅包括了左右端点还包括了时间轴。

  + 实现方式：以$B=n^\frac{2}{3}$为大小分块，所有的询问离线，修改单独放到一个数组内，记录每个询问发生在多少个修改过后。所有的询问以左端点所在块为第一关键字升序，右端点所在块为第二关键字升序，时间轴为第三关键字升序排序。
  + 复杂度证明：

    + 左端点移动复杂度：一个左端点不跨块时候$O(Bm)$，跨块移动$O(n)$。
    + 右端点移动复杂度：左端点在一个块内的时候$O(Bm)$，左端点不变右端点跨块的时候$O(\frac{n^2}{B})$，左端点变化右端点跨块的时候$O(\frac{n^2}{B})$。
    + 时间轴移动复杂度：不同的左右端点所在块都会让时间轴递增移动，复杂度$O(\frac{n^2m}{B^2})$，左右端点所在块变动的时候，时间轴回调也是这个复杂度。

    综上，若认为$n$与$m$同阶，则当$B=n^ \frac{2}{3}$的时候复杂度为$O(n^\frac{5}{3})$。
  + 例题

    + 例题1：洛谷P1903 [国家集训队] 数颜色

+ 回滚莫队

  在莫队里面，有一些区间信息允许$O(1)$扩展到一个包含当前区间的大区间，但是不允许$O(1)$区间缩减（如取minmax）。

  + 实现方式：首先筛选出左右端点落在同一个块内的询问，暴力处理。其余的询问按照左端点所在块为第一关键字，右端点为第二关键字排序，枚举在同一块内的询问时，右端点指针初始化为当前块的右端点，然后不断向右扩展直至出现一个询问的右端点，然后左边只需要暴力从右向左把散块的信息加进去，并且记录加入信息的时候发生了哪些修改，做完询问就按加入顺序的反向撤销，然后继续让右端点递增左端点扩展，如此循环直至左端点在这个块内的询问都被处理完，然后清空所有的记录信息再处理下一个块的询问。
  + 例题：
    + 例题1：洛谷P5906 【模板】回滚莫队
    
      对每一个数记录最左端出现的位置以及最右端出现的位置，然后记录差值的最大值，向左扩展左端点的时候开栈记录修改的情况即可。
    
    + 例题2：SPOJ20644 ZQUERY - Zero Query
    
      区间和为0可以等价转化为两个前缀和相等，于是转化为例题1。
    
    + 例题3：ATCoder1219 歴史の研究
    
      直接记录最大带权区间众数的前后变化就可以了。
    
    + 例题4：CF522D Closest Equals
    
      和例题1的实现方式一样，只不过是最大值转化为最小值。
    

+ 树上莫队

  用于离线求解树上路径集合问题。

  + 实现方式：对于一棵树，DFS的时候需记录入栈序以及出栈序，即一棵树的欧拉序。每个点会恰好在欧拉序中出现两次，记为它们的左端点$lsid$以及右端点$rsid$。欧拉序有如下性质：（以下均假设$lsid(x)<lsid(y)$）

    + 当结点$xy$互不为对方祖先结点的时候，有$rsid(x)<lsid(y)$，且欧拉序中$[rsid(x),lsid(y)]$这一段区间中只出现过一次的编号等于这条链上的所有除$LCA(x,y)$以外的点。
    + 当结点$x$是$y$的祖先结点的时候，有$rsid(y)<rsid(x)$，欧拉序中$[lsid(x),lsid(y)]$这一段区间中只出现过一次的编号等于这条链上的所有点。

    有以上两个性质，可以对$xy$的位置关系进行讨论，然后就是出现一次算加入，出现两次的时候就移除，其余的就套普通的莫队的模板即可。

  + 例题：

    + SPOJ10707 COT2 - Count on a tree II
    
      就是把数颜色放到树上了。按照上述实现方式实现即可。
    
    + 洛谷P4074 [WC2013] 糖果公园
    
      树上带修莫队的集大成者。当然也是裸题。

+ 二次离线莫队

  适用于莫队区间更新所需要的信息可以差分成两个前缀和相减、进而转化成扫描线可以维护的形式的可以莫队的题目。以例题的形式讲解如何应用这个思想。

  + 例题1：洛谷P5047 [Ynoi2019 模拟赛] Yuno loves sqrt technology II

    考虑莫队时需要的信息，如果直接硬维护的话需要维护区间内出现了什么数，以及查询多少数比$x$大/小，考虑将所有的询问进行离线，每个询问的形式是某个区间内比$x$大/小的数有多少个，然后进行一步差分，这里以求解$l$到$r$内有多少数比$r+1$位置的数大为例：差分变成求解$1$到$r$内有多少数比$r+1$位置的数大、$1$到$l-1$内有多少数比$r+1$位置的数大，注意到前者与$l$无关，可以直接处理，后者继续离线，注意到询问的形式都是某个前缀中比某个数小或大，采用一个权值数据结构，从左到右一个一个加入元素，求解对应位置前缀的答案，这是一个$O(n)$插入总量$O(n\sqrt{n})$询问总量的扫描线，使用值域分块平衡两端复杂度，容易实现一个分块，满足$O(\sqrt{n})$单点修改$O(1)$前缀求和，利用这个可以将时间复杂度优化至$O(n\sqrt{n})$，但此时空间复杂度依然是$O(n\sqrt{n})$。

    注意到莫队的区间移动操作，当一个端点没有移动到指定位置的时候，另一个端点一直固定不动，且这个移动的端点一定是经过一个区间，那么我们依然以上面求解$l$到$r$内有多少数比$r+1$位置的数大为例，差分后与$l$无关的那部分前缀和$O(1)$查到，与$l$有关的一部分记录一个区间即可，这部分的空间开销优化至$O(m)$。

    注意到上面求解的是相邻两个询问之间的偏移量，所以还需要额外做一个前缀和才是最终的答案。

    时间复杂度$O((n+m)\sqrt{n})$，空间复杂度$O(n+m)$。

  + 例题2：洛谷P4887 第十四分块（前体）
  
    把异或$bitcount$预处理出来，然后询问的形式是前缀中有多少数与$x$异或以后二进制表示形式下能有$k$个$1$。这部分的复杂度是组合数乘上序列长度的，常数较小，允许直接做。
  
  + 例题3：洛谷P5501 [LnOI2019] 来者不拒，去者不追
  
    显然莫队需要获知的信息是区间内有多少数小于$x$，以及大于等于$x$的数的和，区间和转化为前缀相减维护，维护方法同离线区间逆序对。
  
  + 例题4：洛谷P5398 [Ynoi2018] GOSICK
  
    容易发现莫队转移需要求解的是：区间内有多少数是$x$的倍数、区间内有多少数是$x$的因子。
  
    二次离线后，对于倍数较好维护，只需要加入一个数以后枚举所有的因子就可以了，插入一个数复杂度$O(\sqrt{n})$。查询只要$O(1)$查表就可以获得。
  
    对于因子，考虑类似于根号分治，进行阈值分治，维护一个数能够成为哪些数的因子。设这个阈值为$B$，那么对于一个数$x\ge B$，显然枚举倍数插入即可。但是对于$x<B$的情况，可以枚举这个$x$，注意到所有的本质不同的移动是$O(m)$的，即端点的移动是连续的一段，且询问的前缀与当前的莫队区间没有交集，假设计算右端点递增的共线，则一开始的询问形式是“枚举一个区间内的$x$，计算某个前缀中有多少数是$x$的因子”，可以通过贡献转换为“某个前缀中$x$的出现次数，与某个区间内$x$的倍数数量的乘积”，枚举所有的$x$，通过枚举一个序列求出前缀和可以很方便的维护上面这个值，然后枚举存储的$O(m)$个询问，处理即可。可以发现左端点的做法同理，对称即可。
  
    如此分析可以发现复杂度是$O(m\sqrt{n}+mB+n\frac{V_{max}}{B})$的。具体实现上需要一些卡常技巧。
  
+ 莫队的常数优化技巧&细节
  + 优化1：调节块长。这个比较玄学。优化效果取决于各种地方的实现方式。一般情况下在$nm$同阶的时候，建议块长比$\sqrt{n}$略小一些。但不排除某些题目中询问量与序列长度数量级差别较大的情况。这个东西的优化形式可以在某些题目里见到。（洛谷P4867 Gty的二逼妹子序列）
  + 优化2：考虑对于左端点落在一个块内的询问，其右端点指针一定是向右移动的；在左端点移向下一个块的时候，右端点指针会大概率向左移动到此块第一个询问处，如果能够在这个左移的过程中处理掉所有的询问，而不是左移以后再右移去处理询问，常数会获得一定程度的优化。具体实现起来，以左端点所在块为第一关键字，右端点为第二关键字，左端点所在块的下标为奇数的时候，右端点升序排序，反之降序排序。
  + 细节：若四个while循环排布顺序不当，可能会导致指针$L>R$的情况，此时有可能会造成数组内存下溢（常见于莫队套值域分块）。所以优先考虑扩展两端区间，然后再考虑收缩区间。

----

#### 跳表-Skip List



---

#### 析合树



----

### 维护动态序列的数据结构

----

#### 伸展树-Splay

允许很方便的在保持中序遍历不变的情况下把一个结点转到根并保持复杂度。

+ 维护序列的写法

----

#### 非旋树堆-FHQ Treap

又称之为非旋树堆，允许以分裂的形式将一个treap按照中序遍历分为两个部分。

+ 维护序列的写法

  FHQ-Treap的核心在于分裂与合并上面。像普通的Treap一样，每个结点额外存在一个随机数作为关键字，以实现其随机序列的笛卡尔树来保证树高。

  对于合并操作，以大根堆为例考虑自上而下递归的过程，首先从两个树根中取出较大的一边作为根结点，若左树的根结点关键字值更大，那么由中序遍历的性质，若将两棵Treap自左向右合并，那么其中序遍历一定优先满足遍历原先左边的Treap，所以左Treap的左子树不变，将右子树与右Treap进行合并，将合并出来的树根返回，作为原左Treap的右子树。并且注意到这个过程是递归的，每一次都会有一棵树的规模减少一半，当某一棵树为空的时候就可以直接返回另一棵的树根了。

  ```c++
  int merge(int x, int y) {
  	if ((!x) || (!y)) return x | y;
  	pushdown(x), pushdown(y);
  	if (key[x] > key[y]) { rs[x] = merge(rs[x], y), pushup(x); return x; }
  	else { ls[y] = merge(x, ls[y]), pushup(y); return y; }
  }
  ```

  对于分裂操作，其与合并操作是互逆的，只需要考虑如何拆开这棵Treap，这里以排名分裂的形式说明其操作流程，排名分裂指的是将一棵Treap分成两个部分，相当于是把中序遍历从中分成两部分，然后左右再建回两棵分离的Treap。自上而下的过程中只需要考虑把哪一部分子树进行分离，分离完以后返回两棵子Treap的根结点指针，再把对应的子结点信息进行维护。

  若$rank$小于左子树结点总量，那么显然任何右子树的信息不需要变动，只需要在左子树里面继续分裂，然后把左子树分裂出的遍历顺序在后面的树根接过来，就可以完成信息的维护了。同理其它的情况。

  ```c++
  pair<int, int> split(int cur, int rank) {
  	if ((!rank) || (!cur)) return std::make_pair(0, cur);
  	pair<int, int> res;
  	pushdown(cur);
  	if (rank > siz[ls[cur]]) {
  		res = split(rs[cur], rank - siz[ls[cur]] - 1);
  		rs[cur] = res.first, res.first = cur, pushup(cur);
  	}
  	else {
  		res = split(ls[cur], rank);
  		ls[cur] = res.second, res.second = cur, pushup(cur);
  	}
  	return res;
  }
  ```
  
  所有的区间操作都可以先把所需区间分裂出来，打标记以后再合并回去即可。
  
  显然，无论是分裂还是合并，其复杂度与树高度呈正比，而一棵Treap的期望高度是$O(logn)$的（见维护集合的Treap部分），故单次操作复杂度为$O(logn)$。
  
+ 可持久化平衡树

----

#### 块状链表-Sqrt List

----

### 维护K维空间的数据结构&算法

----

#### CDQ分治

用于处理有维度大小关系限制的统计或者最优化问题，处理时用分治手法逐层剔除一个维度的限制。以例题的形式讲解。

+ 维护偏序统计量：

  + 例题1：洛谷P3810 陌上花开

    三维偏序裸题。首先按照三个维度均递增，维度的优先级依次递减的顺序排序，设这三个维度为$abc$，三个维度优先级递降，考虑分治，将问题分解为求解一个区间内部的贡献，以及两个区间之间产生的贡献。前者直接递归下去求解，现讲解后者如何计算：

    注意到递归求解前后贡献的时候，左侧点的$a$始终小于等于右侧点的$a$，满足第一维的关系，那么考虑后面两个维度，现将前后两半分别按照$b$这一维升序排序，用一个双指针维护，即按照$b$递增顺序枚举右半部分的点，将左半部分$b$满足限制的点加入一个数据结构，维护$c$这一维的情况。那么考虑在右侧查询左对右的贡献，只需要在这个数据结构内查询前缀和即可。

    注意到这个过程本身就是折半递归，然后求解前后贡献，那么$b$这一维的排序可以直接在递归的过程中顺带归并完成，可以有效地减小常数。

    下面给出代码。单点修改前缀求和使用树状数组维护。省略数据结构部分代码。总复杂度$O(nlog^2n)$。

    ```c++
    struct node {
    	int a, b, c, cnt;
    	bool operator < (const node& x) const {
    		if (a != x.a) return a < x.a;
    		else return (b != x.b) ? (b < x.b) : (c < x.c);
    	}
    }s[maxn], tmp[maxn];
    void solve(int l, int r) {
    	if (l == r) return;
    	int mid = (l + r) >> 1, pos = l, pos1 = l, pos2 = mid + 1;
    	solve(l, mid), solve(mid + 1, r);
    	for (int i = mid + 1; i <= r; ++i) {
    		while ((s[pos].b < s[i].b) && (pos <= mid)) update(s[pos].c, s[pos].cnt), ++pos;
    		ans += query(s[i].c);
    	}
    	for (int i = l; i < pos; ++i) update(s[i].c, -s[i].cnt);
    	pos = l;
    	while ((pos1 <= mid) && (pos2 <= r)) {
    		tmp[pos++] = (s[pos1].b < s[pos2].b) ? s[pos1++] : s[pos2++];
    	}
    	while (pos1 <= mid) tmp[pos++] = s[pos1++];
    	while (pos2 <= r) tmp[pos++] = s[pos2++];
    	for (int i = l; i <= r; ++i) s[i] = tmp[i];
    }

  + 例题2：洛谷P3157 [CQOI2011]动态逆序对

    容易发现可以把贡献的形式变成三个维度的大小关系，分别为位置，权值以及删除时间，那么考虑删除一个数$x$会减少的逆序对数，显然要删除时间晚于$x$，位置在左边且大于$x$，或者是位置在右边且小于$x$的数才可以产生贡献。那么针对两种情况做两轮CDQ分治即可。初始逆序对数可以直接反着加回来求。

  + 例题3：洛谷P4390 [BOI2007]Mokia 摩基亚

    经典的单点加矩阵求和。矩阵求和可以一步容斥转化成四个以原点为左下角的矩阵的求和，所有的操作考虑以横纵坐标、操作顺序为三个维度，套入CDQ分治求解即可。

  + 例题4：洛谷P4169 [Violet]天使玩偶/SJY摆棋子

    首先考虑一个弱化版的问题：若严格要求藏宝的位置在查询位置的左下方，那么可以拆开绝对值变成$|x_0-x_i|+|y_0-y_i|=x_0+y_0-(x_i+y_i)$，那么按照时间轴为第一关键字，横坐标为第二关键字，纵坐标为第三关键字处理，用一个数据结构以纵坐标为下标维护横纵坐标之和，询问点就查询前缀最大值即可。那么要从左下方扩展到全图，只需要做完一遍以后把个平面旋转三次再分别做弱化版问题，所得答案取最小值，就可以得到答案了。

+ 维护DP转移：

  + 例题1：洛谷P4093 [HEOI2016/TJOI2016]序列
  
    首先考虑一个$O(n^2)$的DP，假设位置$i$的值$a_i$可以变化成$s_i$，其中最大值设为$max_i$，最小值设为$min_i$，那么设$f(i)$表示以$i$为结尾的最长合法序列，考虑转移的两种情况，即当前位置发生变化或前一个位置发生变化，那么$f(i)=max(f(i),f(j)+1)\ | \ j \le i,\ max_j \le a_i,a_j \le min_i,a_j \le a_i $，容易发现若$max_j \le a_i,a_j \le min_i$同时满足那么$a_j \le a_i$也就是成立的。所以省掉一维，变成三个约束条件的DP，套CDQ分治处理即可。注意CDQ分治递归的时候需要先递归左半部分，然后处理左对右的贡献，然后再处理右半部分。不能归并就暴力快排，总的渐进复杂度表示不变。
  
  + 例题2：洛谷P5621 [DBOI2019]德丽莎世界第一可爱
  
    多了一个维度，考虑CDQ分治的嵌套。首先按照第一二三四维度优先级递降升序排序，然后依然考虑前对后的贡献，那么额外打一个标记记录这个点在左边还是在右边，变成三维偏序转移，转移完以后按原先顺序排列回来，按照先左，再左对右，再右的通用DP处理顺序求解即可。复杂度$O(nlog^3n)$。
  
    这衍生出来另一个CDQ分治的用法，即分治的反复嵌套，那么就可以不使用任何数据结构维护，但是代码量会上升不少，而且标记量会很多，隐含的常数也会变大。
    
  + 例题3：P4027 [NOI2007] 货币兑换
  
    题目里面已经提到，一定存在一个最优解满足单次全买入或单次全卖出，那么设$f(i)$表示第$i$天手里最多可以有多少钱。
  
    考虑转移，首先是考虑不进行买卖，有$f(i)=max\{f(i),f(i-1) \}$，由于可以在售出当天买入，那么有：
    $$
    f(i)=max\{\frac{f(k)}{B_k+Rate_k\times A_k}\times(B_i+Rate_k \times A_i) \}
    $$
    提出一个$B_i$变成最大化$\frac{f(k)}{B_k+Rate_k\times A_k}\times(1+Rate_k\times \frac{A_i}{B_i}) $，容易发现这是一个斜率优化的形式，不妨令：
    $$
    x=\frac{f(k)\times Rate_k}{B_k+Rate_kA_k},\ y=\frac{f(k)}{B_k+Rate_kA_k},\ k=-\frac{A_i}{B_i}
    $$
    斜率用上面的$k$表示，转移的时候首先求解前半段的DP数组，然后按照上述表达式修建上凸包，枚举后半段，一边做前缀最值（不买卖）一边用直线二分切凸包转移（买卖）。
  

----

#### 二维树状数组-2D Fenwick Tree

+ 单点修改，矩阵求和

  说白了就是树状数组套树状数组。单次操作复杂度$O(log^2n)$。

  ```C++
  int n, m, t[maxn][maxn];
  inline void update(int x, int y, int val) {
  	while (x <= n) {
  		for (int i = y; i <= m; i += lowbit(i)) t[x][i] += val;
  		x += lowbit(x);
  	}
  }
  inline int query(int x, int y) {
  	int res = 0;
  	while (x) {
  		for (int i = y; i; i -= lowbit(i)) res += t[x][i];
  		x -= lowbit(x);
  	}
  	return res;
  }
  ```

  高维操作同理。

+ 矩阵加法，矩阵求和（洛谷P4514 上帝造题的七分钟）

  这是一个经典树状数组套路了，首先一步简单容斥转化为$[1,1]$到$[x,y]$上面的矩阵加矩阵求和，考虑沿用一维树状数组的思路进行差分，考虑弱化问题矩阵加法单点修改，假设左上角为$[x1,y1]$，右下角为$[x2,y2]$，差分修改为$[x1,y1]$、$[x2+1,y2+1]$加$1$，$[x1,y2+1]$、$[x2+1,y1]$减$1$，单点查询变为二维前缀和；然后考虑把这些单点信息加起来。设差分数组为$a[i,j]$，则考虑每个差分数组的元素会被多少个单点计算到，得到二维前缀和：
  $$
  ans=\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j]\times(x-i+1)\times(y-j+1) \\
  =\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j]\times(xy-x(j-1)-y(i-1)+(i-1)(j-1))\\
  =xy\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j]-x\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j](j-1)-y\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j](i-1)+\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j](i-1)(j-1)
  $$
  于是记录差分数组以及上面衍生出来的三个数组，四个二维树状数组维护即可。
  
+ DP优化：单点更新，前缀max（洛谷P3287 [SCOI2014]方伯伯的玉米田）

  容易发现，一定存在一个最优解，满足所有被拔高的区间都是一个后缀。因为如果最优解不满足拔高的都是后缀，那么把这个区间向后扩展，得到的解也一定是合法的（子序列单调性不变），并且随着后面高度的增大，可能会出现更优的解。

  设计DP状态$f(i,j)$表示$i$被拔高$j$次以后，以$i$为结尾的最长不降子序列长度，那么考虑枚举前一个承接哪里，前一个位置被拔高多少，那么就是$f(i,j)=max\{f(p,t) \}+1$，满足$p<i$，$t\le j$，且$h_p+t\le h_i +j$，那么外层循环枚举$i$的取值消掉一维的限制，另外两维用二维树状数组维护。具体而言，处理$f(i,j)$之前，先把$f(i-1,j)$更新树状数组$(j,h_{i-1}+j)$位置上的值，然后查询前缀转移。边界条件$f(1,i)=1$，$0\le i \le K$。

----

#### 二维线段树&四分树-2D Segment Tree

有一说一这个东西的复杂度比较感人，不建议去用这种东西。

----

#### KD-Tree

----

### 维护树的数据结构&算法

----

#### 树上差分

+ 边差分&点差分

  考虑如下问题：树上路径加法，这里的路径可以是边可以是点，要求最后输出结果，即询问只有一次且在所有修改之后，可以使用树上差分实现。

  树上差分类似于序列差分，只考虑特殊的单点到根的链加，注意到若增加单点的点权，那么这个点到根路径上面的所有点的子树和都会增加其值。以下所有实现皆基于这个性质。

  例题：

  + 例题1：洛谷P3128 [USACO15DEC]Max Flow P

    边差分例题。把所有的边权都放到其子结点上保存，那么对于任意的路径$s$，$t$，拆成$s$到$LCA(s,t)$与$t$到$LCA(s,t)$的左闭右开的路径点集，那么路径加$x$转化为$st$加$x$，$LCA(s,t)$减$2x$。最终做一遍子树和求解每一条边的权。

  + 例题2：洛谷P3258 [JLOI2014]松鼠的新家

    点差分例题。和边差分大同小异，只不过路径拆为$s$到$LCA(s,t)$与$t$到$fa(LCA(s,t))$左闭右开的路径点集，路径加法只需要$st$加$x$，$LCA(x,y)$与$fa(LCA(x,y))$减$x$。同样做一遍子树和得出结果。

  + 例题3：洛谷P2680 [NOIP2015 提高组] 运输计划

    二分答案转化为判定性问题，设当前检查的值为$mid$，将所有长度大于$mid$的路径提出来，需要在这些路径内寻找一条最长的公共边，使得最长边减去这条边的长度以后能够小于等于$mid$，使用边差分即可实现单次线性检查。

+ 子树差分

  用于维护子树内可减信息的维护。

  全局维护一个数据结构，在进入子树以后维护当前点信息的变动，然后立刻做一次查询，再处理所有的子树，退出DFS的时候再进行一次查询，两次查询结果相减得到子树信息的变动情况。本质是把树拍平成序列，然后在DFS序上面做区间查询，只不过不需要显式的维护DFS序，只需要一遍DFS就可以完成查询。
  
  + 例题1：洛谷P3605 [USACO17JAN]Promotion Counting P
  
    询问子树内有多少点的点权大于当前值。首先离散化所有的边权，然后维护权值树状数组，在进入子树的时候先做树状数组单点加法，然后查询全局，点权大于当前值的有多少，再处理所有的子树，退出DFS的时候再查询一遍全局，两者作差即可得到子树信息的变化，也就是这个点的答案。
  
  + 例题2：洛谷P5384 [Cnoi2019]雪松果树
  
    首先离线求解$K$级祖先，采用DFS的时候维护一条根结点到当前点路径的栈实现。然后转化为求解某个点的子树内有多少某个深度的点，按照上述思路，全局开桶记录每个深度的点的个数维护即可。
  
  + 例题3：洛谷P1600 [NOIP2016 提高组] 天天爱跑步
  
    考虑把路径进行拆分，然后对于自下而上的路径，考虑$x$的子树里面能够产生贡献的一个询问$y$的出发点，显然满足$time(x)=deep(y.start)-deep(x)$，然后转化为$deep(x)+time(x)=deep(y.start)$，也就是查询子树内有多少满足条件的$y$的出发点。
    
    对于自上而下的路径，考虑$x$的子树里有多少能够产生贡献的询问$y$的到达点，那么需要满足$deep(x)+deep(y.start)-2deep(LCA(x,y.start))=time(x)$，转化为$deep(x)-time(x)=2deep(LCA(x,y.start))-deep(y.start)$。显然对于拆分好的路径来说，$LCA(x,y.start)$就是路径中最顶端的点。
    
    有了以上两步转化，考虑一个出发点或者到达点如何对路径上的点产生贡献，以自下向上的路径为例，考虑一个类似于子树差分与路径差分结合的思路，DFS进入某个点时，首先记录一个初始信息（下面会提到），DFS其所有子树，然后全局更新点差分的信息，具体而言开一个桶$bax(i)$，表示全局处理过的点内，出发点的深度为$i$的询问有多少。那么在点$x$处前后记录的信息就是$bax(deep(x)+time(x))$，做一遍前后相减得到这个点的答案。由树上差分的性质知，这个出发点只对这条自下而上的路径上的点有$1$的贡献。同理自上而下路径的求解。

---

#### DFS序&树链剖分

+ DFS序

  DFS序即先序遍历一棵树，每个结点被首先访问到的顺序。接下来以LOJ上面的四道DFS序例题作为讲解DFS序的手法。

  + LOJ P144 DFS序1：单点修改，子树求和

    对于树的DFS序，按照树上的DFS序递增顺序排列点，容易发现对于点$x$，其子树对应的点集合恰好为$[dfn[x],dfn[x]+size[x]-1]$，其中$siz[x]$代表$x$的子树大小。这一点可以由DFS的性质推得，即若$x$的DFS序为$dfn[x]$，那么其子树内的点的DFS序一定在$x$的基础上递增，且只有访问完$x$的子树以后才会访问树上别的部分，那么这一部分的DFS序就是连续的。用一个单点修改区间求和的数据结构维护即可。

  + LOJ P145 DFS序2：子树加，子树求和

    在DFS序1的基础上把单点修改变成区间修改即可。

  + LOJ P146 DFS序3：链加，子树求和，单点查询

    考虑把链加拆开，按照树上差分的思路拆为$4$条路径，把链加特殊化为某个点到根的路径加法。

    考虑链加对子树求和的影响，若先前对某个结点$x$到根的路径上增加了$val$，考虑对于子树求和，显然询问点$y$满足$LCA(x,y)=y$的时候才会有贡献，其贡献就是$(deep(x)-deep(y)+1)\times val=(deep(x)+1)\times val - deep(y)\times val$，显然$x$在$y$的子树内才会有贡献，所以维护一个子树求和，分别维护$\sum (deep(x)+1)\times val(x)$与$\sum val(x)$，两个维护序列的数据结构维护即可。

    考虑链加对单点查询的影响，仍考虑弱化问题，链加对链上一个点的贡献是其增加的值$val$，那么考虑转化为类似于树上差分的思路，改为端点加法子树求和，使用树状数组维护即可。

  + LOJ P147 DFS序4：单点修改，子树加，链求和

    可以把询问转化为两类修改的贡献之和，然后分别考虑两种修改对询问的贡献。

    考虑单点修改对链求和的影响，对树上每个点都维护其到根的链和，那么单点修改对其子树内的所有点的链和都会产生影响，是一个子树加法，询问只需要子树求和。

    考虑子树加对链求和的影响，仍然维护每个点到根的链和，那么若一次$x$的子树增加了$val$，询问为$y$到根的路径，显然需要满足$LCA(x,y)=x$才能对询问产生贡献，贡献为$(deep(y)-deep(x)+1)\times val$，那么这个$x$对其子树均会有贡献，拆开以后维护$\sum val$与$\sum deep(x) \times val$，转化为子树加子树求和。

+ 轻重链剖分

  用于解决DFS序无法处理的链操作链查询问题。

  考虑DFS的时候记录DFS序，把尽可能多的点放在一条自上而下DFS序连续的一段上面，使得我们可以用维护序列的数据结构维护树上路径。给每个非叶子结点向下连一条边，称为重边，这条边指向的结点称作重儿子；其余的指向子结点的边称为轻边，与此对应，称这些子结点为轻儿子。连续的重边自上而下连接在一起，称为重链。当我们DFS时访问到一个有重儿子的结点，那么优先访问重儿子，再访问轻儿子，让一条重链的DFS序自上而下连续递增。

  考虑链上的操作可以通过DFS序映射到一个序列上，一条重链对应一个连续的区间。特别的，认为没有重儿子的结点算作长度为$1$的重链，那么考虑如何让每个点到根上的路径中，轻重链切换次数最少，使得对维护序列的数据结构操作次数最少。方案是把最子树大小最大的子结点设为重儿子，在这种情况下每个结点到根结点的轻重链切换次数为$O(logn)$。

  这个证明比较简单，考虑从一个结点向上走，这个结点指向父结点的边是轻边当且仅当存在一个兄弟结点，这个兄弟结点的子树大小大于等于这个结点的子树大小。显然这个时候向上走一条轻链，子树大小会至少翻一倍，翻倍的次数至多是对数级别的，也就是说每个结点到根结点的轻重链切换次数都是$O(logn)$的。

  具体实现的时候需要实现两个DFS。第一遍DFS，预处理出这棵树每个点的父结点、结点深度、子树大小、重儿子是谁，第二个DFS需要记录DFS序、每个重链中的结点的链顶结点编号。链上操作只需要不断跳重链就可以实现。

  下面给出一个简单的链加链求和的实现。省略数据结构部分的具体实现。
  
  ```c++
  int top[maxn], fa[maxn], siz[maxn], deep[maxn], son[maxn], dfn[maxn], tot;
  //top代表一条重链的顶端结点编号，fa记录父节点，siz记录子树大小，deep记录结点深度，son表示重儿子，dfn为dfs序
  void dfs1(int pos) {
  	siz[pos] = 1;
  	for (int i = head[pos]; i; i = nxt[i]) {
  		if (to[i] == fa[pos]) continue;
  		fa[to[i]] = pos, deep[to[i]] = deep[pos] + 1, dfs1(to[i]);
  		siz[pos] += siz[to[i]];
  		if (siz[to[i]] > siz[son[pos]]) son[pos] = to[i];
  	}
  }
  void dfs2(int pos) {
  	dfn[pos] = ++tot;
  	if (!top[pos]) top[pos] = pos;
  	if (son[pos]) top[son[pos]] = top[pos], dfs2(son[pos]);
  	for (int i = head[pos]; i; i = nxt[i]) {
  		if ((to[i] != son[pos]) && (to[i] != fa[pos])) dfs2(to[i]);
  	}
  }
  inline void modify(int x, int y, int val) {
  	while (top[x] != top[y]) {
  		if (deep[top[x]] < deep[top[y]]) std::swap(x, y);
  		modify(1, n, dfn[top[x]], dfn[x], root, val);
  		x = fa[top[x]];
  	}
  	if (deep[x] < deep[y]) std::swap(x, y);
  	modify(1, n, dfn[y], dfn[x], root, val);
  }
  inline int query(int x, int y) {
  	int res = 0;
  	while (top[x] != top[y]) {
  		if (deep[top[x]] < deep[top[y]]) std::swap(x, y);
  		res += query(1, n, dfn[top[x]], dfn[x], root);
  		x = fa[top[x]];
  	}
  	if (deep[x] < deep[y]) std::swap(x, y);
  	res += query(1, n, dfn[y], dfn[x], root);
  	return res;
  }
  ```

  直接剖分处理的例题：

  + 例题1：洛谷P3703 [SDOI2017]树点涂色

    考虑对树上每个结点记录到根结点的颜色种类数，每一次拿掉一段颜色就会对其整个子树产生影响，移除某种颜色对子树的贡献时，这一段的链顶所在的子树都会减掉对应贡献。在不完全移除时，也即某一段颜色的下半部分未被移除时，只需要再把下半部分的子树贡献加回来。由于染色的复杂度是均摊的，所以可以暴力跳颜色相同的一段极长链处理贡献变化。此时容易枚举情况证明，若某个点$x$到根结点的颜色数答案是$ans[x]$，那么$x$到$y$的路径颜色数恰好为$ans[x]+ans[y]-2\times ans[LCA(x,y)]$。最大值查询就是子树最值查询。以上的操作直接用树剖维护即可。

  + 例题2：洛谷P7735 [NOI2021] 轻重边
  
    + 解法1：考虑在一棵树已经做好重链剖分的情况下如何处理信息，注意到重链剖分中的轻边至多只会被处理$O(logn)$次，并且实际操作中会发现跳轻边的长度每次均为$1$，是位于两条重链切换的位置。每次染完色以后可以发现，一个点至多有两条与之相连的边边权为$1$可以直接记录，那么用两个维护序列的数据结构，一个维护重链的信息，用每个对应的重儿子承接信息；一个维护轻边的信息，用这条轻边的父节点记录哪条轻边权值为$1$。由于至多记录两个，可以直接维护。
  
      实际处理的时候，对于修改操作：首先把两个链上的信息清空一下，在对应存储轻重链的数据结构都清空一下，特殊考虑区间端点为非重链链尾的情况，以及最终处理至$LCA$处的情况；然后重链部分实现链加、轻边部分单点插入即可。对于查询操作，在维护重链的数据结构上直接查，维护轻链的部分在重链切换的部分查。
  
    + 解法2：考虑等价问题，对点进行染色，一条边的权值是$1$当且仅当其相连的两个点的颜色相同，每一次操作一次相当于给这个树的对应路径染上一种从未有过的颜色，查询就是普通的区间信息合并，那么初始化每个点颜色均不相同即可。用重链剖分加上线段树维护。
  
  
  可以利用重链剖分的性质进行优化的东西：
  
    + #### 树上启发式合并-Dsu on Tree
  
      这不是一道题，这是一类求解问题的手法。它能够解决子树信息合并的问题。
  
      一般来讲，常用的子树信息合并就是普通的启发式合并，若使用线性表维护，则复杂度$O(nlogn)$，但是如果用到了`set`等非线性数据结构，那么复杂度会变成$O(nlog^2n)$，多数时候难以接受。
  
      考虑暴力优化，在DFS的时候保留一些信息。暴力的想，一个结点的子树信息被处理完以后，就把它对应的信息清空。但我们可以保留一部分信息，当某一个结点处理完最后一个子树后，不清空这个子树，而是接着利用这个子树的信息，把先前子树信息加入，这样能够优化一部分运行时间。
  
      容易发现，在这种思路下，保留的最后一个子树的子树大小应该取最大的那个，这样才能保证先前子树加入进来的足够少。那么这个过程可以这样去看：
  
      1. 找到子树大小最大的子树，提出来后续单独做处理。
      2. DFS剩余的每个子树，DFS结束以后清空这个子树。
      3. DFS最大的子树，不清空这个子树而是保留信息。
      4. 再DFS其它的子树，把信息加入进来，计算这个子树的答案。
  
      下面证明，这个做法能够达到$O(nlogn)$，假设信息的加入与删除是$O(1)$的。
  
      容易发现每次保留在最后的子树实际上就是重链剖分中，重儿子对应的子树。如此会发现，一个子树的信息会被清空以后再做一遍加入，当且仅当这个子树的根结点是其父结点的轻儿子。从贡献的角度考虑，每个结点会被枚举的次数，和从这个点出发到根的轻边数量成正比。而由重链剖分的复杂度证明可知，任何一个点到根的轻边数量是$O(logn)$的，也就是每个点被枚举的次数也是$O(logn)$的。在增删信息$O(1)$的前提下，总复杂度$O(nlogn)$。
  
      + 例题1：CF600E Lomsat gelral
  
        求解子树众数编号和，那么记录每种颜色的出现次数，以及一个$sum(i)$表示出现次数为$i$的颜色编号和，每个点记录答案的对应出现次数，一个结点的最大出现次数可以从重儿子继承并且更新。剩余的就是板子。
  
      + 例题2：CF246E Blood Cousins Return
  
        把字符串哈希并且把编号映射到$[1,n]$，变成求解子树内某一深度的不同数字个数，对每一个深度开一个`set`记录，也相对比较板子。
  
    + 重链剖分别的性质
  
        + 例题1：洛谷P5391 [Cnoi2019]青染之心
        
          考虑把操作进行离线，修建出一个树形结构，树根到某个结点上代表物品序列，新加入的物品可以看做是某个结点新多出子结点，撤销物品看做是跳往父结点，把所有的询问（也就是每一次操作完）挂载在树结点上DFS跑一个背包，时间复杂度$O(nV)$。
          
          使用重链剖分优化空间，具体做法为：每个重链开一个DP数组，然后DFS时，首先用当前结点的物品更新其所在的DP数组，然后每一次把DP数组复制一份出来让轻儿子结点使用并DFS轻儿子，最终重儿子继承当前结点的DP数组继续向下DFS。由任何一个点到树根的轻重链切换次数不超过$O(logn)$知任何时候共存的DP数组总的空间复杂度为$O(Vlogn)$。
  
+ 长链剖分

  用于DP优化、K级祖先查找优化。

  类似于重链剖分，惟一的区别是重儿子指向的是向下能够走出路径最长的一个子节点，类似的可以分析出每个结点到根结点的轻重链切换次数都是$O(\sqrt{n})$的。

  
  
  + 强制在线求K级祖先
  + 树形DP优化
  
+ 基于DFS序的换根操作

  大多数的换根都是唬人的，都只需要考虑DFS序上面的操作。

  + 例题1：洛谷P3979 遥远的国度

    链覆盖可以直接树剖解决，主要讨论树剖过后的换根子树查询。假设我们以$1$号点作为树剖初始的根，讨论换根操作完以后根不是$1$的情况。假设换过以后的根是$root$，要查询的子树以$x$为根：

    + $lca(x,root)=root$：说明在以1为根的时候，$x$在$root$的子树里面，对应$[dfn(x),dfn(x)+size(x)-1]$。
    + $lca(x,root)=x$：说明$root$在$x$的子树里面，此时用倍增法求出$root$的某个祖先$y$，使得$fa_y=x$，可以看出此时对应的区间是全局剔除$[dfn(y),dfn(y)+size(y)-1]$这部分，即$[1,dfn(y)-1]与[dfn(y)+size(y),n]$两部分。
    + 以上两种情况以外：对应$[dfn(x),dfn(x)+size(x)-1]$。

  + 例题2：洛谷P4689 [Ynoi2016] 这是我自己的发明

    看明白了换根的思路，其实这个是版块“根号分治”里面的数点问题。DFS序把树拍成序列，然后沿用出现次数少的用二维偏序，出现次数多的前缀和统计的思路就可以了。
    
  + 例题3：洛谷P3676 小清新数据结构题
  
    考虑若询问以1为根，那么修改$x$的点权后，子树和会变化的情况只有从$x$到1的这条路径会发生变化，因为是平方之和，因此树剖内套一个线段树，线段树维护每个点子树和的平方，那么线段树只需要维护区间和以及区间平方和就可以维护了。
  
    现在加上换根，考虑现在查询的点是$x$，那么会发现在以1为根的答案的基础上，子树平方和会发生变化的只有从$x$到1的路径上的点，考虑其变化：
  
    + 对于点$x$，显然变化为全局和的平方。也就是原先1号点的子树和平方。
    + 对于从$fa(x)$到1路径上的点$y$，其权值从$sum(y)^2$变化为$(sum(1)-sum(z))^2$，其中$z$满足$fa(z)=y$且$LCA(x,z)=z$。那么考虑每一个路径上的点在和式中的出现次数，写出变化量和式即为$\sum (sum(1)-sum(z))^2-sum(y)^2=(deep(x)-deep(1)-1)sum(x)^2-2sum(1)\sum sum(cur)$。其中$\sum sum(cur)$表示从$x$到1且不包含1的路径上的点的子树和的和。
  
    综上发现线段树直接维护区间和以及区间平方和即可。

----

#### 虚树-Virtual Tree

虚树是求给定一棵树上的若干点，要求求出所有的点以及其两两之间的LCA构成的一棵联通树的算法。其求解的本质是用DFS序进行模拟DFS，以确定所有点以及其LCA之间的相对位置。首先对所有需要加入的点按照DFS序升序排序，维护一个栈，栈内存放深度递增顺序下的一条链的点编号。考虑每一次插入一个点，怎样维护这个栈：

+ 栈为空，直接把点加进栈内。一些情况下可以强行加入一个结点作为超级根，减少特判。
+ 栈不为空，栈顶是加入点的某一级祖先结点，那么只需要把点加进栈内。
+ 栈不为空，栈顶不是加入点的某一级祖先，那么需要弹栈，栈顶与栈顶上一个连边（特殊处理退出情况，后面会说），直到栈顶结点深度小于等于加入点为止退出。退出时若栈顶就是加入点与上一个弹出栈顶的LCA，那么直接在弹掉的栈顶与LCA之间加边，加入点入栈，否则需要先令LCA入栈，再执行弹出操作。

栈最终操作完成后需要再弹一遍栈，连上最后的边。

```C++
inline bool cmp(int x, int y) { return dfn[x] < dfn[y]; }
inline bool involve(int x, int y) {
	return (dfn[x] < dfn[y]) && (dfn[x] + siz[x] > dfn[y]);
}//involve用于判断某个结点是否在一个特定结点的子树里面
void build() {
	std::sort(p + 1, p + num + 1, cmp);
	stk[++top] = 1;
	for (int i = 1; i <= num; ++i) {
		if (involve(stk[top], p[i])) stk[++top] = p[i];
		else {
			while (1) {
				int tmp = stk[top--];//取出栈顶
				if (!involve(stk[top], p[i])) add(stk[top], tmp);
				else {
					int lca = LCA(tmp, p[i]);//判断栈顶下方元素是否为LCA，若不是则加入
					if (lca != stk[top]) stk[++top] = lca;
					add(stk[top], tmp), stk[++top] = p[i];
					break;
				}
			}
		}
	}
	while (top > 1) add(stk[top], stk[top - 1]), --top;
    top = 0;
}
```

由以上操作知虚树上面的总点数是$O(n)$的，更确切一点说，不会超过$2n-1$。

一般来讲虚树中点的编号都是可以预知的，且值域位于$[1,n]$内，所以可以使用基数排序优化。不做赘述。

+ 洛谷P4103 [HEOI2014]大工程

  里面套一个树形DP即可。最长路显然是树上直径，DP或贪心解决；最短路考虑上下端点均是关键点的路径以及在非关键点拼合的路径；代价总和就考虑每一条边的贡献即可。

+ 洛谷P2495 [SDOI2011]消耗战

  树上最小割只需要考虑DP，设$f(i)$表示以$i$为根的子树内，所有关键点都与$i$切断所需要的最小代价，那么只需要讨论当前点是否为关键点，以及切割的是子树内部的边还是与子树直接相连的边即可。

+ 洛谷P3233 [HNOI2014]世界树

+ 洛谷P4426 [HNOI/AHOI2018]毒瘤

----

#### 动态树-Dynamic Tree

用于维护一个森林，支持在树上断边，树之间加边，以及相应的链操作与查询。

+ LCT

  首先介绍实虚链剖分，类似于轻重链剖分与长链剖分，整棵树按照有根树形式存储，对一个点挑出至多一个子结点与其连边作为实边，其余的作为虚边存在，实边自上而下相连形成实链。与前两者不同的是，在对树形态进行调整的时候，也就是涉及了断边连边操作以后，实虚链会不断发生变化。

  考虑使用一个灵活的数据结构维护自上而下的实链，特别的，一个点看做是退化的实链，这里采用主流的Splay维护实链，维护一条实链的Splay称为原树的辅助树。Splay的中序遍历对应实链自上而下深度递增的序列。Splay的父结点与子结点记录的局限性不同，子结点的记录只用于对Splay的维护，但对于一棵单独维护一条链的辅助树：

  + 若这个结点是Splay的根结点，那么这个结点的父结点指向其在原树中所在实链的链顶的父结点。
  + 若这个结点是Splay的非根结点，那么这个结点的父结点指向其Splay中的父结点。

  那么容易看出对于一棵已经剖分好的原树，其对应辅助树可能会有多种。

  LCT的特点是“认父不认子”，所有原树中的虚边都体现在辅助树Splay根的父结点指针中。没有任何一个结点的儿子指针指向其向下的虚边。

  LCT的核心操作是$access$，所有的操作都需要在其基础之上完成。对于一个结点$x$，$access(x)$表示：把原树中根结点到$x$这条通路上所有的边都变成实边，这条实链由一棵辅助树维护，这棵辅助树的中序遍历以所在树的根为开头，以$x$为结尾。那么考虑若干条链的拼合，需要自下而上记录下方已经处理好的实链部分的辅助树，那么需要不断地寻找上方路径实链的中断点，把它在辅助树中双旋到辅助树的根，把其右儿子设为处理好的部分的根，更新所有信息（包括但不限于$pushup$以及更新处理完成的部分）以后再继续向上跳操作。

  然后比较重要的就是$makeroot$操作。其作用是把某个结点$x$转变成所在原树的根。首先执行$access(x)$，然后注意到根结点与$x$是中序遍历的头尾，那么只需要左右翻转这棵树，中序遍历开头就变成了$x$。那么只需要维护一个支持打翻转标记的$Splay$即可。

  由于标记的存在，并且由于Splay本身自下而上的操作顺序，需要先把Splay路径上面的所有标记下推完成再双旋上去。

  若是单纯的维护集合的合并（类并查集），需要一个函数来查找所在树的根结点，那么只需要下推标记以后寻找中序遍历最靠前的位置就可以了。

  对于查询与修改操作，若链端是$x$与$y$，只需要$makeroot(x)$以后$access(y)$，在辅助树上对应打标记或查询即可。

  对于涉及树形态变化的操作（$link$与$cut$），加边只需要增加一条虚边，断边需要进行单向子树指针置$0$，然后向上维护信息。注意若操作不一定合法，则需要检查是否存在对应边，或者两个点存在于不同的子树里。

  附：容易发现这个辅助树需要数据结构满足可以方便的维护序列，其实块状链表与FHQ-Treap均可实现，只不过Splay满足可以快速自下向上调整，其性质允许书写的时候极大地减少代码难度。

  ```c++
  int ch[maxn][2], fa[maxn], cnt;
  bool tag[maxn];
  inline void pushup(int cur) {
  	//something
  }
  inline void pushdown(int cur) {
  	//something
      if (!tag[cur]) return;
  	std::swap(ch[cur][0], ch[cur][1]), tag[cur] = 0;
  	tag[ch[cur][0]] ^= 1, tag[ch[cur][1]] ^= 1;
  }
  inline bool isroot(int cur) { return (cur != ch[fa[cur]][0]) && (cur != ch[fa[cur]][1]); }
  inline int getson(int cur) { return cur == ch[fa[cur]][1]; }
  inline bool isson(int x, int y) { return (ch[x][0] == y) | (ch[x][1] == y); }
  inline void rotate(int cur) {
  	int x = fa[cur], y = fa[x], z = (cur == ch[x][1]);
  	ch[x][z] = ch[cur][z ^ 1], ch[cur][z ^ 1] = x;
  	fa[x] = cur, fa[cur] = y, fa[ch[x][z]] = x;
  	if (y && isson(y, x)) ch[y][x == ch[y][1]] = cur;
  	pushup(x), pushup(cur);
  }
  void push(int cur) {
  	if (!cur) return;
  	if (!isroot(cur)) push(fa[cur]);
  	pushdown(cur);
  }
  inline void splay(int cur) {
  	push(cur);
  	while (cur && (!isroot(cur))) {
  		if (isroot(fa[cur]) && isson(fa[cur], cur)) rotate(cur);
  		else {
  			int f = fa[cur];
  			rotate(getson(f) == getson(fa[f]) ? f : cur), rotate(cur);
  		}
  	}
  }
  inline void access(int cur) {
  	for (int pre = 0; cur; pre = cur, cur = fa[cur]) {
  		splay(cur), ch[cur][1] = pre, pushup(cur);
  	}
  }
  inline void makeroot(int cur) { access(cur), splay(cur), tag[cur] ^= 1; }
  inline int findroot(int cur) {
  	access(cur), splay(cur);
  	while (ch[cur][0]) pushdown(cur), cur = ch[cur][0];
  	return cur;
  }
  inline void cut(int x, int y) {
  	makeroot(x), access(y), splay(y);
  	if ((findroot(y) != x) || (ch[y][0] != x) || ch[x][1]) return;
  	fa[x] = 0, ch[y][0] = 0, pushup(y);
  }
  inline void link(int x, int y) {
      makeroot(x);
      if (findroot(y) != x) fa[x] = y;
  }
  ```

  复杂度分析：

  + 例题1：洛谷P4172 [WC2006]水管局长
  + 例题2：洛谷P1501 [国家集训队]Tree II
  + 例题3：洛谷P2387 [NOI2014] 魔法森林
  + 例题4：洛谷P4338 [ZJOI2018]历史
  
+ ETT

+ Top Tree

----

#### 点分治&点分树

用于求解树上路径最优化/方案数问题。

+ 点分治

  首先把问题变得可以分治化，点分治时需要确定一个中心位置$x$，求解所有经过点$x$的路径，然后把一棵树分割成若干不连通的部分再分别求解。

  + Part1：若$x$所在树上连通块大小为$n$，那么如何在$O(n)$乃至$O(nlog^kn)$的复杂度内求解出所有经过$x$的路径。

    部分时候树形DP即可。或者说用一个数据结构维护已经处理完的子树内的点，然后进入一个子树合并路径更新答案，再把这个子树的信息整合进去更新；亦或者在某些条件下可以使用容斥计算方案数。都可以在线性或者$ploylog$的复杂度内求解所有经过$x$的路径。

  + Part2：考虑怎样确定中心位置$x$使得经过$x$的路径数目尽可能的多。

    首先来讲递归式$T(n)=O(n)+k\times T(\frac{n}{k})=O(nlog_kn)$，这意味着无论$k$取值是多少，其复杂度都是$ploylog$的，可以利用换底公式换掉$k$，复杂度可以统一写作$T(n)=O(nlogn)$。

    一般分治中心选择这棵树连通块的重心位置，树上重心满足：若连通块大小为$n$，那么以重心为连通块的根的时候，所有的子树大小都不超过$\lfloor \frac{n}{2} \rfloor$，同时最大子树大小最小。利用这个性质可以一遍树形DP求出这个位置：（其中$siz$记录子树大小，$son$记录以某个点为根的时候最大子树大小，$tot$记录当前连通块大小）

    ```C++
    int root, siz[maxn], son[maxn];
    bool visit[maxn];
    void get_root(int pos, int pre, int tot) {
    	siz[pos] = 1, son[pos] = 0;
    	for (int i = head[pos]; i; i = nxt[i]) {
    		if ((to[i] == pre) || visit[to[i]]) continue;
    		get_root(to[i], pos, tot);
    		siz[pos] += siz[to[i]];
    		if (siz[to[i]] > son[pos]) son[pos] = siz[to[i]];
    	}
    	son[pos] = std::max(son[pos], tot - siz[pos]);
    	if (son[pos] < son[root]) root = pos;
    }
    ```

    在重心性质的加持下，点分治复杂度为$T(n)=O(n)/O(nlogn)+k\times T(\lfloor \frac{n}{k} \rfloor)=O(nlogn)/O(nlog^2n)$。$k$是一个随树形态不同而变化的常数。

  + 例题1：洛谷P3806 【模板】点分治1

    注意到询问并不多，那么允许在连通块大小为$n$的情况下$O(nm)$处理过重心的所有路径，开桶记录所有过重心的路径长度即可。

  + 例题2：洛谷P4178 Tree

    利用这道题讲解一下容斥做法，首先把所有以重心为端点的路径都列举出来按照长度排序，那么从小到大枚举一条边的长度，然后单指针处理其有多少条边能与其拼合以后满足长度限制；显然会把来自于同一个子树的边拼合算重复，那么只需要对每个子树再做一遍上述过程，减掉即可。

  + 例题3：洛谷P4149 [IOI2011]Race

    开桶记录即可。

  + 例题4：洛谷P2664 树上游戏

    考虑如何计算经过一个点的颜色数，在连通块内首先处理所有以重心为端点的路径，然后考虑路径的拼合，在树上DFS时考虑当前到达的端点，对于某种颜色，考虑其能够出现在哪些路径中，即产生的贡献：

    + 这种颜色没有出现在重心到当前点的路径上，而是出现在别的子树里面，那么这种颜色在从重心到某个点的路径上第一次出现的时候，会产生这个点的子树大小的贡献。
  + 这种颜色出现在了重心到当前点的路径上，会产生连通块大小减子树大小的贡献。
  
    以上两种情况直接分类讨论，开桶记录即可。

  + 例题5：洛谷P4183 [USACO18JAN]Cow at Large P

  + 例题6：P3292 [SCOI2016]幸运数字

    将询问离线，分治处理出连通块内所有点到重心路径上的线性基，然后枚举所有连通块内的询问，暴力合并线性基计算答案即可。每个询问的一个端点至多被枚举递归树高度次，枚举询问的复杂度是$O(mlogn)$的，每个询问会被恰好处理一次。

+ 动态点分治

----

#### 边分治&边分树

----

#### 树分块-Top Cluster

---

#### 树形动态DP

----

### 维护图的数据结构

----

#### 圆方树

----

#### 支配树-Dominant Tree

---

#### 动态图-Dynamic Graph

----

### 根号分治专题

----

#### 模剩余系下标的求和

+ 例题1：洛谷P3396 哈希冲突

  题目要求求解$\sum_{i\mod p=x}value_i$，容易转化为枚举$k=\lfloor \frac{i}{p} \rfloor$的值，转化为$\sum_{i=0}^{\lfloor \frac{n-x}{p} \rfloor}value_{ip+x}$。对$p$的大小分类讨论：

  + 若$p> \sqrt{n}$，那么容易发现$\lfloor \frac{n-x}{p} \rfloor<\sqrt{n}$，也就是求和的位置不超过$\sqrt{n}$，直接维护原数组，枚举所有的位置求和即可。
  + 若$p\le \sqrt{n}$，额外设$sum(i,j)$表示$\sum_{x \mod i=j}value_x$，初始时枚举模数$O(n\sqrt{n})$预处理，涉及到的询问$O(1)$查询，修改时$O(\sqrt{n})$进行维护。
+ 例题2：洛谷P5309 [Ynoi2011] 初始化

  考虑对不同的模数产生的贡献分开来维护，类似于上面那道题，把模数分为两部分的贡献，每部分单独进行修改与求和，最终把两部分的结果加起来即可：

  + 若$p> \sqrt{n}$，就可以枚举所有发生变动的位置，变成一个$O(n\sqrt{n})$次单点加法，$O(m)$区间求和，用一个分块解决。

  + 若$p\le \sqrt{n}$，首先同上设$f(i,j)$表示$\sum_{x \mod i=j}z$，这里维护的是模$i$余$j$的位置的数值变化量，特殊的，这里$0 < j\le i$，用于规避特殊情况讨论（除法结果统一从0开始）。在求解区间和的时候，考虑把区间和转化为前缀和相减，如果要求解$[1,x]$这个前缀和的变化量，就需要同时枚举$ij$，考虑每一个$f(i,j)$对前缀的贡献（乘上出现次数求和），变成：
    $$
    \sum_{i=1}^{\sqrt{n}}\sum_{j=1}^{i}f(i,j)\times \lfloor \frac{x-j}{i}+1\rfloor,(x\ge j)
    $$
    此时考虑枚举每一个$i$，考虑后面那个下取整式子的情况：

    + 若$x\ mod\ i\ge j$，那么$\lfloor \frac{x-j}{i}+1\rfloor=\lfloor \frac{x}{i}\rfloor+1$。
    + 若$x\ mod\ i< j$，那么$\lfloor \frac{x-j}{i}+1\rfloor=\lfloor \frac{x}{i}\rfloor$。

    容易发现上面两个情况中，最终的结果与$j$无关，可以把因式提出来，转化为$f(i,j)$第二个维度的前后缀和，那么对于每个$p\le \sqrt{n}$的加法只需要维护$f(i,j)$以及它的前后缀和即可，单次修改$O(\sqrt{n})$。
+ 例题3：洛谷P7710 [Ynoi2077] stdmxeypz

----

#### 涉及元素出现次数的分治

众所周知若一个多重集大小为$n$，则内部出现次数大于$\sqrt{n}$的元素种类不会超过$\sqrt{n}$种，利用这个性质可以进行数据分治。

+ 例题1：洛谷P5268 [SNOI2017] 一个简单的询问

  设这个序列为$a$，对于全局出现次数大于$\sqrt{n}$的元素，一共不会超过$\sqrt{n}$种。暴力的枚举每一种元素，做前缀和，给每个询问都暴力枚举一遍。对于出现次数小于$\sqrt{n}$的元素，考虑二维偏序，也就是说建立一个$n\times n$的平面，平面上一点$(x,y)$的权值为$1$当且仅当$a[x]=a[y]$。显然固定一个$x$，令$(x,y)$处的值为$1$的$y$不超过$\sqrt{n}$个位置。直接枚举就可以。对于询问$[l,r]$，就是求解二维平面上$l\le x \le r$，$l\le y \le r$的矩形元素和。此时问题转化为有$O(n\sqrt{n})$个点，$O(m)$个询问的的二维偏序，用一个$O(1)$单点加法，$O(\sqrt{n})$的值域分块维护。

+ 例题2：洛谷P5072 [Ynoi2015] 盼君勿忘

  注意到这个形式就是考虑贡献，考虑一个元素$x$在多少个子序列里出现过，正难则反考虑全集减去不出现的情况，设这个区间的长度为$len$，$x$就在$(2^{len}-1)-(2^{len-cnt(x)}-1)=2^{len}-2^{len-cnt(x)}$这么多个序列中出现过，$cnt(x)$就是在这个询问区间内$x$出现的次数，这个区间的答案就是$x$乘上对应出现次数的和，也就是
  $$
  ans=(\sum_{x\in a[l,r]} x(2^{r-l+1}-2^{r-l+1-cnt(x)}))mod\ P
  $$
  考虑对出现次数进行分治，出现次数小于等于$\sqrt{n}$的元素，记录$sum(i)$表示出现次数为$i$的数的和，也就是按照出现次数相同的进行分类，统计时直接计算；出现次数大于$\sqrt{n}$的元素，全局记录多少数出现次数大于$\sqrt{n}$，显然不会超过$\sqrt{n}$个，直接枚举每一个的出现次数进行统计即可。出现次数以及求和可以用莫队直接维护，不同的模数采用光速幂根号打表实现。
  
+ 例题3：洛谷P5397 [Ynoi2018] 天降之物

  首先可以有一个等价操作，即把所有的$x$变成$y$可以等价转换成把所有的$y$变成$x$，然后以此维护一个映射，查询$y$只需要映射一下查询序列中的$x$。

  对所有的数维护链表记录在哪些位置出现，在没有修改的情况下，对于所有出现次数大于$\sqrt{n}$的数$i$，维护$ans(i,j)$表示$i$与整个序列中最近的$j$相距多远，把所有的$i$与整个序列做一个归并即可完成操作。查询的时候若两个数的出现次数小于等于$\sqrt{n}$则直接把两组数归并求解，否则可以直接查表。

  现增加修改，对于每一个出现次数大于$\sqrt{n}$的数维护一个附属集合，其作用会在后面提到。并且$ans$的含义会发生略微变动：$ans(i,j)$表示$i$除去其附属集合的部分到最近的$j$相距多远。

  考虑修改操作，若修改涉及到的两个数里面有至少一个未出现则直接映射即可。接下来考虑别的情况，称一个出现次数大于$\sqrt{n}$的为大数，反之为小数：

  + 小数合并入小数：若修改过后的出现次数仍然小于$O(\sqrt{n})$，则直接把两个链表归并合并，否则归并完以后计入大数，与整个序列做一遍归并更新$ans$。
  + 大数合并入小数：由于前面的等价操作，可以转化成小数合并入大数。
  + 小数合并入大数：大数的附属集合临时存储所有小数变成这个大数的位置，进行一遍归并维护进附属集合，需要额外用一下原数到所有大数的答案更新$ans$。若附属集合大小大于$\sqrt{n}$则重新做一遍全局归并，清空附属集合。
  + 大数合并入大数：直接全局归并即可。

  在有修改的情况下，小数与小数查询同无修改情况，至少一个是大数时，查表以后需要做小数与大数附属集合的归并，或者两个大数附属集合的归并取最小值。

  所有的操作可以利用摊还分析证明其复杂度是$O(n\sqrt{n})$的。

---

### 定期重构专题



---

### bitset专题

---

+ 使用方法
+ 例题

----

### STL容器专题

---

首先在这里列举STL容器中

----

#### 线性数据结构

+ stack

  STL自带的栈。可以支持如下功能：

  + `push(x)`，将$x$入栈
  + `pop()`，弹出栈顶元素
  + `top()`，查询栈顶元素
  
+ queue&deque

  STL自带的队列/双端队列。可以支持如下功能：

  + 

+ vector

  STL自带的动态数组。可以支持如下功能：

  + 

+ unordered_set&unordered_map

  STL自带的哈希表。可以支持如下功能：

  + 

----

#### 非线性数据结构

+ priority_queue

  STL自带的优先队列。底层使用堆实现。可以支持如下功能：

+ set

  STL自带的集合。底层使用红黑树实现。可以支持如下功能：

  + 

  在这些东西的基础上衍生出了一个神奇的数据结构：珂朵莉树。

+ map

  STL自带的映射。底层使用红黑树实现。可以支持如下功能：

+ multiset

  STL自带的可重集。底层使用红黑树实现。可以支持如下功能：

+ pbds

+ rope

----

### 字符串数据结构专题

----

#### 序列自动机-Sequence Automaton

----

#### AC自动机-Aho Corasick Automaton

用于多串匹配的求解。多串指的是多模板串单文本串。

首先把所有需要查找的子串插入一棵Trie树，然后在Trie树上面跑BFS，从根结点上面向下出发，对于每一个Trie树上的结点建立一个$fail$指针，表示最长的后缀失配指针，表示当前字符串在Trie树上面对应的字符串的最长真后缀的位置，那么可以逐层递推处理，放在图上就是使用一遍BFS实现。

首先初始化，Trie树上面根结点代表空串，然后向下第一层结点代表单字符，其最长真后缀显然是空串，其$fail$指针指向根结点即可。接下来考虑递推求解$fail$指针，类似以KMP算法求解$next$的过程，若结点$cur$对应最长后缀位置为$fail(cur)$，考虑$cur$的出边指向的一个结点$ver$，若出边代表字符$c$，且$fail(cur)$处也存在一个字符为$c$的出边，那么直接把$fail(ver)$指向$fail(cur)$的$c$出边指向的结点即可，否则就需要不断跳$fail$指针直到存在一个$c$的出边，指过去即可；若跳到根都没有$c$的出边，那么直接把$fail(ver)$设为根即可。其层序遍历使用BFS实现。

一般来讲不用反复的跳树查找最长真后缀，可以改变一下原先Trie树的子结点指针$ch$的含义，变换为：$ch[cur][c]$代表$cur$结点处增加一个字符$c$以后转移到的匹配位置在哪里。显然原来存在的边不再变化，只需要处理不存在的出边即可。考虑$fail$的含义，若结点的某条出边$ch[cur][x]$不存在，需要跳转到$ch[fail(cur)][x]$，即转移到在最长真后缀后面增加一个$x$所能到达的位置；否则更新$fail(ch[cur][x])$，其值也为$ch[fail(cur)][x]$，表示其最长真后缀所在位置。

给出一个字符集只有小写字母的AC自动机构建过程。

```C++
struct aho_corasick_automaton {
	int ch[maxn][26], fail[maxn], cnt;
	std::queue<int> q;
	inline void insert(char* c) {
		int len = std::strlen(c), pos = 0;
		for (int i = 0; i < len; ++i) {
			int ver = c[i] - 'A';
			if (!ch[pos][ver]) ch[pos][ver] = ++cnt;
			pos = ch[pos][ver];
		}
	}
	inline void build() {
		for (int i = 0; i < 26; ++i) if (ch[0][i]) q.push(ch[0][i]);
		while (q.size()) {
			int pos = q.front(); q.pop();
			for (int i = 0; i < 26; ++i) {
				if (!ch[pos][i]) ch[pos][i] = ch[fail[pos]][i];
				else fail[ch[pos][i]] = ch[fail[pos]][i], q.push(ch[pos][i]);
			}
		}
	}
};
```

+ 例题1：洛谷P2444 [POI2000]病毒

  构建出病毒代表字符串的AC自动机，在每个病毒代表字符串末尾处打标记，然后考虑匹配的过程就是在自动机上面不断地加边跳转，那么显然在有限图上走出一个无限长的路径就需要走环，并且走的过程中不能碰到标记点，消去不可达的位置以后判环即可。

  注意AC自动机做字符串匹配上面都存在一个问题：若在自动机上到了一个没有标记的位置，但这个位置所代表的字符串的某个后缀是一个代表病毒的字符串，这是因为$fail$指向的是最长跳转后缀，而非所有可能的后缀，故有些位置不能一步跳转到。这种情况也是不合法的，那么处理这一步只需要在建立自动机的时候特殊判断其$fail$指针对应后缀处是否有标记即可。

+ 例题2：洛谷P4052 [JSOI2007]文本生成器

  典型的AC自动机上面的DP。考虑正难则反，答案即为全集减去给定字符串集合全都不包含的方案数。设$f(i,j)$表示匹配到自动机上面$i$号点，当前字符串长度为$j$，没有碰到过任何给定字符串末尾的方案数。那么考虑在某个状态下，枚举下一步在字符串末尾添加哪些字符，转移到对应的状态即可。

  这道题也需要注意上面提到的后缀匹配问题，即$fail$指针以及标记处理的问题。

+ 例题3：洛谷P5357 【模板】AC 自动机（二次加强版）

  考虑在自动机上匹配字符串，若走到一个位置，其某个真后缀是给定模板串，那么就变成了例题1中提到的情况，需要不断跳$fail$检查是否有某个真后缀为模板串。

  注意到除了Trie树根结点以外的$fail$指针只存在一个出边，那么可以把$fail$看做是父向边，抽象成一棵树，每匹配一步，就在这棵树上一直跳到根，检查是否有后缀为模板串。容易看出是一个树上链加，并且不需要在线，使用树上差分实现即可。

+ 例题4：洛谷P3121 [USACO15FEB]Censoring G

  考虑匹配不合法信息的情况，匹配到不合法信息就删除以后重新匹配，重新匹配是不必要的，只需要开一个栈记录字符串每个位置对应匹配到自动机上哪个位置，压栈对应匹配一个字符，弹栈处理匹配到的不合法信息。最后输出这个栈即可。

+ 例题5：洛谷P2414 [NOI2011] 阿狸的打字机

  容易发现增删字符的过程可以等价转化为Trie树上面向上走或向下走操作，以此可以建出其对应的Trie树结构，然后考虑如何求解字符串A在B内出现的次数，由于问题的本质是匹配，故考虑先建出Trie树的AC自动机，考虑枚举B的每一个子串后缀，若B的某一个前缀子串以A为后缀，那么在对应AC自动机上不断跳$fail$，一定可以在若干次后跳到串A对应的结点。

  考虑固定一个A，枚举B的每一个后缀，按照例题3的做法建出$fail$对应的树形结构，本质就是求解A对应结点的子树内有多少B的后缀对应的结点，那么DFS整棵字典树，DFS的同时维护当前路径上的字符串的所有前缀，入栈的时候在子树内对应位置赋$1$，查询就只需要子树求和，使用DFS序加上一个支持单点修改区间求和的数据结构实现即可。

----

#### 后缀数组-Suffix Sort

用于将一个字符串的所有后缀按照字典序排序。

下文中所有的$sa(i)$均表示排名为$i$的后缀的首字符在原串内出现的位置，$rank(i)$表示原串内从第$i$个字符开始到串尾形成的后缀的排名，$suffix(i)$表示排名为$i$的后缀。

+ 倍增法

  首先介绍倍增的思想，考虑两个字符串的字典序比较，若两个字符串长度均为$2^k$，那么考虑把一个字符串分成等长的前后两个字符串，若已知这$4$个长度为$2^{k-1}$的字符串的排名，那么两个字符串的比较就变成了一个双关键字排序，即先比较前面，前面的排名一样再比较后面。要求解这几个短字符串的排名，则可以把字符串继续分割成前后变成一个子问题。考虑把这个求解的过程放到一整个字符串上面，即所有后缀的排名。容易发现，在一个字符串后面补充上任意多个字典序最小的字符，对后缀排名的答案不会有任何变化。

  考虑把这个问题递归转化为迭代求解，那么就不是从长到短求解而是从短到长，倍增的思想运用在这里。首先排序求解所有的单字符字典序排名，然后把单字符前后拼接，用上述双关键字排序求解所有长度为$2$的字符串排名，然后再求解所有长度为$4$的子串，以此类推直至所有的后缀字符串排名各不相同为止。

  然后观察这个双关键字排序，若直接利用快速排序则需要$O(nlog^2n)$，但其所具有的性质允许进一步优化。首轮排序依赖于字符集，可以直接桶排序预处理；后面的每一轮排序都不再依赖于字符集，每一次排序$n$个字符串，并且任何一个字符串的排名都不超过字符串总长$n$，由于其值域限制，可以使用基数排序优化至$O(nlogn)$。

  ```c++
  int n, k[maxn], rank[maxn];
  char c[maxn];
  struct str {
  	int k1, k2, id;
  	bool operator != (const str& x) const { return (k1 != x.k1) || (k2 != x.k2); }
  } s[maxn], t[maxn];
  inline void suffix_sort() {
  	int i, m;
  	for (i = 1; i <= n; ++i) s[i].k1 = c[i] - '0' + 1;
  	for (i = 1; i <= n; ++i) ++k[s[i].k1], s[i].id = i;
  	for (m = 75, i = 1; i <= m; ++i) k[i] += k[i - 1];
  	for (i = n; i >= 1; --i) t[k[s[i].k1]--] = s[i];
  	for (m = 0, i = 1; i <= n; ++i) rank[t[i].id] = (t[i] != t[i - 1]) ? ++m : m;
  	for (int len = 1; len <= n; len <<= 1) {
  		std::memset(k, 0, (m + 1) << 2);
  		for (i = 1; i <= n; ++i) s[i].k1 = rank[i], s[i].id = i;
  		for (i = 1; i <= n; ++i) ++k[s[i].k2 = rank[std::min(i + len, n + 1)]];
  		for (i = 1; i <= m; ++i) k[i] += k[i - 1];
  		for (i = n; i >= 1; --i) t[k[s[i].k2]--] = s[i];
  		std::memset(k, 0, (m + 1) << 2);
  		for (i = 1; i <= n; ++i) ++k[t[i].k1];
  		for (i = 1; i <= m; ++i) k[i] += k[i - 1];
  		for (i = n; i >= 1; --i) s[k[t[i].k1]--] = t[i];
  		for (m = 0, i = 1; i <= n; ++i) rank[s[i].id] = (s[i] != s[i - 1]) ? ++m : m;
  		if (m >= n) break;
  	}
  }

+ DC3法

+ SAIS算法

后缀数组求解出来以后可以快速得出一个字符串的任意两个后缀的LCP。首先介绍$height$，$height(i)$表示排名为$i$的后缀与排名为$i-1$的后缀的LCP。求解出这个以后可以用于快速求解任意两个后缀的LCP。

首先证明有关于$height$的若干性质。为了方便描述，以下将$Sa(i)$表示为排名为$i$的后缀。

+ Conclusion1：对于任意$1\le i < j \le n$，那么$LCP(sa(i),sa(j))$就等于长度$min_{i<k \le j}\{ height(k)\}$。

  这个结论是以下所有性质和优化求解的开端。可以把任意两个后缀的最长公共前缀问题转化为区间最小值的求解。

  网上的几乎所有证明都是从LCP Lemma开始的，即$LCP(Sa(i),Sa(j))=min_{i<k\le j}\{LCP(Sa(i),Sa(k)),LCP(Sa(k),Sa(j))\}$，笔者这里换一种介绍思路，考虑如何把$Sa(i)$修改成$Sa(i+1)$，那么一定是$Sa(i)$其中一个字符发生了变动，这个位置的字符增大后，后面的所有字符被替换成$Sa(i+1)$的后缀。这个过程可以使用归纳法递推证明：

  首先来讲$LCP(Sa(i),Sa(i+1))=height(i+1)$成立，作为归纳起点。

  然后假设$LCP(Sa(i),Sa(j))=min_{i<k \le j}\{ height(k)\}$，由此推到$LCP(Sa(i),Sa(j+1))$，设$x=LCP(Sa(i),Sa(j))$，由上面的过程知$Sa(i)$和$Sa(j)$的前$x$个字符相同，然后$x+1$个字符满足$Sa(i)_{x+1}<Sa(j)_{x+1}$，考虑$y=LCP(Sa(j),Sa(j+1))=height(j+1)$，讨论以下几种情况：

  + 若$y\ge x$，说明$Sa(i)$与修改成的$Sa(j+1)$的前$x$个字符仍然一样，且$Sa(i)_{x+1}<Sa(j+1)_{x+1}$成立（当$x=y$的时候会把第$x+1$个字符变得更大），$LCP(Sa(i),Sa(j+1))=LCP(Sa(i),Sa(j))$。
  + 若$y<x$，说明在第$x+1$个字符之前就已经出现一个位置$y$，使得$Sa(i)$与$Sa(j+1)$的前$y$个字符一样，且$Sa(i)_{y+1}<Sa(j+1)_{y+1}$成立，$LCP(Sa(i),Sa(j+1))=LCP(Sa(j),Sa(j+1))$。

  综上知道$LCP(Sa(i),Sa(j+1))=min\{LCP(Sa(i),Sa(j)),height(j+1)\}$，递归写开，也就是$LCP(Sa(i),Sa(j))=min_{i<k \le j}\{ height(k)\}$成立。

+ Conclusion2：$height(rank(i))\ge height(rank(i-1))-1$

  考虑枚举一个后缀$Sa(i)$，然后求解$LCP(Sa(i-1),Sa(i))=height(i)$：

  + 若$height(i)>0$，考虑把这两个后缀同时拿掉第一个字符，得到后缀$Sa(rank(sa(i-1)+1))$与后缀$Sa(rank(sa(i)+1))$。容易发现在$height(i)>0$的前提下，两个后缀仍然满足原有的比较大小关系，由于拿掉了第一个字符，由Conclusion1知$LCP(Sa(rank(sa(i-1)+1)),Sa(rank(sa(i)+1)))=height(i)-1$，由于LCP是取区间最小值，那么$height(rank(sa(i)+1))\ge height(i)-1$。
  + 若$height(i)=0$，那么下一步后显然有任意$height(i)\ge -1$成立。

  使用$sa(rank(i))=i$与$rank(sa(i))=i$换元即可得到结论。

  那么利用这个性质可以快速的求解$height$数组。只需要枚举原串从前向后的后缀，暴力的扩展即可。由摊还分析知总复杂度是$O(n)$的。复杂度证明略去。

  ```c++
  inline void calc_height() {
  	for (int i = 1, x = 0; i <= n; ++i) {
  		x -= x ? 1 : 0;
  		int j = sa[rank[i] - 1];
  		while (s[j + x] == s[i + x]) ++x;
  		height[rank[i]] = x;
  	}
  }

+ 例题1：洛谷P4051 [JSOI2007]字符加密

  显然把原串倍长一下放到后面，其所有长度为$n$的子串包含了所有轮换，对这个倍长后的串做后缀排序，枚举长度大于等于$n$的后缀即可。

+ 例题2：洛谷P2408 不同子串个数

  考虑按照后缀的排名枚举每一个后缀，每个后缀的所有前缀就是原串的子串集合。考虑一个新的后缀能够产生多少新的本质不同的前缀，那么会发现对于后缀$Sa(i)$，其能增加的量就是$|Sa(i)|-height(i)$，那么总答案就是$\frac{|S|(|S|+1)}{2}-\sum_{i=2}^{|S|}height(i)$。

+ 例题3：洛谷P4248 [AHOI2013]差异

+ 例题4：洛谷P2178 [NOI2015] 品酒大会

----

#### 后缀自动机-Suffix Automaton

后缀自动机用于实现将一个字符串的所有后缀放在一个自动机上，只使用线性级别的时空复杂度。

对于一个字符串，定义其某个子串的$endpos$为其所有出现位置的最后一个字符所在位置的并集，称所有$endpos$一样的串的集合为$endpos$等价类。容易发现一个字符串$S$至多有$O(|S|^2)$级别的本质不同的不同的子串，但接下来要证明，这$O(|S|^2)$个子串至多有$2|S|-1$种本质不同的$endpos$集合。接下来要说明若干结论：

+ Conclusion1：对于任意两个子串$s_1s_2$，若满足$endpos(s_1)=endpos(s_2)$，并且$|s_1|<|s_2|$，那么$s_1$是$s_2$的后缀。

  考虑关注$s_2$，然后每一次删除$s_2$最前面的一个字符得到一个$s_2$的后缀$s_2'$，显然满足$endpos(s_2) \subseteq endpos(s_2')$，当集合不发生变化的时候，就是上述命题。

+ Conclusion2：若两个子串满足$|s_1|<|s_2|$，那么要么$endpos(s_2)\subseteq endpos(s_1)$，要么$endpos(s1) \cap endpos(s2)=\empty$。

  

+ Conclusion3：对于一个$endpos$等价类，若把所有的子串从长到短排序，那么任何一个串一定是前一个串的后缀，且其长度为上个串减$1$。也就是说字符串的长度递降且长度连续，没有间断。

+ Conclusion4：依据所有不同的$endpos$等价类，按照集合的包含关系，若$endpos(s1) \subseteq endpos(s_2)$且不存在$s_3$使得$endpos(s_1) \subseteq endpos(s_3) \subseteq endpos(s_2)$，那么将$endpos$等价类抽象成点，从$endpos(s_1)$向$endpos(s_2)$连一条边，那么所有的边和点一同构成一棵树。设一个$endpos$等价类中最长的那个串长度为$len(i)$，那么这棵树满足，这棵树称为parent tree。

+ Conclusion5：若一个串$S$长度为$|S|$，那么其所有本质不同的$endpos$集合的数目是$O(|S|)$的。

这些结论作为后缀自动机复杂度以及正确性的支撑。接下来讲解如何构建后缀自动机。

后缀自动机的构建依赖于parent tree，对于一个后缀自动机以及其唯一对应的一棵parent tree，自动机结点与树上的结点一一对应，且从初始状态经过自动机上的若干边到达结点$cur$形成的字符串集合，与$cur$对应在parent tree上的字符串集合相同。



```c++
struct suffix_automaton {
	map<char, int> o[maxn];
	int las, cnt, len[maxn], link[maxn];
	sufffix_Automaton() { link[0] = -1; }
	inline void extend(char c) {
		int now = ++cnt, pos = las;
		len[now] = len[las] + 1, las = now;
		while ((o[pos].find(c) == o[pos].end()) && (~pos)) {
			o[pos][c] = now, pos = link[pos];
		}
		if (~pos) {
			int ver = o[pos][c];
			if (len[ver] == len[pos] + 1) link[now] = ver;
			else {
				int cpy = ++cnt;
				link[cpy] = link[ver], o[cpy] = o[ver], len[cpy] = len[pos] + 1;
				link[ver] = cpy, link[now] = cpy;
				while ((o[pos].find(c) != o[pos].end()) && (o[pos][c] == ver)) {
					o[pos][c] = cpy, pos = link[pos];
					if (!(~pos)) break;
				}
			}
		}
	}
};
```



----

#### 后缀树-Suffix Tree

----

#### 后缀平衡树-Suffix Balanced Tree

----

#### 回文自动机-Palindromic Automaton

又称之为回文树，是一个有两个树形结构的图。用于记录一个字符串的所有回文子串。

在回文自动机中，可以借助其构造过程中的特点来阐述回文字符串的诸多性质。

回文自动机之所以有两个树形结构，是为了便于分开长度为奇数或为偶数的回文串。对于长度为奇数的回文串，读取方法为：把从根结点到某一个结点上面的边代表的字符自上而下连接起来形成字符串，以第一个字符为对称轴翻转得到这个回文串；偶数则需要直接翻转拼接在前面。为了易于构造，引入“最长回文后缀”这个概念，也即一个回文串的真子串，使得这个串既是后缀也是回文的，并且没有比它更长串的满足前两个性质，类比于AC自动机，称这个跳转指针为$fail$指针。

回文自动机可以在线构造，也就是不断地往末尾加入字符，每插入一个字符就更新自动机的形态。初始时有两个结点，称为奇根与偶根，其中奇根长度为$-1$，偶根长度为$0$，认为偶根为$0$号点，奇根为$1$号点。任何一个非空回文串的长度就是其本身的长度，奇根的$fail$不存在，偶根的$fail$指向奇根，易于后面的操作。

设已经建立好前$n$个字符的回文自动机，并且记录好其最长回文后缀在自动机上的位置，考虑在末尾新加入一个字符$c$，那么会产生的新回文子串只有可能是新字符串的后缀。此时从前$n$个字符的最长回文后缀开始，不断在回文自动机上跳$fail$遍历后缀回文串，直到前$n$个字符的某一个回文后缀前是一个字符$c$，那么此时就确定了新字符串的最长回文后缀。若这个回文后缀对应在自动机上存在一条$c$的出边，说明原来已经存在了这个回文后缀，不需要再处理。现讨论不存在新最长回文后缀的情况。

当已经确定新的最长回文后缀以后，就不再需要继续跳$fail$查询更短的回文后缀了，按照最长回文后缀的性质，更短的回文后缀已经在前面被处理，不需要再额外进行下去了。由这个可以推出，一个字符串的所有本质不同的回文子串数量是$O(|S|)$的。

有可能在某种极端情况下，前$n$个字符里面没有字符$c$，那么认为任何子串的回文后缀都包含空串，那么一定会在某一次跳转$fail$时到达偶根，然后跳转到奇根，由于奇根长度恒为$-1$，代表新加入的字符本身，所以奇根是一定不会失配的，此时最长回文后缀就是这个字符本身。

定位最长回文后缀以后，需要维护其对应$fail$指针的值以及长度，长度直接为父结点长度加$2$，然后就是继续跳新最长回文后缀的一个最长回文真后缀接过去。若跳到奇根则代表其最长回文真后缀就是单字符，按照上述操作以后仍满足自动机结点性质。然后维护其父结点与其关系即可。

```C++
struct palindromic_automaton {
	int ch[maxn][26], fail[maxn], len[maxn], las, cnt;
	char s[maxn];
	palindromic_automaton() {
		len[cnt = 0] = 0, fail[0] = 1, len[++cnt] = -1, fail[las = 1] = 1;
	}
	inline int find(int pos, int now) {
		while (s[now - len[pos] - 1] != s[now]) pos = fail[pos];
		return pos;
	}
	inline void extend(char c, int now) {
		int cur = find(las, now);
		if (!ch[cur][c - 'a']) {
			fail[++cnt] = ch[find(fail[cur], now)][c - 'a'];
			ch[cur][c - 'a'] = cnt;
			len[las = cnt] = len[cur] + 2;
		}
		else las = ch[cur][c - 'a'];
	}
};
```

复杂度分析：其复杂度只有寻找最长回文后缀这一部分需要摊还分析，其余的部分显然是$O(|S|)$的。注意到回文自动机本质上修建了两类树，一类是自动机本身代表的回文串，另一部分是$fail$指针构成的隐式的树形结构。寻找最长回文后缀时，每一次跳$fail$指针都会让最长回文后缀长度下降至少$1$，然后新加入一个字符会让新最长回文后缀长度至多增加$2$，本质是在回文树上向上跳，每跳$2$次其深度至少减少$1$，然后走到一个结点的某个子结点使深度加$1$。对于维护新后缀的$fail$指针，本质是在$fail$树上面跳，找到父结点并生成子结点，复杂度分析是一致的。故跳$fail$指针的总量是$O(|S|)$的，其总时间复杂度为$O(|S|)$。

+ 例题1：洛谷P5496 【模板】回文自动机（PAM）

  对于建好的回文自动机，某个前缀的的回文后缀，可以从其最长回文后缀开始，不断的跳$fail$指针直到偶根，每一个非偶很结点都代表了一个回文后缀，容易发现由于跳转的是最长真回文后缀，所以这个统计的过程不重不漏。并且$fail$指针之间形成一棵树，回文后缀的数目其实就是其$fail$树上对应结点的深度，直接维护$fail$树即可。

+ 例题2：洛谷P4287 [SHOI2011]双倍回文

  考虑修建这个串的回文自动机，枚举所有本质不同的偶数长度的回文串，用$fail$数组查出是否存在一个长度为其一半的真后缀回文串，且长度为偶数。由于$fail$构成树形结构，所以变成枚举一个回文串，检查$fail$树的子树内是否存在一个长度为$2$倍的回文串。用任意一种维护子树信息的方式维护即可。

+ 例题3：洛谷P4555 [国家集训队]最长双回文串

  一正一反建出两个回文自动机，每个位置记录最长回文后缀以及最长回文前缀，枚举一个分界点合并前后答案即可。

+ 例题4：洛谷P3649 [APIO2014]回文串

  建出这个字符串的回文自动机，考虑枚举每一个前缀的最长回文后缀，然后不断跳$fail$指针维护其真回文后缀的出现次数，容易发现这个过程的本质是树上某个结点到根的路径加法，打标记后树上差分实现。然后暴力枚举所有的回文子串统计最大值即可。

+ 例题5：洛谷P5685 [JSOI2013]快乐的 JYY

  建出两个回文自动机，树上差分统计所有的回文子串出现次数，然后在两棵回文树上同时向下DFS，统计出现次数乘积之和即可。

---

### 附录1：利用主定理计算时间复杂度

考虑计算以下递归式的时间复杂度：
$$
T(n)=aT(\frac{n}{b})+f(n)
$$
其中$f(n)$为一个多项式有界函数，即存在常数$c$、$k$与$n_0$，使得对于任意的$n>n_0$，$f(n)<c\times n^k$；$T(n)$在$n$很小的时候为有限值，可以看做是常数。那么由递归树每一层求和得到
$$
T(n)=\sum_{i=0}^{log_bn}f(\frac{n}{b^i})a^i
$$
为了便于计算，令$f(n)=O(n^k)$，代入得到
$$
T(n)=\sum_{i=0}^{log_bn}O(\frac{n^ka^i}{b^{ik}})=O(n^k \sum_{i=0}^{log_bn}(\frac{a}{b^k})^i)
=O(n^k\times \frac{(\frac{a}{b^k})^{log_bn+1}-1}{(\frac{a}{b^k})-1})
$$
接下来分三种情况讨论：

+ 当$a=b^k$的时候，$T(n)=O(n^klog_bn)$。

+ 当$a<b^k$的时候，即$log_ba<k$，此时有一个所谓的“正则条件”，也就是对于足够大的$n$，存在一个$0<c<1$使得$af(\frac{n}{b})\le cf(n)$。也就是说上述条件还不能用于计算类似于$T(n)=2T(\frac{n}{2})+O(nlogn)$的递归式。那么在这种情况下，可以放缩：
  $$
  T(n)=\sum_{i=0}^{log_bn}f(\frac{n}{b^i})a^i
  \le\sum_{i=0}^{log_bn}f(n)c^i
  =f(n)(1+c\frac{1-c^{log_bn-1}}{1-c})
  \le f(n)(1+\frac{c}{1-c})
  =O(f(n))
  $$
  对应复杂度被$O(n^k)$支配。

+ 当$a>b^k$的时候，对应复杂度被$O(n^{log_ba})$支配的情况。

但实际上，我们可以证明，正则条件成立的时候本身就意味着$f(n)$渐进支配$n^{log_ba}$，不做赘述。

---

### 附录2：势能分析法计算时间复杂度

有时候数据结构的形态发生变化时，需要耗费一定的代价进行结构上的调整，例如Splay的旋转到树根，替罪羊树的重构。有时候单次操作复杂度可能会很高，但是经过一些特殊的手法进行分析，可以求解出总复杂度是在可以接受的范围内。以下将会使用一些例子来阐述什么是势能分析。

势能可以理解为未来数据结构进行调整需要耗费的代价，任何时刻势能非负，数据结构进行额外调整所需要的代价全部从势能中扣除，只要我们在一次操作后合理增加势能，就可以保证未来开销的合理性。当然这个概念并不局限于数据结构，还有许多类似可以进行的分析。举一个现实中的例子，每天往银行里存入1块钱，然后时不时地从银行里把钱取出来，并保证没有欠债，那么取出来的钱不会超过存入钱的总量。几乎所有的数据结构都可以用类似的分析手段。

+ Sample1：二进制加法计数器递增的分析	

  大概意思就是，存在一个二进制数，每一次操作的含义为让这个二进制数加1，容易发现总的代价为01位的变化量和操作总量。

  定义这个二进制计数器的势能$\Phi(S)$为当前计数器内有多少位为1，容易发现二进制计数器的本质是，推平这个二进制数的最低位的连续一段1，然后把下一个0变成1。为方便分析，我们默认从0开始计数，那么以此为基础进行归纳：

  + 势能的增加手段为：每一次给计数器加1的操作让势能加1，然后在此基础上证明势能永远非负：
  + 初始状态下，计数器为0，势能为0，成立。
  + 在势能等于计数器中1的个数的前提下，每一次推平最低位的极长1段，这时候势能下降数值为这段1的长度，然后把下一位赋为1，势能增加1，增加的1对应于上述给计数器加1的时候顺带增加了势能。

  容易发现势能永远非负，进而知道势能下降总量不超过增加量，容易知道每一次操作中固定进行一次赋1，这个代价总量是$O(m)$的，然后势能总的增加量是$m$，那么总的推平1的代价不超过$m$，那么总的维护代价是$O(m)$，更严格来说，维护代价不超过$2m-1$，若感兴趣可进行自证。

+ Sample2：栈与队列多次弹出的分析

  这个题目的含义是，维护栈或者队列（按照以下的分析可以看出这一条同样适用于双指针），考虑栈内元素个数作为势函数，

+ Sample3：动态数组的扩张与收缩

  有这样一个问题，

---

### 附录3：
