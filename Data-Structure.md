# 有关各种数据结构&求解思想及应用

by Luan_233

#### 线性数据结构

+ 栈
  + 表达式的求值
  + 单调栈
  + 线性建笛卡尔树
+ 队列
  + 单调队列
+ 哈希表

#### 维护区间的数据结构

+ 树状数组

+ 线段树

  + 定长01序列的操作&标记技巧

    常见的操作有区间赋值，区间异或1，区间求和，区间最长0/1段长度，使用维护序列的数据结构均可完成。

    标记记录区间覆盖、区间是否被异或过，打标记的时候考虑所有的先前情况，合并时候按照题目需求，记录区间0/1数量、左0/1长度、右0/1长度、区间最长0/1长度。

    例题：洛谷P2894 [USACO08FEB]Hotel G、洛谷P2572 [SCOI2010]序列操作、洛谷P3968 [TJOI2014]电源插排、洛谷P4344 [SHOI2015]脑洞治疗仪

+ 高维区间数据结构：

  + 二维树状数组
  + 二维线段树
  + KD-Tree

#### 维护集合的数据结构

+ 堆

+ Treap

  每个二叉树结点记录一个随机出来的优先级，单点插入删除只需要进行左旋右旋保证堆性质。

  复杂度分析：

+ Scapegoat-Tree

  每个二叉树结点记录子树的$size$，设定一个阈值$\alpha$，我们认为一个结点不平衡当且仅当$\frac{max(size(ls),size(rs))}{size} > \alpha$，在插入时候若不平衡，则取出中序遍历按照建立二叉树的方式重构子树。一般$\alpha$取值在$0.75-0.85$。

  复杂度分析：设势能函数
  $$
  \phi(T)=c\sum_{cur \in T} |size(cur.ls)-size(cur.rs)|
  $$
  其中$c$是一个与$\alpha$有关的常数，容易证明一棵替罪羊树的高度一定是对数级别的，考虑一次插入一个点会最多给势能提升多少，显然是$c$倍的树的高度，是$O(logn)$的。一棵子树重构以后这个结点以及它所有的子结点的势能函数变成0，此时容易发现对于一个被重构的结点，我们用O(n)的代价让势能函数减少了$(2\alpha-1)cn$，此时只需要调结$c$的大小，使得其能够支配住重构过程的常数即可。容易发现每次不用连续重构自上而下的一段结点，只需要重构最上方的不平衡结点即可，此时重构常数极大减小。

#### 维护动态序列的数据结构

+ Splay

  允许很方便的把一个结点转到根。

+ FHQ-Treap

  

+ 块状链表

  

+ WBLT

  奇怪的数据结构，复杂度不对但是跑得很快，好写，难卡。

#### 可持久化数据结构

+ 可持久化线段树

+ 可持久化平衡树

+ 可持久化可并堆

  应用：K短路

#### 区间第K大&区间K大值

+ 划分树

+ 可持久化线段树（见可持久化数据结构版块）

+ 树套树

  说白了就是外面一个维护序列的数据结构，里面一个维护集合的数据结构。具体而言就是维护序列的数据结构的每个结点都需要维护这个结点所代表的区间内所有元素的可重集。

  除了内层是权值线段树以外的区间第K大都需要多一个$log$，因为权值线段树虽然可能由于动态开点的缘故形态不同，但是每个不同的树上对应结点的代表区间一致，所以可以在若干棵线段树上同时二分向下走，省去了每一次再跑一遍外层数据结构的复杂度。

  | 数据结构类型            | 空间复杂度     | 单点修改时间复杂度 | 区间x的排名   | 区间第K大       |
  | ----------------------- | -------------- | ------------------ | ------------- | --------------- |
  | 树状数组/线段树套平衡树 | $O(nlogn)$     | $O(log^2n)$        | $O(log^2n)$   | $O(logVlog^2n)$ |
  | 树状数组套权值线段树    | $O(nlogVlogn)$ | $O(logVlogn)$      | $O(logVlogn)$ | $O(logVlogn)$   |

+ 整体二分

  + 单点修改，区间第K大。（洛谷P2617 Dynamic Rankings）

    将序列中的每个初始的数表示为单点插入，然后将询问与修改都放进一个大数组里一起操作。询问的形式就是求解一个区间的第K大，序列初始化的形式变为单点增加一个数，修改的形式是单点移除一个数再加入另一个数。所有的操作以时间顺序递增。

    在我们已知所有的元素的取值范围以及所有的操作区间以后，设函数$solve(L,R,l,r)$表示当前处理所有的修改以及询问的值域均位于区间$[L,R]$内，这一部分在所有的操作序列$[l,r]$中。预先开好一个允许单点加区间求和的数据结构，以及两个栈用来分离操作，考虑二分法检查答案，令$mid=\lfloor \frac{R+L}{2} \rfloor$，然后从$l$到$r$枚举操作，若此时对应的增加/移除操作，且这个操作的权值小于等于$mid$，就在一个新的数组内把这个位置的值增加/减少1；若遇到查询操作，

  + 别的整体二分题目：洛谷P3332 [ZJOI2013]K大数查询、洛谷P1527 [国家集训队]矩阵乘法、洛谷P3527 [POI2011]MET-Meteors、洛谷P4175 [CTSC2008]网络管理、洛谷P7424 [THUPC2017] 天天爱射击

+ 树状数组二分

  好像不是很实用，用于求解一个可重集的第K小元素，

+ 值域分块

  一般要套序列分块一起使用，一般用$cnt1(i,j)$表示前$i$个块内j出现了多少次，$cnt2(i,j)$表示前$i$个块内值域有多少数位于值域的第$j$个块内，然后零散部分（如果询问跨块，那么零散部分就是左右两端，否则就是询问的序列）记录$cnt3(i)$为零散部分有多少$i$，$cnt4(i)$为零散部分有多少数落入值域块$i$，然后从小到大枚举值域块，类似于线段树二分，如果定位了某个块就枚举这个值域块内部的元素，求解完成后撤销零散块贡献。

  例题：区间x变y，区间K小值（洛谷P4119 [Ynoi2018] 未来日记）

  解法：首先按照上面说的进行序列与值域分块，然后每个块记录一个映射，$f1(i)$表示当前块内$i$代表什么数，$f2(i)$表示当前块内什么数代表$i$，然后零散块修改直接重构，记录块内有多少$x$，整块考虑三种情况：

  + 没有$x$，那么直接跳过；
  + 有$x$，没有$y$，直接用上面提到的$f1$、$f2$进行映射，同时记录块内有多少个$x$；
  + 有$x$，有$y$，直接重构这个块，记录块内有多少$x$。

  然后对于修改，记录每个块有多少$x$被修改，求一个前缀和后对$cnt1$、$cnt2$进行修改维护。

  这个复杂度看起来是假的，但实际上仍然是$O(n \sqrt{n})$的（认为序列长度与询问量同阶），考虑一个整块的重构会用$O(\sqrt{n})$的代价将这个块内的数字种类减1，而一个块的数字种类至多是$\sqrt{n}$个，只有一次零散块的重构才会给这个数增加1，零散块的重构次数不超过$2n$，所以总的重构次数不会超过$O(n+m)$，总的重构代价与总复杂度渐进表示一致。

#### 集合合并

+ 并查集

  介绍若干种并查集使用手法以及适于求解的问题

  + 路径压缩
  + 按秩合并
  + 带有偏移量的并查集
  + 实体化的并查集应用：克鲁斯卡尔重构树

+ 启发式合并

  + 例题1：洛谷P3302 [SDOI2013]森林
  + 例题2：洛谷P3201 [HNOI2009] 梦幻布丁

+ 线段树合并

  首先要知道线段树合并的

#### 矩阵&K维空间上的操作&扫描线

+ 偏序

  + 平面数点问题
    + 例题1：洛谷P2163 [SHOI2007]园丁的烦恼
    
  + 三维以及更高维的偏序

    + cdq分治法：
    + 分治嵌套法：
    + 树套树法：
    + bitset暴力法：
    + KD-Tree法：

  + 一类有限制DP的优化

    + 例题1：最长上升子序列问题

      

    + 例题2：P3431 [POI2005]AUT-The Bus

+ 单点修改矩阵求和

  + 允许离线：cdq分治板题，容斥一下转化成，xyT三个维度的偏序问题。
  + 强制在线：
    + KD-Tree解法：
    + 能够卡空间的线段树动态开点：
  
+ 矩阵加矩阵求和

  这是一个经典树状数组套路了，首先一步简单容斥转化为$[1,1]$到$[x,y]$上面的矩阵加矩阵求和，考虑沿用一维树状数组的思路进行差分，考虑弱化问题矩阵加法单点修改，假设左上角为$[x1,y1]$，右下角为$[x2,y2]$，差分修改为$[x1,y1]$、$[x2+1,y2+1]$加1，$[x1,y2+1]$、$[x2+1,y1]$减1，单点查询变为二维前缀和；然后考虑把这些单点信息加起来。设差分数组为$a[i,j]$，则考虑每个差分数组的元素会被多少个单点计算到，得到二维前缀和：
  $$
  ans=\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j]\times(x-i+1)\times(y-j+1) \\
  =\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j]\times(xy-x(j-1)-y(i-1)+(i-1)(j-1))\\
  =xy\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j]-x\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j](j-1)-y\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j](i-1)+\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j](i-1)(j-1)
  $$
  于是记录差分数组以及上面衍生出来的四个数组，四个二维树状数组维护即可。

+ 矩阵最值相关
  + 例题1：矩阵赋值矩阵最大值，保证赋值具有单调性
  + 例题2：矩阵加矩阵max，所有的询问都放在操作后面
  
+ 平面图形面积&周长求解

  + 图形面积：
  + 图形周长：

+ 特殊要求覆盖的求解例题

  + 例题1：洛谷P3997 [SHOI2013]扇形面积并

+ 可以转化成平面矩阵求和的问题

  + 例题1：洛谷P3246 [HNOI2016]序列

    首先有考虑贡献的套路，设这个序列为$a$，考虑每一个位置能够成为多少个区间的最小值，对于相同元素，我们令一个子段的最小值是这一段的最小值中最靠左的。那么利用单调栈处理出左面第一个小于等于当前位置的值的位置，以及右面第一个小于当前值的位置。设位置$i$能够向左最多延伸到$left(i)$，向右最多延伸到$right(i)$，我们可以定义一个二维平面，位置$(x,y)$上面的值是$a[x...y]$中的最小值，显然对于序列中的每个元素，平面中$left(i)\le x \le i$，$i\le y \le right(i)$的值就是$a[i]$。依然沿用

#### DP优化

+ 单调队列优化DP
+ 线段树优化DP
+ 可并堆优化DP
+ 动态DP

#### 调整型贪心的数据结构优化

+ 例题1：
+ 

#### 悬线法



#### 各种莫队的复杂度分析&优化&适用范围

+ 普通莫队
  + 适用范围：一些可以在$O(nm)$复杂度下暴力求解的区间询问题目，可以在已知一个区间信息以及这个区间的答案的情况下$O(1)$扩展到相邻区间。不带修改，允许离线。
  + 实现方式：将所有的询问排序，对序列分块，以左端点所在块为第一关键字升序排序，右端点为第二关键字升序排序，维护两个指针左右移动，做完一个询问就暴力移动指针维护区间的信息与答案至下一个询问。
  + 复杂度证明：
  + 例题：洛谷P1494 [国家集训队]小Z的袜子、洛谷P2709 小B的询问、洛谷P3730 曼哈顿交易、洛谷P4137 Rmq Problem / mex、洛谷P4396 [AHOI2013]作业、洛谷P4462 [CQOI2018]异或序列
+ 带修莫队
  + 适用范围：
  + 复杂度证明：
  + 例题：洛谷P1903 [国家集训队]数颜色
  + 扩展至高维形式的复杂度：
+ 回滚莫队
  + 适用范围：
  + 例题：
+ 树上莫队
  + 适用范围：
  + 例题：
+ 二次离线莫队
  + 适用范围：
  + 例题：
+ 莫队的常数优化技巧
  + 优化1：调节块长。这个比较玄学。优化效果取决于各种地方的实现方式。一般情况下建议块长比$\sqrt{n}$略小一些。但不排除某些题目中询问量与序列长度数量级差别较大的情况。
  + 优化2：考虑对于左端点落在一个块内的询问，其右端点指针一定是向右移动的；在左端点移向下一个块的时候，右端点指针会大概率向左移动到此块第一个询问处，如果能够在这个左移的过程中处理掉所有的询问，而不是左移以后再右移去处理询问，常数会获得一定程度的优化。具体实现起来，以左端点所在块为第一关键字，右端点为第二关键字，左端点所在块的下标为奇数的时候，右端点升序排序，反之降序排序。

#### 树上路径&子树相关的问题

+ 树链剖分
  + 轻重链剖分

    考虑dfs的时候记录dfs序，把尽可能多的点放在一条自上而下dfs序连续的一段上面，使得我们可以用维护序列的数据结构维护树上路径，考虑每个非叶子结点向下连一条边，称为重边，这条边指向的结点称作重儿子；其余的指向子结点的边称为轻边，与此对应称这些子结点为轻儿子。连续的重边自上而下连接在一起，称为重链。当我们dfs时访问到一个有重儿子的结点，那么优先访问重儿子，再访问轻儿子，让一条重链的dfs序自上而下连续递增。

    考虑链上的操作可以通过dfs序映射到一个序列上，一条重链对应一个连续的区间，特别的我们认为没有重儿子的结点算作长度为1的重链，那么我们考虑如何让每个点到根上的路径中，轻重链切换次数最少。方案是把最子树大小最大的子结点设为重儿子，在这种情况下每个结点到根结点的轻重链切换次数为$O(logn)$。

    这个复杂度证明比较简单，考虑从一个结点向上走，这个结点指向父结点的边是轻边当且仅当存在一个兄弟结点，这个兄弟结点的子树大小大于等于这个结点的子树大小。显然这个时候向上走一步，子树大小会至少翻一倍，至多翻倍的次数是对数级别的，也就是说每个结点到根结点的轻重链切换次数都是$O(logn)$的。

    具体实现的时候需要实现两个dfs。第一遍dfs，预处理出这棵树每个点的父结点、结点深度、子树大小、重儿子是谁，第二个dfs需要记录先序dfs序、每个重链中的结点的链顶结点编号。链上操作只需要不断跳重链就可以实现。

  + 长链剖分

    类似于重链剖分，惟一的区别是重儿子指向的是向下能够走出路径最长的一个子节点，类似的可以分析出每个结点到根结点的轻重链切换次数都是$O(\sqrt{n})$的。

    应用：DP优化、K级祖先查找优化

    + 快速求K级祖先

    + 树形DP优化
  
+ 树上差分

+ 树上换根问题

  大多数的换根都是唬人的，都只需要考虑dfs序上面的操作。

  + 例题1：洛谷P3979 遥远的过度

    链覆盖可以直接树剖解决，主要讨论树剖过后的换根子树查询。假设我们以1作为树剖的根，讨论换完以后根不是1的情况。假设换过以后的根是$root$，要查询的子树以$x$为根：

    + $lca(x,root)=root$：说明在以1为根的时候，$x$在$root$的子树里面，对应$[dfn[x],dfn[x]+size[x]-1]$。
    + $lca(x,root)=x$：说明$root$在$x$的子树里面，此时用倍增法求出$root$的某个祖先$y$，使得$fa[y]=x$，可以看出此时对应的区间是全局剔除$[dfn[y],dfn[y]+size[y]-1]$这部分，即$[1,dfn[y]-1]与[dfn[y]+size[y],n]$两部分。
    + 以上两种情况以外：对应$[dfn[x],dfn[x]+size[x]-1]$。

  + 例题2：洛谷P4689 [Ynoi2016] 这是我自己的发明

    看明白了换根的思路，其实这个是版块“根号分治”里面数点问题。dfs序把树拍成序列，然后沿用出现次数少的用二维偏序，出现次数多的前缀和统计的思路就可以了。

+ 树上直径

+ 树上启发式合并

+ 虚树

+ 动态树
  + LCT
  + ETT
  
+ 点分治

+ 点分树

+ 边分治

+ 边分树

+ 树分块

+ 树上距离求和问题

  + 例题1：洛谷P4211 [LNOI2014]LCA
  + 例题2：洛谷P3241 [HNOI2015]开店
  + 例题3：

#### 动态图



#### 能够预处理的静态区间查询

+ 倍增rmq，ST表

  以求解区间最大值为例，$f(i,j)$表示闭区间$[i,i+2^j-1]$的最大值，有递推式$f(i,j)=max(f(i,j-1),f(i+2^{(j-1)},j-1))$，初始化$f(i,0)=a[i]$，查询区间$[l,r]$则令$t=\lfloor log_2(r-l+1) \rfloor$，查询$max(f(l,t),f(r-2^t+1,t))$。同理可以应用于区间$min$，区间$and$、区间$or$、区间最大公约数最小公倍数，区间线性基等具有结合律、幂等运算或者至多能够产生一次贡献的操作。

+ 可以优化至$O(n+m)$的rmq

  + 随机数据下期望$O(n+q)$的区间最值求解（洛谷P3793 由乃救爷爷）

    对序列分块，预处理每个块前缀后缀的答案，以及块到块的答案，这两个操作均可以在$O(n)$内完成，然后对于跨块的询问，直接将询问拆成两个零散块与中间块的答案$O(1)$求出，否则直接暴力扫出落在一个块内的答案。

    为什么这个复杂度是对的呢？考虑有多少种情况需要暴力求解，答案是$\Theta(n\sqrt{n})$级别的，所有的询问的情况是$\Theta(n^2)$级别的，在所有可能的询问出现概率相等的情况下，我们有$\Theta(\frac{1}{\sqrt{n}})$的概率进行一次暴力，这个部分的期望复杂度是$O(m\times\frac{1}{\sqrt{n}}\times\sqrt{n})$也就是$O(m)$的，其它的询问均可以在$O(1)$完成，故总复杂度的期望是线性的。

    而且这个东西也不好卡，如果要卡的话需要调小询问长度，显然就有着很大的风险把暴力选手放过去。

  + 约束rmq的$O(n+m)$求解

    ”约束“的意思是整个序列中的相邻元素的差的绝对值恰好为1，利用这个特殊条件可以将问题进行优化。

    + 首先进行分块，按照$size=\lceil\frac{(log_2n)}{2}\rceil$为一块进行分块，然后求出单块内部前缀后缀的最大值，整块间使用ST表处理，这一部分的复杂度是$O(n)$的。
    + 当询问跨块的时候，直接零散块查表以后大块rmq，考虑当询问落在一个块内的时候怎么处理，我们要充分利用差值的绝对值为正负1的条件，需要额外记录一下每个块中的最小值是多少，然后把这个块内的所有元素减去这个最小值，注意到块长很短，全做减法以后相邻差值不变，我们认为两个块不同当且仅当在减去块内最小值以后，块内存在若干元素不同。此时由于差分数组的取值只有正负1，本质不同的块至多有$2^{0.5log_2n}$种，这个是$O(\sqrt{n})$级别的，因此对这本质不同的$O(\sqrt{n})$种块跑$O(size^2)$的暴力处理结果，查询时直接映射即可。这部分处理复杂度亚线性，单次查询$O(1)$。记得查询完以后把减去的最小值加回来。

  + $O(n\alpha(n)+m)$的做法：

+ 猫树：分治实体化的产物

#### 区间历史最值



#### 区间取最值型修改



#### 区间众数相关

+ 求区间众数（洛谷P4168 [Violet]蒲公英）
  + 分块解法：
  + 莫队解法：
    + 如果有要求
+ 求区间众数出现次数（洛谷P5048 [Ynoi2019 模拟赛] Yuno loves sqrt technology III）
  + 分块解法：
  + 莫队解法：可以直接用普通的莫队，指针移动的同时记录$cnt1(i)$表示区间内i出现了多少次，再记录一个$cnt2(i)$表示区间内出现次数为i的数有几个，对于$cnt2$记录$top$表示最大的非零位置，由于区间长度变化的连续性，容易看出这个最大的非零位的偏移量至多为1，单次指针移动的信息可以在常数时间内更新完成。
+ 求带权众数的权（ATcoder1219 歴史の研究）：
  + 分块解法：
  + 莫队解法：$max$操作没有逆元，区间不可收缩，但是信息允许记录撤销，故采用回滚莫队。

#### 涉及位运算的操作

+ 分位统计
  + 区间异或区间求和
  + 就是分位

+ 求异或K大值
  + 给一个数以及一个集合，在集合内找一个元素和给定的数异或出来的结果最大（01Trie）
  + 给一个集合，在集合内挑选若干数字异或得到的结果最大（线性基）
  + 更加广义上的单调性二分
  
+ 全局加减1全局异或
+ 区间异或区间排序（？）

#### 染色&数颜色问题

+ 颜色段数
  + 一般序列上的问题
  + 序列上树
+ 区间不同种类的颜色数
  + 离线可做，$O(n\sqrt{n})-O(nlogn)$
    + $O(n\sqrt{n})$做法：莫队入门题。
    + $O(nlogn)$做法：询问离线，按照右端点为关键字存入链表，对于每个元素记录$pre(i)$表示$i$前面最后一个和i颜色相同的位置，没有就设为0，考虑一个暴力的实现，从左向右扫描，如果某种颜色是第一次出现则进行记录，否则不会产生贡献。那么考虑固定右端点，向左扫描时记录所有的第一次出现的位置，若这个位置是第一次出现则赋为1，否则为0，那么此时右端点为r，左端点为$x$的答案就是$x$到$r$的区间求和，那么考虑右端点向右移动一位，显然只有$r+1$这个位置会变成第一次出现，那么上一次出现$r+1$这个位置的颜色就会从第一次出现变成第二次出现，赋成0即可，只需要一个单点修改区间求和的数据结构即可完成操作。
    + 例题：洛谷P1972 [SDOI2009]HH的项链
    + 变式：洛谷P4113 [HEOI2012]采花（从一个变成两个，怎么继续利用上面问题的求解过程？）
  + 强制在线，$O(n\sqrt{n})-O(nlogn)$
    + $O(n\sqrt{n})$做法：序列分块，$f(i,j)$表示前$i$个块内$j$出现了多少次，用前缀和预处理；$ans(i,j)$表示第$i$个块开头到位置$j$的答案，暴力做记录答案；落在一个块内部的询问，直接暴力求出答案；否则将右部分的零散块开桶记录出现次数，扫描左部分的零散块去重，查询是否没有在大块以及右端零散块出现过。
    + $O(nlogn)$做法：考虑上面$pre$的性质，如果$l$到$r$内某一个元素是从左到右第一次出现，那么必然满足这个位置的$pre$小于$l$，那么相当于求一个区间内有多少数比给定的$x$小，可持久化权值线段树就可以解决。
  + 单点修改，$O(n^\frac{5}{3})-O(nlog^2n)$
    + $O(n^\frac{5}{3})$离线做法：带修改莫队入门题。
    + $O(n^\frac{5}{3})$在线做法：分块，以$n^{\frac{2}{3}}$为大小进行分块，记录$ans[i,j]$表示从第$i$块的开头一直到第$j$块的末尾的答案，同理记录前缀和，修改一个元素就考虑所有的跨过这个块的大区间，总共$O(n^\frac{2}{3})$数量级，每一个区间都可以在查前缀和表的时候$O(1)$更新，查询同理静态分块做法。只不过复杂度变成了$O(n^\frac{2}{3})$。
    + $O(nlog^2n)$做法：考虑如何沿用上面那个一个$log$的思路，维护某一个位置的$pre$，求解区间内有多少数小于$x$，显然$pre$只涉及两种元素的变动，考虑对于每一种颜色开一个set，记录所有这种颜色出现的位置，然后对于一个位置，求出当前颜色的后继、目标颜色的前驱后继，树套树单点修改（强制在线）或者cdq分治求解（允许离线）。
    + 例题：洛谷P1903 [国家集训队]数颜色
  + 区间赋值，$O(nlog^2n)$（洛谷P4690 [Ynoi2016] 镜中的昆虫）
    + 考虑依然沿用上面记录$pre$数组的做法，然后考虑把颜色相同的位置缩成一段，采用类似于珂朵莉树的形式维护，然后对于一段的修改操作，若一个颜色段完全位于区间内部则只需要修改这一段开头位置的pre值，否则需要修改这一段分裂后分裂处的$pre$值，至多需要修改2个位置。容易发现在这个过程中我们以$O(nlong)$的代价使颜色段数的数目至少减少$n-2$个，在初始化以及后面的操作中颜色段数总量不会超过$O(n+m)$，利用摊还分析可以证明复杂度正确，同时$O(n+m)$也就是需要单点修改的$pre$的总量。只需要把这么多个操作放在树套树上或者cdq分治就可以解决。

#### 区间最大子段和

+ 单点修改区间最大子段和

  使用维护序列的数据结构，每个结点记录这个结点代表的区间的和、以区间左/右端点作为开头/结尾的最大前/后缀和，叶子结点这四个值就对应序列上的值；向上合并的时候区间和最易于维护，考虑左端点为开头的最大前缀和，要么跨越中间要么不跨越中间，前者对应左子区间的左端点为开头的最大前缀和，后者显然左区间已经全部被选上，对应左子区间的和加上右子区间的左端点为开头的最大前缀和；同理右端点为结尾的最大后缀和；区间最大子段和依然考虑能否跨区间，不跨区间就对应左右子区间的最大子段和，否则对应左子区间的右端点为结尾的最大前缀和，加上右子区间的左端点为开头的最大前缀和，如此维护。

  例题：SPOJ1043 GSS1 - Can you answer these queries I、SPOJ1716 GSS3 - Can you answer these queries III

+ 一些可以向区间最大子段和转化的变式

  + 例题1：洛谷P3488 [POI2009]LYZ-Ice Skates

    

  + 例题2：洛谷P2839 [国家集训队]middle

    我们考虑离散化以后二分答案，将$[a,d]$这一段区间内大于等于$mid$的权设为1，否则设为-1，如果$mid$能够成为某个子序列的中位数，那么这一段的数字和一定等于0或1，那么考虑当mid越来越大的时候，最大的权值和一定越来越小以致于小于0，在二分一个值的时候，按照上述说法处理这一段序列，求出左端点在$[a,b]$，右端点在$[c,d]$的最大子段和，若大于等于0则上调二分下界，这个正负1的序列可以通过权值递降的顺序建可持久化线段树求得。

  + 例题3：洛谷P3582 [POI2015]KIN

    考虑固定一个右端点向左暴力，第一次看的电影就加上其权值，第二次碰到就抵消加上负的权值，再碰到就是0，利用“区间不同种类颜色数”中记录$pre$的思想，就可以转化为一个单点修改、后缀最大权值和的问题。

  + 例题4：SPOJ1557 GSS2 - Can you answer these queries II

    在最大子段和的问题上加上了只算一次的条件，考虑将询问按照右端点离线，暴力一点，从左向右枚举右端点向左扫描，在左边所有的点处更新以这个点作为子区间左端点的最大值，然后处理完一个右端点就处理所有在这个位置的询问，显然是求解区间最大值。考虑在右端点向右移动一位的时候所有左端点的答案如何变化，首先所有的位置都先加上新右端点的权，然后上一次出现新右端点元素的位置向左出现重复减去这个权，也就是实现一个区间加法，然后再把所有的左端点更新从开始到现在的最大值，查询只需查询区间的从开始到现在出现过的的最大值，那么此时问题转化为区间加区间历史最大值，套用模板即可。

  + 例题5：SPOJ2916 GSS5 - Can you answer these queries V

    注意到给定的区间可能重合也可能不重合，那么大力讨论一下所有的情况，不重合的情况比较简单，只需要左右分开求前缀后缀最大值，加上中间的和即可。考虑左右区间有交集的情况，分为两端点均在交集部分、有至少一个端点不在交集部分两种情况，前者就是最大子段和模板，后者用不重合的情况处理交集两侧的前后缀最大值的和即可。

  + 例题6：SPOJ6779 GSS7 - Can you answer these queries VII

    序列问题上树就用树剖，区间赋值就考虑每个结点打标记，讨论赋值的正负对区间最大子段和、前后缀最值的影响，同理标记下推的过程。

+ 区间加区间最大子段和，$O(n^\frac{5}{3})-O(n\sqrt{n})$（？？？）

#### 快速单调栈的维护

例题1：洛谷P4198 楼房重建

例题2：洛谷P4425 [HNOI/AHOI2018]转盘

#### 数据结构优化建图



#### 涉及元素修改次数上界的问题



#### 一次函数最值问题

首先把李超线段树介绍一下，这个数据结构用于维护二维平面上的多条线段，

#### 有时间轴的区间处理问题



#### 随机化区间覆盖

直接介绍珂朵莉树的使用手段

#### 区间数对统计

+ 区间逆序对
  + 允许离线：时间复杂度$O((n+m)\sqrt{n})$，空间复杂度$O(n+m)$的二次离线莫队（洛谷P5047 [Ynoi2019 模拟赛] Yuno loves sqrt technology II）

    考虑莫队时需要的信息，如果直接硬维护的话需要维护区间内出现了什么数，以及查询多少数比$x$大/小，考虑将所有的询问进行离线，每个询问的形式是某个区间内比$x$大/小的数有多少个，然后进行一步差分，这里以求解$l$到$r$内有多少数比$r+1$位置的数大为例：差分变成求解1到$r$内有多少数比$r+1$位置的数大、1到$l-1$内有多少数比$r+1$位置的数大，注意到前者与$l$无关，可以直接处理，后者继续离线，注意到询问的形式是二维偏序，那么从左到右一个一个加入元素，求解对应位置前缀的答案，这是一个$O(n)$插入总量$O(n\sqrt{n})$询问总量的二维偏序，使用值域分块平衡两端复杂度，容易实现一个分块，满足$O(\sqrt{n})$单点修改O(1)前缀求和，利用这个可以将时间复杂度优化至$O(n\sqrt{n})$，但此时空间复杂度依然是$O(n\sqrt{n})$。

    注意到莫队的区间移动操作，当一个端点没有移动到指定位置的时候，另一个端点一直固定不动，且这个移动的端点一定是经过一个区间，那么我们依然以上面求解l到r内有多少数比$r+1$位置的数大为例，差分后与$l$无关的那部分前缀和$O(1)$查到，与$l$有关的一部分记录一个区间即可，这部分的空间开销优化至$O(m)$。

  + 强制在线：时间复杂度$O((n+m)\sqrt{n})$，空间复杂度$O((n+m)\sqrt{n})$的分块（洛谷P5046 [Ynoi2019 模拟赛] Yuno loves sqrt technology I）

    介绍两种复杂度一样的做法，只介绍跨块处理手法，零散块以及块内询问处理手法一样我就写在后面了。

    + $f(i,j)$表示前$i$个块内小于等于$j$的数有多少个，$ans(i,j)$表示第$i$个块的开头到第$j$个块的末尾这一段的答案，然后对于每个块处理前缀后缀的逆序对数，$ans(i,j)=ans(i,j-1)+ans(j,j)+calc()$，这个calc表示的是求解块$i$到$j-1$这一部分与块$j$产生的逆序对数贡献，只需要枚举块$j$内的元素，查$f$数组求得贡献。$ans(i,i)$可以在求解前后缀时顺带求出。每个单独的部分考虑完然后考虑互相的贡献，零散块之间采用归并，零散块对整块的部分用$f$数组，枚举零散块元素，查询f数组得到这个元素的贡献求和即可。
    + $f(i,j)$表示前$i$个元素对第$j$个块产生的逆序对数贡献，求解只需要把第$j$个块与整个序列做一遍归并，考虑元素$i$在这个块的前面还是后面（如果在块内的话就不产生贡献），$O(n)$求出一个块的信息，做一遍前缀和得到结果。然后上述做法中的$calc$可以直接查询$f$数组，进而在$O(n)$时间复杂度内求得$ans$数组，零散块对整块的贡献就枚举中间块，用数组$f$差分求解。

    然后将每个零散块复制一下进行排序，扫零散块的时候打标记，扫描排序数组得到零散部分的有序数列，然后归并求解逆序对。左右端点落在同一个块的询问只需要两个后缀相减再减去归并求得的贡献即可。

  + 单点修改区间逆序对

    求解的手段跟上面一样，依然维护

+ 别的一些序列数对上的例题

  + 例题1：洛谷P3722 [AH2017/HNOI2017]影魔


#### 根号分治专题

+ 模剩余系下标的求和
  + 例题1：洛谷P3396 哈希冲突
  + 例题2：洛谷P5309 [Ynoi2011] 初始化
  
+ 涉及元素出现次数的分治

  众所周知若一个多重集大小为$n$，则内部出现次数大于$\sqrt{n}$的元素种类不会超过$\sqrt{n}$种，利用这个性质可以进行数据分治。

  + 例题1：洛谷P5268 [SNOI2017]一个简单的询问
    + 解法1：把式子拆开成询问跑莫队
    + 解法2：设这个序列为$a$，对于全局出现次数大于$\sqrt{n}$的元素，一共不会超过$\sqrt{n}$种。暴力的枚举每一种元素，做前缀和，给每个询问都暴力枚举一遍。对于出现次数小于$\sqrt{n}$的元素，考虑二维偏序，也就是说建立一个$n\times n$的平面，平面上一点$(x,y)$的权值为1当且仅当$a[x]=a[y]$。显然固定一个$x$，令$(x,y)$处的值为1的$y$不超过$\sqrt{n}$个位置。直接枚举就可以。对于询问$[l,r]$，就是求解二维平面上$l\le x \le r$，$l\le y \le r$的矩形元素和。此时问题转化为有$O(n\sqrt{n})$个点，$O(m)$个询问的的二维偏序，用一个$O(1)$单点加法，$O(\sqrt{n})$的值域分块维护。
    
  + 例题2：洛谷P5072 [Ynoi2015] 盼君勿忘

    注意到这个形式就是考虑贡献，考虑一个元素$x$在多少个子序列里出现过，正难则反考虑全集减去不出现的情况，设这个区间的长度为$len$，$x$就在$(2^{len}-1)-(2^{len-cnt(x)}-1)=2^{len}-2^{len-cnt(x)}$这么多个序列中出现过，$cnt(x)$就是在这个询问区间内$x$出现的次数，这个区间的答案就是$x$乘上对应出现次数的和，也就是
    $$
    ans=\sum_{x\in a[l,r]} x(2^{r-l+1}-2^{r-l+1-cnt(x)})
    $$
    考虑对出现次数进行分治，出现次数小于$\sqrt{n}$的元素，记录$sum1(i)$表示出现次数为$i$的数的和，也就是按照出现次数相同的进行分类，统计时直接计算；出现次数大于$\sqrt{n}$的元素，全局记录多少数出现次数大于$\sqrt{n}$，显然不会超过$\sqrt{n}$个，直接枚举每一个进行统计即可。出现次数可以用莫队直接维护，不同的模数采用光速幂根号打表实现。

#### bitset专题



#### STL容器专题



#### 字符串数据结构专题

+ 序列自动机

+ 后缀数组

+ 后缀自动机

+ 后缀树

+ 后缀平衡树

+ 回文自动机

  又称之为回文树，是一个有两个树形结构的有向图。用于记录一个字符串的所有回文子串。


#### 乱搞&暴力优化&定期重构（？）
