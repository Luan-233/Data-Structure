# 有关各种数据结构&求解思想及应用

by Luan_233

### 线性数据结构

----

#### 栈

+ 单调栈

  用于求解一个序列中，某一个元素向左或向右第一个大于或小于它的位置。

  + 

  + 

+ 表达式的求值

----

#### 队列

+ 单调队列

  用于求解左右端点均向一个方向单调变化的区间内的最大最小值。

  + 例题1：洛谷P1886 滑动窗口
  + 例题2：洛谷P2216 [HAOI2007]理想的正方形

  + 例题3：洛谷P3512 [POI2010]PIL-Pilots
  + 例题4：洛谷P3594 [POI2015]WIL-Wilcze doły

+ DP优化
  + 区间最值型优化
    + 例题1：洛谷P3957 [NOIP2017 普及组] 跳房子
    + 例题2：洛谷P2254 [NOI2005] 瑰丽华尔兹
    + 例题3：洛谷P2569 [SCOI2010]股票交易
    + 例题4：洛谷P5665 [CSP-S2019] 划分
    + 例题5：洛谷P7832 [CCO2021] Bread First Search
    
  + 斜率优化
    + 例题1：洛谷P3195 [HNOI2008]玩具装箱
    + 例题2：洛谷P3628 [APIO2010]特别行动队
    + 例题3：洛谷P2120 [ZJOI2007]仓库建设
    + 例题4：洛谷P2900 [USACO08MAR]Land Acquisition G
    
  + 多重背包的优化
  
    考虑多重背包在实现的时候的转移方程，设$f(i,j)$表示前$i$件物品里面花至多$j$元的情况下能够得到的最优解，那么有转移方程
    $$
    f(i,j)=max\{f(i-1,j-k\times cost)+k\times value \}(0\le k \le min\{nums,\lfloor\frac{j}{cost}\rfloor \})
    $$
    设$j=p\times cost+q$，其中$0\le q <cost$，那么转移方程写作：
    $$
    f(i,j)=max\{f(i-1,q+(p-k)\times cost)+k\times value \}(0\le k \le min\{nums,\lfloor\frac{j}{cost}\rfloor \})
    $$
    换元，令$t=p-k$，则$\lfloor \frac{j}{cost} \rfloor-min\{nums,\lfloor \frac{j}{cost} \rfloor \} \le t \le \lfloor \frac{j}{cost} \rfloor$，转移方程变化为
    $$
    f(i,j)=max\{f(i-1,q+t\times cost)+(p-t)\times value \}(\lfloor \frac{j}{cost} \rfloor-min\{nums,\lfloor \frac{j}{cost} \rfloor \} \le t \le \lfloor \frac{j}{cost} \rfloor)
    $$
    那么容易发现所有的转移点取值在模$cost$意义下相同，那么以在转移之前，对于所有不同的$q$，维护一个单调队列来记录模$q$相同的花费下的$f(i-1,q+t\times cost)-t\times value$，显然建立这些单调队列的时间复杂度是$O(V)$的。下面我们说明$t$的取值区间左右均是单调的：显然右端点随着$j$的增大单调不降；对于左端点，当$\lfloor \frac{j}{cost} \rfloor$逐渐增大的时候，其大小未达到$nums$之前的左端点一直是$0$，达到$nums$以后左端点是$\lfloor \frac{j}{cost} \rfloor-nums$，也随着$j$的增大单调不降，故可以使用单调队列优化。容易发现每个状态入队恰好一次，出队至多一次，故复杂度$O(nV)$。
  
+ 

----

#### 哈希表

用于在期望时间复杂度常数的情况下维护集合或者实现映射。

----

### 维护集合的数据结构

----

#### 堆

堆是一种用于维护集合最值、插入元素、删除最值的数据结构，其逻辑形态为一棵二叉树。

+ 普通堆的维护：

  首先介绍数据的堆式存储形式。堆式存储以$1$号结点为堆顶结点，设某个结点编号为$x$，那么其左儿子结点编号为$2x$，右儿子结点为$2x+1$，父节点为$\lfloor \frac{x}{2} \rfloor$。下面以大根堆为例给出一个代码实现。

  介绍线性建堆算法。这个算法的思路在于循环不变式的应用。我们认为一个结点是一个堆，对于一个结点，若两个子树均满足堆性质，但算上这个结点以后不满足堆性质，那么可以通过调整它的位置，把两个小堆结合成一个更大的堆。容易发现只要取出两个子堆里面堆顶元素较小的那个作为交换，把堆顶换下去变成一个子问题，就可以在上界为子堆深度为上界的复杂度内维护这个堆。

    ```c++
    inline void make_heap(){
        for (int i = siz; i; --i) {
            int cur = i;
            while ((i << 1) <= siz) {
                int son = (cur << 1);
                if ((son < siz) && (val[son] < val[son + 1])) ++son;
                if (val[cur] >= val[son]) break;
                std::swap(val[cur], val[son]), cur = son;
            }
        }
    }
    ```

    其复杂度为$T(n)=\sum_{i=1}^{log_2n}2^{i-1}(log_2n-i+1)=O(n)$。

    下面介绍插入操作，每插入一个元素，首先在数组尾部加入这个新元素，然后考虑调整数据结构，维护这个结点到根上面所有的包含它的子树。若某个结点以下的二叉树不满足大根堆性质，就把父节点换下去，若依然不满足，就继续交换直到满足为止。由插入前各个结点元素信息之间的单调性可知这样做可以正确维护信息。

  ```C++
  inline void push(int x) {
  	int cur = ++siz, fa;
  	val[siz] = x;
  	while ((cur > 1) && (cur >> 1)) {
  		fa = cur >> 1;
  		if (val[cur] <= val[fa]) break;
  		std::swap(val[cur], val[fa]), cur = fa;
  	}
  }
  ```

    最后是删除堆顶元素的操作。首先取出堆尾部元素覆盖到堆顶，然后类似于建堆操作向下调整。

    ```c++
    inline void pop() {
        int cur = 1, son;
        val[1] = val[siz--], val[siz + 1] = 0;
        while ((cur << 1) <= siz) {
            son = cur << 1;
            if ((son < siz) && (val[son] < val[son + 1])) ++son;
            if (val[cur] >= val[son]) break;
            std::swap(val[cur], val[son]), cur = son;
        }
    }
    ```

    显然单次操作复杂度上界为这棵树的高度，为$O(logn)$。

  下面是一些直接实现最值查找的例题。

  + 例题1：洛谷P1631 序列合并
  + 例题2：洛谷P2048 [NOI2010] 超级钢琴

  堆一般用于贪心的优化。

  + 例题1：洛谷P1090 [NOIP2004 提高组] 合并果子
  + 例题2：洛谷P3045 [USACO12FEB]Cow Coupons G
  + 例题3：洛谷P5470 [NOI2019] 序列

  堆可回用于实现哈夫曼编码。

  + 例题1：洛谷P2168 [NOI2015] 荷马史诗

+ 对顶堆

  对顶堆不是严格的数据结构，任意两个单调性相反的堆均可以用做对顶堆。其功能是维护一个集合，支持每次插入一个元素并询问当前集合内元素的中位数。

  其具体手法是维护两个单调性不同的堆，满足两个堆内部元素数目差值至多为$1$，小根堆堆顶元素大于等于大根堆内部元素。当插入一个元素的时候考虑其与两个堆顶的元素的大小关系，若小于大根堆堆顶则放入大根堆，若大于小根堆堆顶则放入小根堆，若在两个元素之间就任意放入一个元素数目较少的堆即可。注意到前两种情况下可能会破坏性质“两个堆内部元素数目差值至多为$1$”，但此时至多差值为$2$，那么从元素数目较多的堆里面拿出来一个放入另一个就可以了。查询中位数的话就查询元素数目较多的那个堆的堆顶元素就可以了。显然复杂度为$O(nlogn)$。

  + 例题1：洛谷P1168 中位数
  + 例题2：洛谷P1801 黑匣子

+ 左偏树

  可并堆的一种。可以用于可持久化。

+ 配对堆

  可并堆的一种。复杂度假但是运行效率优秀，不能用于可持久化。

+ 可持久化可并堆

----

#### 并查集

并查集用于集合的合并，以及查询两个元素是否在同一个集合内。下面介绍若干种并查集使用手法和扩展，以及适于求解的问题。

容易发现集合的实现可以用一个有向森林来表示，每个点有唯一的出边，要么指向自己，要么能从自己出发，通过有向边走到一个出边指向自己的点。这个指向性的数组就是并查集，并称这些出边指向自己的点为它所在集合的代表元素。在这种表示方法下，称两个元素在同一个集合内当且仅当两个元素对应在并查集内有相同的代表元素。集合的合并只需要把一个代表元素的根指向另一个代表元素，就可以实现合并与连通性查询的维护。

+ 路径压缩
  + 实现手法
  + 复杂度分析
+ 按秩合并
  + 实现手法
  + 复杂度分析
+ 带有偏移量的并查集
+ 允许暴力修改的求和问题
+ 实体化的并查集应用：克鲁斯卡尔重构树
  + 例题1：洛谷P7834 [ONTAK2010] Peaks 加强版
  + 例题2：洛谷P4768 [NOI2018] 归程
  + 例题3：洛谷P4899 [IOI2018] werewolf 狼人

----

#### Treap

用于维护集合的数据结构。每个节点含有两个关键字，一个用于维护元素，使得整棵树满足中序遍历单调；另一个用于维护树的形态，使得树随时满足堆的性质。所以说Treap是笛卡尔树的一种。

+ 具体实现手法

  每个二叉树结点记录一个随机出来的优先级，单点插入删除只需要进行左旋右旋保证堆性质。

+ 复杂度分析

  

----

#### 替罪羊树

用于维护集合的数据结构。

+ 具体实现手法

  每个二叉树结点记录子树的$size$，设定一个阈值$\alpha$，我们认为一个结点不平衡当且仅当$\frac{max(size(ls),size(rs))}{size} > \alpha$，在插入时候若不平衡，则取出中序遍历按照建立二叉树的方式重构子树。一般$\alpha$取值在$0.75-0.85$。

+ 复杂度分析

  对于一棵替罪羊树，设势能函数
  $$
  \phi(T)=c\sum_{cur \in T} |size(cur.ls)-size(cur.rs)|
  $$

  其中$c$是一个与$\alpha$有关的常数，容易证明一棵替罪羊树的高度一定是对数级别的，考虑一次插入一个点会最多给势能提升多少，显然是$c$倍的树的高度，是$O(logn)$的。一棵子树重构以后这个结点以及它所有的子结点的势能函数变成$0$，此时容易发现对于一个被重构的结点，我们用$O(n)$的代价让势能函数减少了$(2\alpha-1)cn$，此时只需要调结$c$的大小，使得其能够支配住重构过程的常数即可。容易发现每次不用连续重构自上而下的一段结点，只需要重构最上方的不平衡结点即可，此时重构常数极大减小。

----

#### 字典树Trie树

+ 01-Trie

  + 维护集合

    可以充当线段树用。

  + 位运算贪心

    一般用于求解给定一个数字$x$，求解$x$与这个集合内的元素异或结果的最大值。

  + 可持久化01-Trie

    
  
  + 反向建树的应用

----

#### AVL树

----

#### 红黑树

----

#### B-Tree & (B+)-Tree

----

#### van Emde Boas Tree

----

#### Fusion Tree

----

### 维护定长序列的数据结构

----

#### 树状数组

适用于运算存在逆元或有特殊单调性的序列单点修改前缀查询问题。

+ 基本操作

  + 单点加法，区间求和

    以这个作为基本操作讲述树状数组的写法，并证明复杂度。

    首先定义$lowbit(i)$表示取出$i$二进制意义下最低的非零位，由补码的性质可以知道$lowbit(i)=i\&(-i)$。

    树状数组是一个类后缀和的数组，又称之为二叉索引树，对于一个普通的数组$a[i]$，设其对应的树状数组为$t[i]$，那么$t[i]$保存原数组中区间$[i-lowbit(i)+1,i]$这个区间的元素和。容易画图验证两个树状数组对应原序列的区间要么不相交，要么一个被一个包含。由这个关系可以把区间抽象成一棵树。故得名树状数组。

    对于前缀查询，假设要求$a[1...x]$的和，从$x$开始，首先给返回值加上$t[x]$，然后$x$再减掉$lowbit(x)$，如此迭代直到$x=0$为止。容易看出每一次迭代都让$x$在二进制意义下的$1$的个数减少$1$，而对于一个长度为$n$的树状数组，$popcnt(x)$的最大值为$log_2n$，故单次查询是$O(logn)$的。

    ```C++
    inline int query(int pos) {
    	int res = 0;
    	while (pos) res += t[pos], pos -= lowbit(pos);
    	return res;
    }
    ```

    对于单点修改，假设给位置$x$的数加上$val$，那么需要找到所有包含$x$的区间维护一下即可。下面不加证明的给出这个做法：首先给$t[x]$加$val$，然后给$x$加上$lowbit(x)$，如此迭代直到$x>n$。

    容易看出，$x$加上$lowbit(x)$的过程就是每一次找到$x$二进制下最下面的一段$1$，将其赋为$0$以后把下一位赋为$1$。其至多进行$log_2x$次操作就会把$x$变成$2$的整数次幂，然后再进行加法就会让$x$翻一倍，至多进行$log_2n$轮操作就会退出，故单点修改的复杂度也是$O(logn)$的。

    ```C++ 
    inline void modify(int pos, int val) {
    	while (pos <= n) t[pos] += val, pos += lowbit(pos);
    }
    ```

  + 区间加法，单点查询

    这类问题的维护套路就是对原序列做差分，查分以后某个元素的实际值就是差分序列的前缀和，区间修改只会涉及到差分序列两个位置的变动，为此只需要用树状数组维护这个差分序列即可。

  + 区间加法，区间查询

    考虑沿用上面差分的思路，设差分以后的序列为$a[i]$，那么求原数列中$[1,x]$的和就可以写成
    $$
    sum(x)=\sum_{i=1}^{x}\sum_{j=1}^{i}a[i]
    =\sum_{i=1}^{x}a[i]\times(x-i+1)
    =x\sum_{i=1}^{x}a[i]-\sum_{i=1}^{x}(i-1)\times a[i]
    $$
    由此可知只需要维护$a[i]$的前缀和以及$(i-1)a[i]$的前缀和就可以进行快速修改与查询了。区间加法和区间求和只需要拆成前缀进行操作即可。

+ 统计应用

  + 例题1：洛谷P1972 [SDOI2009] HH的项链

    询问离线，按照右端点为关键字存入链表，对于每个元素记录$pre(i)$表示$i$前面最后一个和$i$颜色相同的位置，没有就设为$0$，考虑一个暴力的实现，从左向右扫描，如果某种颜色是第一次出现则进行记录，否则不会产生贡献。以此维护一个$01$序列，考虑固定右端点，向左扫描时记录所有的第一次出现的位置，若这个位置是第一次出现则赋为$1$，否则为$0$，那么此时右端点为$r$，左端点为$x$的答案就是$x$到$r$的区间求和，那么考虑右端点向右移动一位以后这个$01$序列会发生哪些变动，显然只有$r+1$这个位置会变成第一次出现，那么上一次出现$r+1$这个位置的颜色就会从第一次出现变成第二次出现，赋成$0$即可，只需要一个单点修改区间求和的树状数组即可完成操作。

  + 例题2：洛谷P4113 [HEOI2012] 采花

    考虑依然沿用上一题记录$pre$的思路，维护上一次出现相同元素的位置。依然考虑暴力，显然每种颜色遇到第二次的时候才会记录一次，所以只需要维护从右向左的第二个位置为$1$，其余的为$0$即可。

  + 例题3：洛谷P2154 [SDOI2009]虔诚的墓主人

  + 例题4：洛谷P3616 富金森林公园

  + 例题5：洛谷P3760 [TJOI2017]异或和

+ 树状数组二分

  用于在一个权值数据结构里求第K大。类似于线段树二分，首先从最大的前缀区间开始，设$pos=2^{\lfloor log_2n \rfloor}$，查树状数组$[1,pos]$之内的元素数量和，设为$offset$，如果$K>offset$则令$K$减掉$offset$进入树状数组$[pos+1,n]$部分进行查询，否则保持$K$的值，然后变成查询区间$[1,pos]$部分，容易发现$[1,pos]$也是树状数组，而且注意到$[pos+1,n]$的部分形态和树状数组一样，只不过下标多了$pos$，查询的时候给下标加上偏移量即可，如此枚举$2$的若干次方，进行迭代就可以求出第K大。注意到任何一个时候$K>0$成立，也就是说最终求出来的时候恰好是第K大的前一个数，故返回的位置需要加$1$。

  ```C++
  inline int query(int rank) {
  	int res = 0;
  	for (int i = lg2[n]; ~i; --i) {
  		if (res + (1 << i) > n) continue;
  		if (t[res + (1 << i)] < rank) rank -= t[res += (1 << i)];
  	}
  	return res + 1;
  }
  ```

+ DP优化

  一般用于二维偏序的优化。
  
  例题：
  
  + 洛谷P3431 [POI2005]AUT-The Bus

----

#### 线段树

由于绝大多数实现思路都可以用线段树及其变式完成，故把大多数典型题目类型放到这个版块，充分讲解线段树的应用。

+ 基本操作

  + 区间加法，区间求和

    现存若干种常见的线段树写法，主要介绍记录左右子树的写法。这种写法适合推广到动态开点写法。

    信息的记录：

    ```c++
    int root, ls[maxn << 1], rs[maxn << 1], cnt;//根结点编号、左儿子编号。右儿子编号、内存池计数器
    long long sum[maxn << 1], tag[maxn << 1];//区间数值和、区间加法标记
    ```

    建树：

    ```c++
    void build(int L, int R, int& cur) {
    	cur = ++cnt;
    	if (L == R) { read(sum[cur]); return; }
    	int mid = (L + R) >> 1;
    	build(L, mid, ls[cur]), build(mid + 1, R, rs[cur]);
        sum[cur] = sum[ls[cur]] + sum[rs[cur]];
    }
    ```

    对于别的维护区间信息的线段树，更加一般化的写法如下：（左右均为闭区间）

    ```c++
    void build(int L, int R, int& cur) {
    	cur = ++cnt;
    	if (L == R) {
            //初始化叶子结点信息
            return;
        }
    	int mid = (L + R) >> 1;
    	build(L, mid, ls[cur]), build(mid + 1, R, rs[cur]);
        pushup(cur);
    }
    ```

    其中$pushup(cur)$的意义是通过$cur$的左右子树信息合并，得到$cur$对应区间的信息，例如区间加法的$pushup$就可以这样实现：

    ```c++
    inline void pushup(int cur) {
    	sum[cur] = sum[ls[cur]] + sum[rs[cur]];
    }
    ```

    然后考虑区间求和，我们直接在线段树上面dfs，若当前结点代表区间与询问有交集就继续向有交集的子树走，将查询到的信息合并返回；若结点区间被询问区间包含，就直接返回这个区间的信息即可。

    ```c++
    ll query(int L, int R, int l, int r, int cur) {//LR即当前cur对应的区间，lr对应询问区间
    	if ((l <= L) && (r >= R)) return sum[cur];//被包含就直接返回
    	int mid = (L + R) >> 1;
        ll res = 0;
    	if (l <= mid) res += query(L, mid, l, r, ls[cur]);
    	if (r > mid) res += query(mid + 1, R, l, r, rs[cur]);//分割区间
    	return res;
    }
    ```

    在这个基础之上加上区间加法，显然不能把每个叶子节点都暴力加一遍，所以我们要利用标记，维护这个子树对应的区间内每个叶子结点加上了多少，并且实时更新结点对应的和。写出来以后会发现操作和查询是一样的。

    另外，由于加上了修改操作，我们首先需要考虑实时的维护每个我们需要的结点的信息，也就是标记的下推。更具体的，标记最好理解为“在这个子树内每个叶结点都进行了这样一次操作，这个结点的信息已经更新完成”。这样有利于在之后的代码书写中搞清楚。另外一般的标记需要有可合并性，也就是对于一个已经有标记的结点，要能在这个基础之上再额外进行快速修改。

    所以我们的标记下推与区间修改可以如下写：（个人写法问题，只在dfs的时候记录区间左右端点）

    ```c++
    inline void pushdown(int L, int R, int cur) {
    	int mid = (L + R) >> 1;
    	tag[ls[cur]] += tag[cur], tag[rs[cur]] += tag[cur];
    	sum[ls[cur]] += tag[cur] * (mid - L + 1);
    	sum[rs[cur]] += tag[cur] * (R - mid);//维护子结点的标记与区间和
    	tag[cur] = 0;//标记下推完以后，它的历史使命就完成了，清空
    }
    void modify(int L, int R, int l, int r, int cur, long long val) {
    	if ((l <= L) && (r >= R)) {
    		sum[cur] += val * (R - L + 1), tag[cur] += val;
    		return;
    	}
    	if (tag[cur]) pushdown(L, R, cur);//没有标记就不需要下推
    	int mid = (L + R) >> 1;
    	if (l <= mid) update(L, mid, l, r, ls[cur], val);
    	if (r > mid) update(mid + 1, R, l, r, rs[cur], val);
    	pushup(cur);
    }
    ```

    同时，由于标记的存在，在查询的时候需要下推标记更新信息，使得我们查询到的区间信息就是正确的：

    ```c++
    ll query(int L, int R, int l, int r, int cur) {
    	if ((l <= L) && (r >= R)) return sum[cur];
    	if (tag[cur]) pushdown(L, R, cur);//重要！！！
    	int mid = (L + R) >> 1;
        ll res = 0;
    	if (l <= mid) res += query(L, mid, l, r, ls[cur]);
    	if (r > mid) res += query(mid + 1, R, l, r, rs[cur]);
    	return res;
    }
    ```

    这样我们就得到了能够维护区间加法、区间求和的线段树。

    当然了，由于加法的特殊性质，有另一种不需要下推标记的写法，叫做标记可持久化。

  + 区间加法，区间乘法，区间求和

    这个相对于上面多加上了一个乘法操作，自然可以多加上一个标记维护乘法。

  + 定长01序列的操作

    常见的操作有区间赋值，区间异或1，区间求和，区间最长0/1段长度。一般需要标记记录区间覆盖、区间是否被异或过，打标记的时候考虑所有的标记的可能，更新合并时候记录区间0/1数量、左0/1长度、右0/1长度、区间最长0/1长度。

    + 例题1：洛谷P2894 [USACO08FEB] Hotel G
    + 例题2：洛谷P2572 [SCOI2010] 序列操作
    + 例题3：洛谷P3968 [TJOI2014] 电源插排
    + 例题4：洛谷P4344 [SHOI2015] 脑洞治疗仪
  
+ 动态开点

  这个写法可以在线段树有用信息稀疏的情况下节省空间。同时为后面的线段树合并做铺垫。很多时候可以替代平衡树进行操作。

+ 可持久化

+ 线段树合并

+ 区间历史最值

  + 例题1：洛谷P4314 CPU监控

    考虑如何维护一个区间内带修改的区间历史最值，由于标记分为加法和赋值，所以分开打标记，初始时为加法标记加$0$，每个结点额外记录状态表示当前生效的是哪个标记。

    然后考虑对一个线段树结点反复做加法的情况下，会使区间历史最值如何变化，以及如何记录区间信息对子结点的影响。容易看出是在加法标记最大的时候可能对子结点区间的信息产生影响，那么需要记录加法标记，以及加法标记出现过的的最大值。考虑带上赋值操作，显然赋值过后加法标记不再起作用，但由于查询的是历史最值，最大赋值标记仍然会起作用。赋值过后再赋值只需要标记覆盖，同理加法操作需要记录最大的赋值标记是多少；加法可以等价转化成区间赋值，套用赋值的信息变动方式处理。

    下推标记的时候，首先下推加法标记，更新加法操作过后的最大值，然后再检查是否存在赋值标记，标记下推完成以后注意清空加法相关的标记，将生效标记转换为加法。

  + 例题2：SPOJ1557 GSS2 - Can you answer these queries II

    在最大子段和的问题上加上了只算一次的条件，考虑将询问按照右端点离线，暴力一点，从左向右枚举右端点向左扫描，在左边所有的点处更新以这个点作为子区间左端点的最大值，然后处理完一个右端点就处理所有在这个位置的询问，显然是求解区间最大值。考虑在右端点向右移动一位的时候所有左端点的答案如何变化，首先所有的位置都先加上新右端点的权，然后上一次出现新右端点元素的位置向左出现重复减去这个权，也就是实现一个区间加法，然后再把所有的左端点更新从开始到现在的最大值，查询只需查询区间的从开始到现在出现过的的最大值，那么此时问题转化为区间加区间历史最大值，套用模板即可。

+ 区间最大子段和

  + 单点修改区间最大子段和

    使用朴素的线段树，每个结点记录这个结点代表的区间的和、以区间左/右端点作为开头/结尾的最大前/后缀和，叶子结点这四个值就对应序列上的值；向上合并的时候区间和最易于维护，考虑左端点为开头的最大前缀和，要么跨越中间要么不跨越中间，前者对应左子区间的左端点为开头的最大前缀和，后者显然左区间已经全部被选上，对应左子区间的和加上右子区间的左端点为开头的最大前缀和；同理右端点为结尾的最大后缀和；区间最大子段和依然考虑能否跨区间，不跨区间就对应左右子区间的最大子段和，否则对应左子区间的右端点为结尾的最大前缀和，加上右子区间的左端点为开头的最大前缀和，如此维护。

    ```c++
    inline void pushup(int cur) {
        lmax[cur] = std::max(lmax[ls[cur]], sum[ls[cur]] + lmax[rs[cur]]);
        rmax[cur] = std::max(rmax[rs[cur]], sum[rs[cur]] + rmax[ls[cur]]);
        maxv[cur] = std::max(lmax[rs[cur]] + rmax[ls[cur]], std::max(maxv[ls[cur]], maxv[rs[cur]]));
        sum[cur] = sum[ls[cur]] + sum[rs[cur]];
    }
    ```

    + 例题1：SPOJ1043 GSS1 - Can you answer these queries I
    + 例题2：SPOJ1716 GSS3 - Can you answer these queries III

  + 一些可以向区间最大子段和转化的变式

    + 例题1：洛谷P3488 [POI2009] LYZ-Ice Skates

      

    + 例题2：洛谷P2839 [国家集训队] middle

      我们考虑离散化以后二分答案，将$[a,d]$这一段区间内大于等于$mid$的权设为1，否则设为-1，如果$mid$能够成为某个子序列的中位数，那么这一段的数字和一定等于0或1，那么考虑当mid越来越大的时候，最大的权值和一定越来越小以致于小于0，在二分一个值的时候，按照上述说法处理这一段序列，求出左端点在$[a,b]$，右端点在$[c,d]$的最大子段和，若大于等于0则上调二分下界，这个正负1的序列可以通过权值递降的顺序建可持久化线段树求得。

    + 例题3：洛谷P3582 [POI2015] KIN

      考虑固定一个右端点向左暴力，第一次看的电影就加上其权值，第二次碰到就抵消加上负的权值，再碰到就是0，利用“区间不同种类颜色数”中记录$pre$的思想，就可以转化为一个单点修改、后缀最大值的问题。

    + 例题4：SPOJ2916 GSS5 - Can you answer these queries V

      注意到给定的区间可能重合也可能不重合，那么大力讨论一下所有的情况，不重合的情况比较简单，只需要左右分开求前缀后缀最大值，加上中间的和即可。考虑左右区间有交集的情况，分为两端点均在交集部分、有至少一个端点不在交集部分两种情况，前者就是最大子段和模板，后者用不重合的情况处理交集两侧的前后缀最大值的和即可。

    + 例题5：SPOJ6779 GSS7 - Can you answer these queries VII

      序列问题上树就用树剖，区间赋值就考虑每个结点打标记，讨论赋值的正负对区间最大子段和、前后缀最值的影响，同理标记下推的过程。

+ 允许暴力修改的线段树

  这类题目的特点是区间修改区间求和，每个元素至多被暴力处理一个比较小的数字次。

+ 李超线段树

+ 线段树维护单调栈

  + 例题1：洛谷P4198 楼房重建

    考虑线段树每个结点维护其对应区间形成的单调栈的长度，显然叶子结点的答案为1，考虑自下向上维护的过程，定义函数$pushup(cur,k)$表示计算将$cur$这个结点对应的区间建成一个首元素大于k的单调栈，栈内元素的数量是多少。线段树维护一个区间最大值，考虑如何实现区间信息的维护，显然对于一个结点$cur$，其对应区间的单调栈长度等于$len(ls)+pushup(rs,ls.maxh)$。

    我们着重考虑如何实现这个单调栈，显然当$K$要求大于一个区间内的所有值的时候长度就是0，剪枝优化掉这个情况后，利用分治的思想，从下向上考虑：

    + 当前结点为叶子结点，只需要判断元素值是否大于$K$即可。
    + 当前结点为非叶子结点，首先检查左子结点中的最大值，若最大值小于等于$K$，则直接递归右子结点；否则左子树中尾部信息保留，当前区间构成的单调栈中来自于右子树的部分可以完全保留。

    ```c++
    int pushup(int L, int R, int cur, double k) {
        if (k >= maxh[cur]) return 0;
    	if (l == r) return (maxh[cur] > k) ? 1 : 0;
    	int mid = (L + R) >> 1;
    	if (maxh[ls[cur]] <= k) return pushup(mid + 1, R, rs[cur], k);
    	else return pushup(L, mid, ls[cur], k) + len[cur] - len[ls[cur]];
    }
    ```

    由于自下而上的过程中，叶子结点的信息正确，在子结点的信息都是正确的情况下可以求出当前结点的正确答案。

  + 例题2：洛谷P4425 [HNOI/AHOI2018] 转盘

+ 线段树分裂

  用于把线段树中的一段连续区间分裂出来出来形成两棵线段树。以模板题（洛谷P5494 【模板】线段树分裂）为例进行说明。

  多重集的维护可以直接使用线段树动态开点维护，集合的合并使用线段树合并维护，对于分裂操作，需要维护一个新树的根结点指针，然后一边向下走一边判断，若新分裂出来的树也需要对应位置的结点保持形态，那么就动态开结点给新树用，直到结点区间被操作区间完全包含为止，这时候就可以把这个子树直接接到新树下方。使用传址调用可以极大地降低代码难度。

  ```C++
  void split(int L, int R, int& cur1, int& cur2, int l, int r) {
  	if ((l <= L) && (r >= R)) { cur2 = cur1, cur1 = 0; return; }
  	cur2 = top ? stk[top--] : (++cnt);//用一个栈实现内存池垃圾回收
  	int mid = (L + R) >> 1;
  	if (l <= mid) split(L, mid, ls[cur1], ls[cur2], l, r);
  	if (r > mid) split(mid + 1, R, rs[cur1], rs[cur2], l, r);
  	pushup(cur1), pushup(cur2);
  }
  ```

  + 例题1：洛谷P2824 [HEOI2016/TJOI2016] 排序

    我们可以把一个极长递增序列以及一个极长递减序列用权值线段树维护，注意到区间排序的形式是

+ 线段树分治

+ 区间取最值型的操作

  直接介绍Segment Tree Beats（吉老师线段树）的实现方法。

+ 扫描线的维护

  + 例题1：洛谷P5490 【模板】扫描线（矩形面积并）

  + 例题2：洛谷P1856 [IOI1998] [USACO5.5] 矩形周长Picture

  + 例题3：洛谷P3246 [HNOI2016] 序列

    首先有考虑贡献的套路，设这个序列为$a$，考虑每一个位置能够成为多少个区间的最小值，对于相同元素，我们令一个子段的最小值是这一段的最小值中最靠左的。那么利用单调栈处理出左面第一个小于等于当前位置的值的位置，以及右面第一个小于当前值的位置。设位置$i$能够向左最多延伸到$left(i)$，向右最多延伸到$right(i)$。
    
    定义一个二维平面，位置$(x,y)$上面的值是$a[x...y]$中最靠左的最小值，显然对于序列中的每个元素，平面中$left(i)\le x \le i$，$i\le y \le right(i)$的值就是$a[i]$，由此可以将二维平面$y=x$的上半部分分割成若干不相交的子矩形。考虑扫描线的过程，每个询问$[l,r]$就是在查询二维平面内$l\le x \le r$，$l\le y \le r$这一部分的矩阵和，进一步拆分成$x \le r$，$l\le y \le r$的和与$x \le l-1$，$l\le y \le r$的和。递增枚举横坐标，对于已经完全包含在左面的子矩形，直接区间加法维护和；对于跨越当前横坐标的子矩形，注意到我们要求的部分和就是$\sum (r-left(i))\times a[i]=r\sum a[i]-\sum left(i)a[i]$，用两个线段树分别维护当前未被完全扫描完的子矩形的$a[i]$与$left(i)a[i]$即可。

+ 优化建图

  + 例题1：洛谷P5025 [SNOI2017]炸弹
  + 例题2：洛谷P3588 [POI2015] PUS

+ DP优化

  + 例题1：洛谷P1848 [USACO12OPEN] Bookshelf G
  + 例题2：洛谷CF833B The Bakery

+ zkw线段树

----

#### 分块

+ 基本操作

  以hwzer的数列分块入门九题作为基础操作讲解。以下默认当询问左右端点在同一个块内的时候就是零散块的操作，设$B$为块长。

  + 数列分块1：区间加法，单点查询

    分块，每个块打一个标记，维护整个块内每个元素额外加上了多少。加法操作就枚举散块与整块，散块直接暴力加，整块只需要在标记上做加法即可。单点查询只需要取出序列中的数再加上所在块的标记即可。块长取$B=\sqrt{n}$的时候复杂度为$O(m\sqrt{n})$。

  + 数列分块2：区间加法，区间询问小于等于某个元素的数的个数

    分块，每个块打标记记录这个块每个元素额外加上了多少，还需要维护一个数组保存这个块中所有元素排序过后的结果。散块暴力给每一个元素做加法，排序重构排序数组；查询答案就暴力枚举散块元素，整块内部二分。块长取$B=\sqrt{n}$的时候复杂度为$O(m\sqrt{n}logn)$。

    当然了，注意到散块加法是给排好序的数组中的一部分数做加法，故在排序数组中每个数额外记录其在原序列中的位置，一遍扫描把排序数组分成两部分，其中一部分是需要做加法的，另一部分不需要做加法，这两部分可以通过归并实现排序数组的维护。调节块长，块长取$B=\sqrt{nlogn}$的时候复杂度为$O(m\sqrt{nlogn})$。

  + 数列分块3：区间加法，区间查询前驱

    实现手法和数列分块2相似，故不再赘述。

  + 数列分块4：区间加法，区间求和

    分块，每个块维护整个块的元素和，以及打标记，维护这个块内每个元素额外加上了多少。加法操作就枚举散块与整块，散块直接暴力加，维护整块元素和，整块需要在标记上做加法，元素和也相应的有变动。区间求和需要枚举零散块与整块，整块直接查询块内元素和，零散块部分暴力扫描，注意需要加上所在块的标记。

  + 数列分块5：区间每个数开方，区间求和

    分块，维护每个块内的元素最大值。注意到正整型范围内的每个元素开平方根下取整不超过5次就会变成1，变成1或者0以后就不再变化，所以每个元素暴力做就可以。对于零散块暴力开根号维护块和与最大值，在整块的最大值超过1的时候对整个块暴力，维护块和与最大值，否则直接跳过不计算。求和同理数列分块4。整块至多暴力$5B^2\times \frac{n}{B}=O(Bn)$数量级，在块长取$B=\sqrt{n}$的时候复杂度为$O((n+m)\sqrt{n})$。

  + 数列分块6：单点插入，单点询问

    这个将会放在维护序列的数据结构中的块状链表部分讲解。

  + 数列分块7：区间加法，区间乘法，区间求和

    类似于线段树做法，每个块维护加法乘法标记，将数列分块4与乘法线段树结合一下就可以了。

  + 数列分块8：区间赋值，区间询问某个数的出现次数

    考虑怎么维护区间赋值，如果我们能做到在$O(x)$时间内定位、移除或增加一个颜色段，由摊还分析可以知道暴力修改（无查询的情况下）的复杂度是$O((n+m)x)$的，即移除所有被包含的颜色段，分割有交集的两端，插入一个连续的整段的总复杂度。

    那么维护$cnt(i,j)$实表示块$i$内$j$出现了多少次，再在每个块内实现现一个链表，维护这个块内的极长相同数字段，每一次零散块操作会让这个块内极长色段数减少$x(0\le x)$并且至多增加$2$，暴力重构一下维护；整块赋值就直接暴力遍历这个块的链表修改$cnt$数组，这一部分的复杂度是这个块的初始颜色段数加上后来零散块操作加上的颜色数，所有块的总量是$O(n+m)$的。查询就散块暴力整块查表。块长取$B=\sqrt{n}$的时候复杂度为$O((n+m)\sqrt{n})$。

  + 数列分块9：区间众数（洛谷P4168 [Violet] 蒲公英）

    设$cnt(i,j)$表示前$i$个块内$j$出现了多少次，前缀和处理；$ans(i,j)$表示从第$i$个块的开头到位置$j$这段区间的最小众数，枚举每个块的左端点向右暴力处理。求解答案的时候，若询问左右端点在同一个块内的时候暴力求解，否则先查$ans$数组求出一个临时解，扫描左右零散块，开一个$num(i)$记录零散部分$i$出现了多少次，枚举左零散块中的元素，利用$cnt$与$num$查询出现次数更新答案。求解完一次就撤销清空$num$数组。块长取$\sqrt{n}$的时候复杂度为$O((n+m)\sqrt{n})$。

+ 一些进阶分块题目：

  + 例题1：洛谷P4108 [HEOI2015]公约数数列

    考虑到从序列开头到所有位置出现的本质不同的前缀最大公约数的出现数量级是$O(logV)$的，但区间异或区间查找某个数是否出现不易于我们操作，考虑暴力分块，每个块维护这个块内的异或前缀，以及对应的异或前缀集合，一个块内数据的的最大公约数，从序列开头到这个块尾的最大公约数。查询的时候从序列开头枚举每一个块，若前缀经过这个块以后的最大公约数没有变化，就去这个块对应的异或前缀集合内查找，否则暴力扫一遍这个块求解。显然暴力的次数很少，当块长为$B$的时候，单次修改复杂度$O(BlogV+BlogB)$，单次查询复杂度为$O(BlogVlogB+\frac{n}{B}logB)$，$B$在取一个比较小的数，约$\frac{n}{4}$的时候运行速度比较优秀。

  + 例题2：洛谷P5046 [Ynoi2019 模拟赛] Yuno loves sqrt technology I

    对于在线区间逆序对，介绍两种复杂度一样的做法，均为时间复杂度$O((n+m)\sqrt{n})$，空间复杂度$O(n\sqrt{n})$的，只介绍跨块处理手法，零散块以及块内询问处理手法一样放在后面。

    + $f(i,j)$表示前$i$个块内小于等于$j$的数有多少个，$ans(i,j)$表示第$i$个块的开头到第$j$个块的末尾这一段的答案，然后对于每个块处理前缀后缀的逆序对数，$ans(i,j)=ans(i,j-1)+ans(j,j)+calc()$，这个calc表示的是求解块$i$到$j-1$这一部分与块$j$产生的逆序对数贡献，只需要枚举块$j$内的元素，查$f$数组求得贡献。$ans(i,i)$可以在求解前后缀时顺带求出。每个单独的部分考虑完然后考虑互相的贡献，零散块之间采用归并，零散块对整块的部分用$f$数组，枚举零散块元素，查询f数组得到这个元素的贡献求和即可。

    + $f(i,j)$表示前$i$个元素对第$j$个块产生的逆序对数贡献，求解只需要把第$j$个块与整个序列做一遍归并，考虑元素$i$在这个块的前面还是后面（如果在块内的话就不产生贡献），$O(n)$求出一个块的信息，做一遍前缀和得到结果。然后上述做法中的$calc$可以直接查询$f$数组，进而在$O(n)$时间复杂度内求得$ans$数组，零散块对整块的贡献就枚举中间块，用数组$f$差分求解。

    将每个零散块复制一下进行排序，扫零散块的时候打标记，扫描排序数组得到零散部分的有序数列，然后归并求解逆序对。左右端点落在同一个块的询问只需要两个后缀相减再减去归并求得的贡献即可。

  + 例题3：洛谷P4117 [Ynoi2018] 五彩斑斓的世界

    首先在不考虑空间开销的情况下维护一个区间做减法的过程，对序列分块，每个块维护一个最大值，考虑若能够对于一个块在$O(x)$的复杂度内把一个块的元素极差缩小$x$，由摊还分析知道我们处理一个块的复杂度是$O(x+m)$的。对所有大于$x$的数减去$x$，考虑当一个块内的数值位于值域区间$[1,V]$的时候，$X\ge V$的时候跳过不考虑，主要考虑$1\le x <V$的情况，显然我们可以首先考虑一个暴力，把一个块内所有出现相同数字的位置都放到一起，然后枚举$x+1$一直到$V$，把集合合并到其所在的下标减$x$后的集合内。

    + $x> V-x$，那么要在$O(x)$的复杂度内让区间的极差减小$x$，显然直接枚举$[x+1,V]$的每一个数，对应减掉$x$以后
    + $x\le V-x$，那么要在$O(x)$的复杂度内让区间的极差减小$x$，不能枚举大的部分就考虑枚举小的部分，这时候可以有等价操作：给序列中每个小于等于$x$的数加上$x$，然后查询$x$的出现次数的时候需要加上块内偏移量以后查询集合大小。

    显然，集合的合并可以使用并查集，每个块维护并查集，把所有一样的数合并，记录每个集合的根元素位置以及大小，对位合并即可。零散块暴力只需要重构。注意到询问不需要在线，并且每个块的询问以及修改操作之间相互独立，只需要把操作离线逐块处理就可以做到空间线性。

  + 例题4：洛谷P5065 [Ynoi2014] 不归之人与望眼欲穿的人们

  + 例题5：

+ 值域分块

  一般要套序列分块一起使用，用于求解区间第K大。一般用$cnt1(i,j)$表示前$i$个块内j出现了多少次，$cnt2(i,j)$表示前$i$个块内值域有多少数位于值域的第$j$个块内，然后零散部分（如果询问跨块，那么零散部分就是左右两端，否则就是询问的序列）记录$cnt3(i)$为零散部分有多少$i$，$cnt4(i)$为零散部分有多少数落入值域块$i$，然后从小到大枚举值域块，类似于线段树二分，如果定位了某个块就枚举这个值域块内部的元素，求解完成后撤销零散块贡献。

  + 例题：区间x变y，区间K小值（洛谷P4119 [Ynoi2018] 未来日记）

    首先按照上面说的进行序列与值域分块，然后每个块记录一个映射，$f1(i)$表示当前块内$i$代表什么数，$f2(i)$表示当前块内什么数代表$i$，然后零散块修改直接重构，记录块内有多少$x$，整块考虑三种情况：

    + 没有$x$，那么直接跳过；

    + 有$x$，没有$y$，直接用上面提到的$f1$、$f2$进行映射，同时记录块内有多少个$x$；
    + 有$x$，有$y$，直接重构这个块，记录块内有多少$x$。

    然后对于修改，记录每个块有多少$x$被修改，求一个前缀和后对$cnt1$、$cnt2$进行修改维护。

    这个复杂度看起来是假的，但实际上仍然是$O(n \sqrt{n})$的（认为序列长度与询问量同阶），考虑一个整块的重构会用$O(\sqrt{n})$的代价将这个块内的数字种类减1，而一个块的数字种类至多是$\sqrt{n}$个，只有一次零散块的重构才会给这个数增加$1$，零散块的重构次数不超过$2n$，所以总的重构次数不会超过$O(n+m)$，总的重构代价与总复杂度渐进表示一致。

----

#### 嵌套数据结构树套树

说白了就是外面一个维护序列的数据结构，里面一个维护集合的数据结构。具体而言就是维护序列的数据结构的每个结点都需要维护这个结点所代表的区间内所有元素的可重集。

树套树用于维护区间第K大、区间x的排名、区间查找前驱后继等应用。

除非内层是权值线段树，否则树套树求解区间第K大都需要多一个$log$，因为权值线段树虽然可能由于动态开点的缘故形态不同，但是所有不同的权值线段树上对应结点的代表区间一致，所以可以在若干棵线段树上同时二分向下走，省去了每一次再跑一遍外层数据结构的复杂度。

| 数据结构类型            | 空间复杂度     | 单点修改时间复杂度 | 区间x的排名   | 区间第K大       |
| ----------------------- | -------------- | ------------------ | ------------- | --------------- |
| 树状数组/线段树套平衡树 | $O(nlogn)$     | $O(log^2n)$        | $O(log^2n)$   | $O(logVlog^2n)$ |
| 树状数组套权值线段树    | $O(nlogVlogn)$ | $O(logVlogn)$      | $O(logVlogn)$ | $O(logVlogn)$   |

一些例题：

+ 区间数颜色

  + 单点修改（洛谷P1903 [国家集训队] 数颜色）

    考虑如何沿用上面那个一个$log$的思路，维护某一个位置的$pre$，求解区间内有多少数小于$x$，显然$pre$只涉及两种元素的变动，考虑对于每一种颜色开一个set，记录所有这种颜色出现的位置，然后对于一个位置，求出当前颜色的后继、目标颜色的前驱后继，树套树单点修改（强制在线）或者cdq分治求解（允许离线）。

  + 区间赋值（洛谷P4690 [Ynoi2016] 镜中的昆虫）

    考虑依然沿用上面记录$pre$数组的做法，然后把颜色相同的位置缩成一段，采用类似于珂朵莉树的形式维护，然后对于一段的修改操作，若一个颜色段完全位于区间内部则只需要修改这一段开头位置的pre值，否则需要修改这一段分裂后分裂处的$pre$值，至多需要修改$2$个位置。容易发现在这个过程中我们以$O(nlong)$的代价使颜色段数的数目至少减少$n-2$个，在初始化以及后面的操作中颜色段数总量不会超过$O(n+m)$，利用摊还分析可以证明复杂度正确，同时$O(n+m)$也就是需要单点修改的$pre$的总量。只需要把这么多个操作放在树套树上或者cdq分治就可以解决。

+ 三维偏序

  考虑
  
+ 离线化的树套树：整体二分

  这里以单点修改，区间第K大为例，讲解整体二分的实现方法。（洛谷P2617 Dynamic Rankings）

  将序列中的每个初始的数表示为单点插入，然后将询问与修改都放进一个大数组里一起操作。询问的形式就是求解一个区间的第K大，序列初始化的形式是单点增加一个数，修改的形式是单点移除一个数再加入另一个数。所有的操作从左到右按照时间顺序递增。预先开好一个允许单点加区间求和的数据结构，以及两个栈$stk1$、$stk2$用来分离所有的操作。

  在我们已知所有的元素的取值范围以及所有的操作以后，设函数$solve(L,R,l,r)$表示当前处理所有的修改的值域以及询问的答案均位于区间$[L,R]$内，这一部分在所有的操作序列$[l,r]$中。考虑二分法检查答案，令$mid=\lfloor \frac{R+L}{2} \rfloor$，然后从$l$到$r$枚举操作，若此时对应的增加/移除操作，且这个操作的权值小于等于$mid$，就在一个新的数组内把这个位置的值增加/减少$1$，并且把这个修改放入$stk1$，否则只需要放入$stk2$；若遇到查询操作，就在序列中查询这一段有多少个$1$，也就是检查当前这一段内值域位于$[l,mid]$中的数有多少，设这个数值为$offset$，若$rank \le offset$则把这个询问放入$stk1$，否则将$rank$减去$offset$，然后把询问放入$stk2$。这个过程类似于线段树上二分，也就是查询左子树中的元素个数以决定向哪一个子结点迭代。处理完以后就把$stk1$中的操作进行一遍撤销，将两个栈中的操作放回操作序列$[l,r]$，其中$stk1$在左，$stk2$在右，向下递归$solve(L,mid,l,l+top1-1)$和$solve(mid+1,R,l+top,r)$。当递归到某一段没有询问的时候就返回，当值域区间长度为$1$的时候，就可以直接更新对应操作区间内询问的答案了。

  复杂度证明：显然一个操作只会出现在$logV$个值域区间内，每个操作恰好对应一次数据结构的修改或者查询，故总复杂度$O((n+m)lognlogV)$。

  提供一个单点修改，区间第K大的写法：

  ```c++
  struct option {
  	int id, x, y, z;
  } s[maxn << 1], stk1[maxn], stk2[maxn];
  //当id为0的时候为修改操作，把x位置移除/增加一个y
  //id为正的时候为询问编号，询问区间[x,y]的第z大
  void solve(int l, int r, int L, int R) {
  	if (l > r) return;
  	if (L == R) {
  		for (int i = l; i <= r; ++i) if (s[i].id) ans[s[i].id] = L;
  		return;
  	}
  	int mid = (L + R) >> 1, pos = l, top1 = 0, top2 = 0;
  	for (int i = l; i <= r; ++i) {
  		if (!s[i].id) {
  			if (s[i].y <= mid) update(s[i].x, s[i].z), stk1[++top1] = s[i];
  			else stk2[++top2] = s[i];
  		}
  		else {
  			int k = query(s[i].y) - query(s[i].x - 1);
  			if (s[i].z <= k) stk1[++top1] = s[i];
  			else { s[i].z -= k; stk2[++top2] = s[i]; }
  		}
  	}
  	for (int i = 1; i <= top1; ++i) {
  		if (!stk1[i].id) update(stk1[i].x, -stk1[i].z);
  		s[pos++] = stk1[i];
  	}
  	for (int i = 1; i <= top2; ++i) s[pos++] = stk2[i];
  	solve(l, l + top1 - 1, L, mid), solve(l + top1, r, mid + 1, R);
  }
  ```
  
  别的可以用整体二分解决的题目：
  
  + 例题1：洛谷P3332 [ZJOI2013] K大数查询
  + 例题2：洛谷P1527 [国家集训队] 矩阵乘法
  + 例题3：洛谷P3527 [POI2011] MET-Meteors
  + 例题4：洛谷P4175 [CTSC2008] 网络管理
  + 例题5：洛谷P7424 [THUPC2017] 天天爱射击
  + 例题6：洛谷P3242 [HNOI2015] 接水果

----

#### 能够快速预处理的静态区间查询

+ 倍增rmq，ST表

  以求解区间最大值为例，$f(i,j)$表示闭区间$[i,i+2^j-1]$的最大值，有递推式$f(i,j)=max(f(i,j-1),f(i+2^{(j-1)},j-1))$，初始化$f(i,0)=a[i]$，查询区间$[l,r]$则令$t=\lfloor log_2(r-l+1) \rfloor$，查询$max(f(l,t),f(r-2^t+1,t))$。同理可以应用于区间$min$，区间$and$、区间$or$、区间最大公约数最小公倍数，区间线性基等具有结合律、幂等运算或者至多能够产生一次贡献的操作。

+ 可以优化至$O(n+m)$的rmq

  + 随机数据下期望$O(n+q)$的区间最值求解（洛谷P3793 由乃救爷爷）

    对序列分块，预处理每个块前缀后缀的答案，以及块到块的答案，这两个操作均可以在$O(n)$内完成，然后对于跨块的询问，直接将询问拆成两个零散块与中间块的答案$O(1)$求出，否则直接暴力扫出落在一个块内的答案。

    为什么这个复杂度是对的呢？考虑有多少种情况需要暴力求解，答案是$\Theta(n\sqrt{n})$级别的，所有的询问的情况是$\Theta(n^2)$级别的，在所有可能的询问出现概率相等的情况下，我们有$\Theta(\frac{1}{\sqrt{n}})$的概率进行一次暴力，这个部分的期望复杂度是$O(m\times\frac{1}{\sqrt{n}}\times\sqrt{n})$也就是$O(m)$的，其它的询问均可以在$O(1)$完成，故总复杂度的期望是线性的。

    而且这个东西也不好卡，如果要卡的话需要调小询问长度，显然就有着很大的风险把暴力选手放过去。

  + 约束rmq的$O(n+m)$求解

    ”约束“的意思是整个序列中的相邻元素的差的绝对值恰好为1，利用这个特殊条件可以将问题进行优化。

    + 首先进行分块，按照$size=\lceil\frac{(log_2n)}{2}\rceil$为一块进行分块，然后求出单块内部前缀后缀的最大值，整块间使用ST表处理，这一部分的复杂度是$O(n)$的。
    + 当询问跨块的时候，直接零散块查表以后大块rmq，考虑当询问落在一个块内的时候怎么处理，我们要充分利用差值的绝对值为正负1的条件，需要额外记录一下每个块中的最小值是多少，然后把这个块内的所有元素减去这个最小值，注意到块长很短，全做减法以后相邻差值不变，我们认为两个块不同当且仅当在减去块内最小值以后，块内存在若干元素不同。此时由于差分数组的取值只有正负1，本质不同的块至多有$2^{0.5log_2n}$种，这个是$O(\sqrt{n})$级别的，因此对这本质不同的$O(\sqrt{n})$种块跑$O(size^2)$的暴力处理结果，查询时直接映射即可。这部分处理复杂度亚线性，单次查询$O(1)$。记得查询完以后把减去的最小值加回来。

  + $O(n\alpha(n)+m)$的做法：

+ 猫树：分治实体化的产物

----

#### 莫队

+ 普通莫队
  + 适用范围：一些可以在$O(nm)$复杂度下暴力求解的区间询问题目，可以在已知一个区间的所有信息以及这个区间的答案的情况下$O(1)$扩展到相邻区间。不带修改，允许离线。
  
  + 实现方式：将所有的询问排序，对序列分块，以左端点所在块为第一关键字升序排序，右端点为第二关键字升序排序，维护两个指针左右移动，做完一个询问就暴力移动指针维护区间的信息与答案至下一个询问。
  
  + 复杂度证明：设块长大小为$B$，那么总的分块数就是$\frac{n}{B}$，考虑复杂度来源于哪个部分：
  
    + 左端点在一个块内移动：每个询问至多移动块长，$O(\frac{nm}{B})$。
    + 左端点跨块移动：每个块至多向右跨一次。$O(n)$。
    + 左端点所在块相同的时候，右端点移动：每个块都对应移动序列长度数量级，$O(\frac{n^2}{B})$。
    + 左端点跨块的时候，右端点移动：$O(\frac{n^2}{B})$。

    假设$n$与$m$同阶，当$B$取$\sqrt{n}$的时候总复杂度$O((n+m)\sqrt{n})$。
  
  + 例题
    + 例题1：洛谷P1494 [国家集训队]小Z的袜子
    + 例题2：洛谷P2709 小B的询问
    + 例题3：洛谷P3730 曼哈顿交易
    + 例题4：洛谷P4137 Rmq Problem / mex
    + 例题5：洛谷P4396 [AHOI2013] 作业
    + 例题6：洛谷P4462 [CQOI2018] 异或序列
  
+ 带修莫队
  + 适用范围：允许在普通莫队$O(nm)$暴力求解的同时，在已知某个区间信息以及答案的同时$O(1)$扩展到相邻区间，或者进行一次单点修改的区间查询问题。
  + 实现方式：以$n^\frac{2}{3}$为大小分块，所有的询问离线，修改单独放到一个数组内，记录每个询问发生在多少个修改过后。所有的询问以左端点所在块为第一关键字升序，右端点所在块为第二关键字升序，时间轴为第三关键字升序排序。
  + 复杂度证明：

    + 左端点移动复杂度：一个左端点不跨块时候$O(Bm)$，跨块移动$O(n)$。
    + 右端点移动复杂度：左端点在一个块内的时候$O(Bm)$，左端点不变右端点跨块的时候$O(\frac{n^2}{B})$，左端点变化右端点跨块的时候$O(\frac{n^2}{B})$。
    + 时间轴移动复杂度：不同的左右端点所在块都会让时间轴递增移动，复杂度$O(\frac{n^2m}{B^2})$，左右端点所在块变动的时候，时间轴回调也是这个复杂度。

    综上，若认为$n$与$m$同阶，则当$B=n^ \frac{2}{3}$的时候复杂度为$O(n^\frac{5}{3})$。
  + 例题：洛谷P1903 [国家集训队] 数颜色

+ 回滚莫队
  + 适用范围：有一些区间信息允许$O(1)$扩展到一个包含当前区间的大区间，但是不允许$O(1)$区间缩减（如取minmax）。
  + 实现手法：首先筛选出左右端点落在同一个块内的询问，暴力处理。其余的询问按照左端点所在块为第一关键字，右端点为第二关键字排序，枚举在同一块内的询问时，右端点指针初始化为当前块的右端点，然后不断向右扩展直至出现一个询问的右端点，然后左边只需要暴力从右向左把散块的信息加进去，并且记录加入信息的时候发生了哪些修改，做完询问就按加入顺序的反向撤销，然后继续让右端点递增左端点扩展，如此循环直至左端点在这个块内的询问都被处理完，然后清空所有的记录信息再处理下一个块的询问。
  + 例题
    + 洛谷P5906 【模板】回滚莫队
    + SPOJ20644 ZQUERY - Zero Query
    + ATCoder1219 歴史の研究
    + CF522D Closest Equals
  
+ 树上莫队
  + 适用范围：离线求解树上路径集合问题。
  
  + 实现手法：对于一棵树，dfs的时候需记录入栈序以及出栈序，即一棵树的欧拉序。每个节点会恰好在欧拉序中出现两次，记为它们的左端点$lsid$以及右端点$rsid$。欧拉序有如下性质：（均假设$lsid(x)<lsid(y)$）
  
    + 当结点$xy$互不为对方祖先结点的时候，有$rsid(x)<lsid(y)$，且欧拉序中$[rsid(x),lsid(y)]$这一段区间中只出现过一次的编号等于这条链上的所有除$LCA(x,y)$以外的点。
    + 当结点$x$是$y$的祖先结点的时候，有$rsid(y)<rsid(x)$，欧拉序中$[lsid(x),lsid(y)]$这一段区间中只出现过一次的编号等于这条链上的所有点。
  
    有以上两个性质，可以对$xy$的位置关系进行讨论，然后就是出现一次算加入，出现两次的时候就移除，其余的就套普通的莫队的模板即可。
  
  + 例题
  
    + SPOJ10707 COT2 - Count on a tree II
    + 洛谷P4074 [WC2013] 糖果公园
  
+ 二次离线莫队

  + 适用范围：用于区间更新所需要的信息可以差分成两个前缀和相减、进而转化成扫描线可以维护的形式的可以莫队的题目。以例题的形式讲解如何应用这个思想。

  + 例题

    + 例题1：洛谷P5047 [Ynoi2019 模拟赛] Yuno loves sqrt technology II

      考虑莫队时需要的信息，如果直接硬维护的话需要维护区间内出现了什么数，以及查询多少数比$x$大/小，考虑将所有的询问进行离线，每个询问的形式是某个区间内比$x$大/小的数有多少个，然后进行一步差分，这里以求解$l$到$r$内有多少数比$r+1$位置的数大为例：差分变成求解$1$到$r$内有多少数比$r+1$位置的数大、$1$到$l-1$内有多少数比$r+1$位置的数大，注意到前者与$l$无关，可以直接处理，后者继续离线，注意到询问的形式都是某个前缀中比某个数小或大，采用一个权值数据结构，从左到右一个一个加入元素，求解对应位置前缀的答案，这是一个$O(n)$插入总量$O(n\sqrt{n})$询问总量的扫描线，使用值域分块平衡两端复杂度，容易实现一个分块，满足$O(\sqrt{n})$单点修改$O(1)$前缀求和，利用这个可以将时间复杂度优化至$O(n\sqrt{n})$，但此时空间复杂度依然是$O(n\sqrt{n})$。

      注意到莫队的区间移动操作，当一个端点没有移动到指定位置的时候，另一个端点一直固定不动，且这个移动的端点一定是经过一个区间，那么我们依然以上面求解l到r内有多少数比$r+1$位置的数大为例，差分后与$l$无关的那部分前缀和$O(1)$查到，与$l$有关的一部分记录一个区间即可，这部分的空间开销优化至$O(m)$。

      时间复杂度$O((n+m)\sqrt{n})$，空间复杂度$O(n+m)$。

    + 例题2：洛谷P4887 第十四分块(前体)
    + 例题3：洛谷P5501 [LnOI2019] 来者不拒，去者不追
    + 例题4：洛谷P5398 [Ynoi2018] GOSICK

+ 莫队的常数优化技巧&细节
  + 优化1：调节块长。这个比较玄学。优化效果取决于各种地方的实现方式。一般情况下在$nm$同阶的时候，建议块长比$\sqrt{n}$略小一些。但不排除某些题目中询问量与序列长度数量级差别较大的情况。
  + 优化2：考虑对于左端点落在一个块内的询问，其右端点指针一定是向右移动的；在左端点移向下一个块的时候，右端点指针会大概率向左移动到此块第一个询问处，如果能够在这个左移的过程中处理掉所有的询问，而不是左移以后再右移去处理询问，常数会获得一定程度的优化。具体实现起来，以左端点所在块为第一关键字，右端点为第二关键字，左端点所在块的下标为奇数的时候，右端点升序排序，反之降序排序。
  + 细节：若四个while循环排布顺序不当，可能会导致指针$l>r$的情况，有可能会造成数组内存下溢。所以优先考虑扩展两端区间，然后再考虑收缩区间。

---

#### 笛卡尔树

笛卡尔树是一棵二叉树，满足堆性质，

+ 
+ 例题
  + 例题1：洛谷P6453 [COCI2008-2009#4] PERIODNI
  + 例题2：洛谷P5044 [IOI2018] meetings 会议

----

### 维护动态序列的数据结构

----

#### Splay

允许很方便的在保持中序遍历不变的情况下把一个结点转到根并保持复杂度。

+ 维护序列的写法
+ 复杂度分析

----

#### FHQ-Treap

又称之为非旋树堆，允许以分裂的形式将一个treap按照中序遍历分为两个部分。

+ 维护序列的写法

+ 可持久化平衡树

----

#### 块状链表

----

#### WBLT

奇怪的数据结构，复杂度不对但是跑得很快，好写，难卡。

----

### 维护K维空间的数据结构&算法

----

#### CDQ分治

----

#### 二维树状数组

+ 单点修改，矩阵求和

  说白了就是树状数组套树状数组。

+ 矩阵加法，矩阵求和（洛谷P4514 上帝造题的七分钟）

  这是一个经典树状数组套路了，首先一步简单容斥转化为$[1,1]$到$[x,y]$上面的矩阵加矩阵求和，考虑沿用一维树状数组的思路进行差分，考虑弱化问题矩阵加法单点修改，假设左上角为$[x1,y1]$，右下角为$[x2,y2]$，差分修改为$[x1,y1]$、$[x2+1,y2+1]$加1，$[x1,y2+1]$、$[x2+1,y1]$减1，单点查询变为二维前缀和；然后考虑把这些单点信息加起来。设差分数组为$a[i,j]$，则考虑每个差分数组的元素会被多少个单点计算到，得到二维前缀和：
  $$
  ans=\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j]\times(x-i+1)\times(y-j+1) \\
  =\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j]\times(xy-x(j-1)-y(i-1)+(i-1)(j-1))\\
  =xy\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j]-x\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j](j-1)-y\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j](i-1)+\sum_{i=1}^{x}\sum_{j=1}^{y}a[i][j](i-1)(j-1)
  $$
  于是记录差分数组以及上面衍生出来的四个数组，四个二维树状数组维护即可。

----

#### 二维线段树&四分树

----

#### KD-Tree

----

### 维护树的数据结构

----

#### 树链剖分

+ 轻重链剖分

  考虑dfs的时候记录dfs序，把尽可能多的点放在一条自上而下dfs序连续的一段上面，使得我们可以用维护序列的数据结构维护树上路径。给每个非叶子结点向下连一条边，称为重边，这条边指向的结点称作重儿子；其余的指向子结点的边称为轻边，与此对应，称这些子结点为轻儿子。连续的重边自上而下连接在一起，称为重链。当我们dfs时访问到一个有重儿子的结点，那么优先访问重儿子，再访问轻儿子，让一条重链的dfs序自上而下连续递增。

  考虑链上的操作可以通过dfs序映射到一个序列上，一条重链对应一个连续的区间。特别的，认为没有重儿子的结点算作长度为$1$的重链，那么考虑如何让每个点到根上的路径中，轻重链切换次数最少，使得对维护序列的数据结构操作次数最少。方案是把最子树大小最大的子结点设为重儿子，在这种情况下每个结点到根结点的轻重链切换次数为$O(logn)$。

  这个证明比较简单，考虑从一个结点向上走，这个结点指向父结点的边是轻边当且仅当存在一个兄弟结点，这个兄弟结点的子树大小大于等于这个结点的子树大小。显然这个时候向上走一步，子树大小会至少翻一倍，翻倍的次数至多是对数级别的，也就是说每个结点到根结点的轻重链切换次数都是$O(logn)$的。

  具体实现的时候需要实现两个dfs。第一遍dfs，预处理出这棵树每个点的父结点、结点深度、子树大小、重儿子是谁，第二个dfs需要记录dfs序、每个重链中的结点的链顶结点编号。链上操作只需要不断跳重链就可以实现。

  下面给出一个简单的链加链求和的实现。省略数据结构部分的具体实现。

  ```c++
  int top[maxn], fa[maxn], siz[maxn], deep[maxn], son[maxn], dfn[maxn], tot;
  //top代表一条重链的顶端结点编号，fa记录父节点，siz记录子树大小，deep记录结点深度，son表示重儿子，dfn为dfs序
  void dfs1(int pos) {
  	siz[pos] = 1;
  	for (int i = head[pos]; i; i = nxt[i]) {
  		if (to[i] == fa[pos]) continue;
  		fa[to[i]] = pos, deep[to[i]] = deep[pos] + 1, dfs1(to[i]);
  		siz[pos] += siz[to[i]];
  		if (siz[to[i]] > siz[son[pos]]) son[pos] = to[i];
  	}
  }
  void dfs2(int pos) {
  	dfn[pos] = ++tot;
  	if (!top[pos]) top[pos] = pos;
  	if (son[pos]) top[son[pos]] = top[pos], dfs2(son[pos]);
  	for (int i = head[pos]; i; i = nxt[i]) {
  		if ((to[i] != son[pos]) && (to[i] != fa[pos])) dfs2(to[i]);
  	}
  }
  inline void modify(int x, int y, int val) {
  	while (top[x] != top[y]) {
  		if (deep[top[x]] < deep[top[y]]) std::swap(x, y);
  		modify(1, n, dfn[top[x]], dfn[x], root, val);
  		x = fa[top[x]];
  	}
  	if (deep[x] < deep[y]) std::swap(x, y);
  	modify(1, n, dfn[y], dfn[x], root, val);
  }
  inline int query(int x, int y) {
  	int res = 0;
  	while (top[x] != top[y]) {
  		if (deep[top[x]] < deep[top[y]]) std::swap(x, y);
  		res += query(1, n, dfn[top[x]], dfn[x], root);
  		x = fa[top[x]];
  	}
  	if (deep[x] < deep[y]) std::swap(x, y);
  	res += query(1, n, dfn[y], dfn[x], root);
  	return res;
  }
  ```

  例题：

  + 洛谷P7735 [NOI2021] 轻重边

    + 解法1：考虑在一棵树已经做好重链剖分的情况下如何处理信息，注意到重链剖分中的轻边至多只会被处理$O(logn)$次，并且实际操作中会发现跳轻边的长度每次均为$1$，是位于两条重链切换的位置。每次染完色以后可以发现，一个点至多有两条与之相连的边边权为$1$可以直接记录，那么用两个维护序列的数据结构，一个维护重链的信息，用每个对应的重儿子承接信息；一个维护轻边的信息，用这条轻边的父节点记录哪条轻边权值为$1$。由于至多记录两个，可以直接维护。

      实际处理的时候，对于修改操作：首先把两个链上的信息清空一下，在对应存储轻重链的数据结构都清空一下，特殊考虑区间端点为非重链链尾的情况，以及最终处理至$LCA$处的情况；然后实现链加、单点插入即可。对于查询操作，在维护重链的数据结构上直接查，维护轻链的部分在重链切换的部分查。

    + 解法2：考虑等价问题，对点进行染色，一条边的权值是$1$当且仅当其相连的两个点的颜色相同，每一次操作一次相当于给这个树的对应路径染上一种从未有过的颜色，查询就是普通的区间信息合并，那么初始化每个点颜色均不相同即可。用重链剖分加上线段树维护。

  + 

+ 长链剖分

  类似于重链剖分，惟一的区别是重儿子指向的是向下能够走出路径最长的一个子节点，类似的可以分析出每个结点到根结点的轻重链切换次数都是$O(\sqrt{n})$的。

  应用：DP优化、K级祖先查找优化

  + 快速求K级祖先

  + 树形DP优化

----

#### 换根操作

大多数的换根都是唬人的，都只需要考虑dfs序上面的操作。

+ 例题1：洛谷P3979 遥远的过度

  链覆盖可以直接树剖解决，主要讨论树剖过后的换根子树查询。假设我们以1作为树剖的根，讨论换完以后根不是1的情况。假设换过以后的根是$root$，要查询的子树以$x$为根：

  + $lca(x,root)=root$：说明在以1为根的时候，$x$在$root$的子树里面，对应$[dfn[x],dfn[x]+size[x]-1]$。
  + $lca(x,root)=x$：说明$root$在$x$的子树里面，此时用倍增法求出$root$的某个祖先$y$，使得$fa[y]=x$，可以看出此时对应的区间是全局剔除$[dfn[y],dfn[y]+size[y]-1]$这部分，即$[1,dfn[y]-1]与[dfn[y]+size[y],n]$两部分。
  + 以上两种情况以外：对应$[dfn[x],dfn[x]+size[x]-1]$。

+ 例题2：洛谷P4689 [Ynoi2016] 这是我自己的发明

  看明白了换根的思路，其实这个是版块“根号分治”里面的数点问题。dfs序把树拍成序列，然后沿用出现次数少的用二维偏序，出现次数多的前缀和统计的思路就可以了。

----

#### 树上启发式合并

----

#### 虚树

----

#### 动态树

+ LCT
+ ETT

----

#### 点分治

----

#### 点分树

----

#### 边分治

----

#### 边分树

----

#### 树分块

----

#### 一类树上距离求和问题

+ 例题1：洛谷P4211 [LNOI2014] LCA
+ 例题2：洛谷P3241 [HNOI2015] 开店
+ 例题3：

#### 树形动态DP

----

### 维护图的数据结构

----

#### 圆方树

----

#### 动态图

----

### 根号分治专题

----

#### 模剩余系下标的求和

+ 例题1：洛谷P3396 哈希冲突
+ 例题2：洛谷P5309 [Ynoi2011] 初始化

----

#### 涉及元素出现次数的分治

众所周知若一个多重集大小为$n$，则内部出现次数大于$\sqrt{n}$的元素种类不会超过$\sqrt{n}$种，利用这个性质可以进行数据分治。

+ 例题1：洛谷P5268 [SNOI2017] 一个简单的询问
  + 解法1：把式子拆开成询问跑莫队
  + 解法2：设这个序列为$a$，对于全局出现次数大于$\sqrt{n}$的元素，一共不会超过$\sqrt{n}$种。暴力的枚举每一种元素，做前缀和，给每个询问都暴力枚举一遍。对于出现次数小于$\sqrt{n}$的元素，考虑二维偏序，也就是说建立一个$n\times n$的平面，平面上一点$(x,y)$的权值为$1$当且仅当$a[x]=a[y]$。显然固定一个$x$，令$(x,y)$处的值为$1$的$y$不超过$\sqrt{n}$个位置。直接枚举就可以。对于询问$[l,r]$，就是求解二维平面上$l\le x \le r$，$l\le y \le r$的矩形元素和。此时问题转化为有$O(n\sqrt{n})$个点，$O(m)$个询问的的二维偏序，用一个$O(1)$单点加法，$O(\sqrt{n})$的值域分块维护。
  
+ 例题2：洛谷P5072 [Ynoi2015] 盼君勿忘

  注意到这个形式就是考虑贡献，考虑一个元素$x$在多少个子序列里出现过，正难则反考虑全集减去不出现的情况，设这个区间的长度为$len$，$x$就在$(2^{len}-1)-(2^{len-cnt(x)}-1)=2^{len}-2^{len-cnt(x)}$这么多个序列中出现过，$cnt(x)$就是在这个询问区间内$x$出现的次数，这个区间的答案就是$x$乘上对应出现次数的和，也就是
  $$
  ans=\sum_{x\in a[l,r]} x(2^{r-l+1}-2^{r-l+1-cnt(x)})
  $$
  考虑对出现次数进行分治，出现次数小于等于$\sqrt{n}$的元素，记录$sum1(i)$表示出现次数为$i$的数的和，也就是按照出现次数相同的进行分类，统计时直接计算；出现次数大于$\sqrt{n}$的元素，全局记录多少数出现次数大于$\sqrt{n}$，显然不会超过$\sqrt{n}$个，直接枚举每一个进行统计即可。出现次数可以用莫队直接维护，不同的模数采用光速幂根号打表实现。
  
+ 例题3：洛谷P5397 [Ynoi2018] 天降之物

### bitset专题

----

### STL容器专题

----

#### 线性数据结构

+ stack
+ queue&deque
+ vector
+ unordered_set
+ unordered_map

----

#### 非线性数据结构

+ set
  + 使用手法
  + 珂朵莉树
+ map
+ pbds
+ rope

----

### 字符串数据结构专题

----

#### 序列自动机

----

#### AC自动机

用于多串匹配的求解。多串指的是多匹配串单模式串。

首先把

----

#### 后缀数组

----

#### 后缀自动机

----

#### 后缀树

----

#### 后缀平衡树

----

#### 回文自动机

又称之为回文树，是一个有两个树形结构的有向图。用于记录一个字符串的所有回文子串。

